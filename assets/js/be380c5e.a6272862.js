"use strict";(globalThis.webpackChunkengineering_iog_io=globalThis.webpackChunkengineering_iog_io||[]).push([[7092],{2484:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var t=a(8168),r=(a(6540),a(5680));const l={slug:"2022-04-28-on-the-inlining-of-integer-and-natural-operations",title:"On the inlining of Integer and Natural operations",authors:["sylvain"],tags:["ghc"],custom_edit_url:null},i=void 0,o={permalink:"/2022-04-28-on-the-inlining-of-integer-and-natural-operations",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2022-04-28-on-the-inlining-of-integer-and-natural-operations-bot8CUQvoe-import.md",source:"@site/blog/2022-04-28-on-the-inlining-of-integer-and-natural-operations-bot8CUQvoe-import.md",title:"On the inlining of Integer and Natural operations",description:"In this post I discuss the inlining of Integer and Natural operations in Haskell. It\u2019s a promising performance work I\u2019ve been conducting six months ago, which was blocked by an independent issue, but that I will likely resume soon as the issue has been fixed in the meantime.",date:"2022-04-28T00:00:00.000Z",formattedDate:"April 28, 2022",tags:[{label:"ghc",permalink:"/tags/ghc"}],readingTime:4.135,hasTruncateMarker:!1,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"}],frontMatter:{slug:"2022-04-28-on-the-inlining-of-integer-and-natural-operations",title:"On the inlining of Integer and Natural operations",authors:["sylvain"],tags:["ghc"],custom_edit_url:null},prevItem:{title:"Setting up Csaba's External STG Interpreter",permalink:"/2022-05-02-setup-ext-stg-interp"},nextItem:{title:"GHC March 2022 Update",permalink:"/2022-04-19-ghc-march-2022-update"}},s={authorsImageUrls:[void 0]},p=[],g={toc:p},d="wrapper";function u({components:e,...n}){return(0,r.yg)(d,(0,t.A)({},g,n,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"In this post I discuss the inlining of Integer and Natural operations in Haskell. It\u2019s a promising performance work I\u2019ve been conducting six months ago, which was blocked by an independent issue, but that I will likely resume soon as the issue has been fixed in the meantime."),(0,r.yg)("hr",null),(0,r.yg)("p",null,"To follow this post, you must know that ",(0,r.yg)("inlineCode",{parentName:"p"},"Natural")," numbers are represented as follows in ",(0,r.yg)("inlineCode",{parentName:"p"},"ghc-bignum"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"-- | Natural number\n--\n-- Invariant: numbers <= WORD_MAXBOUND use the `NS` constructor\ndata Natural\n   = NS !Word#\n   | NB !BigNat#\n")),(0,r.yg)("p",null,"Small naturals are represented with a ",(0,r.yg)("inlineCode",{parentName:"p"},"Word#")," and large ones with a ",(0,r.yg)("inlineCode",{parentName:"p"},"BigNat#")," (a ",(0,r.yg)("inlineCode",{parentName:"p"},"ByteArray#"),")."),(0,r.yg)("p",null,"Now consider the following simple example using Natural:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"-- | Add 2 to a Word. Use Natural to avoid Word overflow\nfoo :: Word -> Natural\nfoo x = fromIntegral x + 2\n")),(0,r.yg)("p",null,"There are only small naturals involved: ",(0,r.yg)("inlineCode",{parentName:"p"},"fromIntegral x")," is small because ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," is a ",(0,r.yg)("inlineCode",{parentName:"p"},"Word"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"2")," is small. We could hope that GHC would use ",(0,r.yg)("inlineCode",{parentName:"p"},"Word#")," primops to implement this and would allocate a ",(0,r.yg)("inlineCode",{parentName:"p"},"Natural")," heap object for the result ",(0,r.yg)("em",{parentName:"p"},"only"),". However it\u2019s not what happens currently, even in GHC HEAD. In the following STG dump, we can see that a ",(0,r.yg)("inlineCode",{parentName:"p"},"Natural")," heap object is allocated for ",(0,r.yg)("inlineCode",{parentName:"p"},"x")," before calling ",(0,r.yg)("inlineCode",{parentName:"p"},"naturalAdd")," (",(0,r.yg)("inlineCode",{parentName:"p"},"let")," bindings in STG reflect heap allocations):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"foo1 = NS! [2##];\n\nfoo =\n    \\r [x_sXn]\n        case x_sXn of {\n        W# x#_sXp ->\n        let { sat_sXq = NS! [x#_sXp]; } in  naturalAdd sat_sXq foo1;\n        };\n")),(0,r.yg)("p",null,"Let\u2019s look at ",(0,r.yg)("inlineCode",{parentName:"p"},"naturalAdd"),":"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"-- | Add two naturals\nnaturalAdd :: Natural -> Natural -> Natural\n{-# NOINLINE naturalAdd #-}\nnaturalAdd (NS x) (NB y) = NB (bigNatAddWord# y x)\nnaturalAdd (NB x) (NS y) = NB (bigNatAddWord# x y)\nnaturalAdd (NB x) (NB y) = NB (bigNatAdd x y)\nnaturalAdd (NS x) (NS y) =\n   case addWordC# x y of\n      (# l,0# #) -> NS l\n      (# l,c  #) -> NB (bigNatFromWord2# (int2Word# c) l)\n")),(0,r.yg)("p",null,"We are clearly in the last case where both arguments are small. It seems beneficial to allow this function to be inlined. If we did we would get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-javascript"},"foo =\n    \\r [x_s158]\n        case x_s158 of {\n        W# x#_s15a ->\n        case addWordC# [x#_s15a 2##] of {\n        (#,#) l_s15c ds_s15d ->\n        case ds_s15d<TagProper> of ds1_s15e {\n          __DEFAULT ->\n              case int2Word# [ds1_s15e] of sat_s15f {\n              __DEFAULT ->\n              case bigNatFromWord2# sat_s15f l_s15c of ds2_s15g {\n              __DEFAULT -> NB [ds2_s15g];\n              };\n              };\n          0# -> NS [l_s15c];\n        };\n        };\n        };\n")),(0,r.yg)("p",null,"which produces much better assembly code, especially if there is no carry:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'    addq $2,%rax       ; add 2 to a machine word\n    setc %bl           ; test the carry.\n    movzbl %bl,%ebx    ; it could be done\n    testq %rbx,%rbx    ; more efficiently\n    jne _blk_c17c      ; with "jc"\n_blk_c17i:\n    movq $NS_con_info,-8(%r12) ; alloc NS datacon value\n    movq %rax,(%r12)           ; with the addition result as payload.\n    leaq -7(%r12),%rbx         ; make it the first argument\n    addq $8,%rbp               ; and then\n    jmp *(%rbp)                ; call continuation\n...\n')),(0,r.yg)("p",null,"So why aren\u2019t we always inlining ",(0,r.yg)("inlineCode",{parentName:"p"},"naturalAdd"),"? We even explicitly disallow it with a ",(0,r.yg)("inlineCode",{parentName:"p"},"NOINLINE")," pragma. The reason is that ",(0,r.yg)("inlineCode",{parentName:"p"},"naturalAdd")," and friends are involved in constant-folding rules."),(0,r.yg)("p",null,"For example, consider:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"bar :: Natural -> Natural\nbar x = x + 2\n\nbaz = bar 0x12345678913245678912345679123456798\n")),(0,r.yg)("p",null,"Currently we get the following Core:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"bar1 = NS 2##\n\nbar = \\ x_aHU -> naturalAdd x_aHU bar1\n\nbaz = NB 99114423092485377935703335253042771879834\n")),(0,r.yg)("p",null,"You can see that ",(0,r.yg)("inlineCode",{parentName:"p"},"baz"),"  is a constant thanks to constant-folding."),(0,r.yg)("p",null,"However if we let ",(0,r.yg)("inlineCode",{parentName:"p"},"naturalAdd")," inline we get:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-haskell"},"baz\n  = case bigNatAddWord# 99114423092485377935703335253042771879832 2##\n    of ds_d11H\n    { __DEFAULT ->\n    NB ds_d11H\n    }\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"baz")," is no longer a constant."),(0,r.yg)("p",null,"A solution would be to add constant-folding rules for ",(0,r.yg)("inlineCode",{parentName:"p"},"BigNat#")," functions, such as ",(0,r.yg)("inlineCode",{parentName:"p"},"bigNatAddWord#"),". This is exactly what we have started doing in ",(0,r.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20361"},"#20361"),". Our new plan is:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Make ",(0,r.yg)("inlineCode",{parentName:"li"},"BigNat#")," operation ",(0,r.yg)("inlineCode",{parentName:"li"},"NOINLINE")," and add constant-folding rules for them"),(0,r.yg)("li",{parentName:"ul"},"Make Integer/Natural operations ",(0,r.yg)("inlineCode",{parentName:"li"},"INLINEABLE")," (expose their unfolding)"),(0,r.yg)("li",{parentName:"ul"},"Hence rely on constant-folding for ",(0,r.yg)("inlineCode",{parentName:"li"},"Word#/Int#/BigNat#")," to provide constant folding for ",(0,r.yg)("inlineCode",{parentName:"li"},"Integer")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"Natural"))),(0,r.yg)("p",null,"The good consequences of this plan are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Less allocations when bignum operations are inlined and some of the arguments are known to be small/big or fully known (constant)."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"Integer")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"Natural")," are less magical: you can implement your own similar types and expect the same performance without having to add new rewrite rules")),(0,r.yg)("p",null,"There were some unforeseen difficulties with this plan though:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Some of the rewrite rules we need involve unboxed values such as ",(0,r.yg)("inlineCode",{parentName:"li"},"BigNat#")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"Word#")," and the weren\u2019t supported. Luckily, this has been recently fixed (",(0,r.yg)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/19313"},"#19313"),") by removing the \u201capp invariant\u201d (",(0,r.yg)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20554"},"#20554"),"). Thanks Joachim! That\u2019s the reason why we could resume this work now."),(0,r.yg)("li",{parentName:"ol"},"Some unfoldings (RHSs) become bigger due to the inlining of bignum operations. Hence they may not themselves be inlined further due to inlining thresholds even if it would be beneficial. A better inlining heuristic would fix this (see ",(0,r.yg)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20516"},"#20516"),"). It will likely be the topic of the next post.")))}u.isMDXComponent=!0},5680:(e,n,a)=>{a.d(n,{xA:()=>g,yg:()=>m});var t=a(6540);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach(function(n){r(e,n,a[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))})}return e}function o(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},g=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef(function(e,n){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),d=p(a),c=r,m=d["".concat(s,".").concat(c)]||d[c]||u[c]||l;return a?t.createElement(m,i(i({ref:n},g),{},{components:a})):t.createElement(m,i({ref:n},g))});function m(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"}}]);