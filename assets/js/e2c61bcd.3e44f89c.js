"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[7215],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(n),u=r,h=m["".concat(s,".").concat(u)]||m[u]||c[u]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4529:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},assets:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={slug:"2022-07-26-the-ghcjs-linker",title:"The GHCJS Linker",date:"July 26, 2022",authors:["luite"],tags:["ghc","javascript","linking"]},s=void 0,d={permalink:"/2022-07-26-the-ghcjs-linker",source:"@site/blog/2022-07-26-ghcjs-linker.md",title:"The GHCJS Linker",description:"Introduction",date:"2022-07-26T00:00:00.000Z",formattedDate:"July 26, 2022",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"javascript",permalink:"/tags/javascript"},{label:"linking",permalink:"/tags/linking"}],readingTime:5.125,truncated:!1,authors:[{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"}],frontMatter:{slug:"2022-07-26-the-ghcjs-linker",title:"The GHCJS Linker",date:"July 26, 2022",authors:["luite"],tags:["ghc","javascript","linking"]},prevItem:{title:"GHC DevX July 2022 Update",permalink:"/2022-08-01-ghc-update"},nextItem:{title:"Primitive Type Representation in GHC's upcoming JS-backend",permalink:"/2022-07-20-js-backend-prim-types"}},p={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",children:[],level:2},{value:"JavaScript &quot;executables&quot;",id:"javascript-executables",children:[],level:2},{value:"Building <code>out.js</code>",id:"building-outjs",children:[],level:2},{value:"The Compactor",id:"the-compactor",children:[{value:"Renaming private symbols",id:"renaming-private-symbols",children:[],level:3},{value:"Block Initializer",id:"block-initializer",children:[],level:3},{value:"Deduplication",id:"deduplication",children:[],level:3}],level:2},{value:"Incremental Linking",id:"incremental-linking",children:[],level:2},{value:"Future Improvements",id:"future-improvements",children:[],level:2}],m={toc:c};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"I recently gave a short presentation on the workings of the GHCJS linker. This post is a summary of the content."),(0,i.kt)("h2",{id:"javascript-executables"},'JavaScript "executables"'),(0,i.kt)("p",null,"The task of a linker is collecting and organizing object files and resources into a loadable library or executable program. JavaScript can be run in various environments, for example the browser or node.js, and not in all of these the concept of an executable makes sense."),(0,i.kt)("p",null,"Therefore, when we link a Haskell program, we generate a ",(0,i.kt)("inlineCode",{parentName:"p"},"jsexe")," directory filled with various files that allow us to run the JavaScript result:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"File"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"out.js")),(0,i.kt)("td",{parentName:"tr",align:"center"},"compiled/linked Haskell code")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"out.frefs.*")),(0,i.kt)("td",{parentName:"tr",align:"center"},"list of foreign calls from ",(0,i.kt)("inlineCode",{parentName:"td"},"out.js"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"out.stats")),(0,i.kt)("td",{parentName:"tr",align:"center"},"source code size origin statistics for ",(0,i.kt)("inlineCode",{parentName:"td"},"out.js"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"lib.js")),(0,i.kt)("td",{parentName:"tr",align:"center"},"non-Haskell code, from ",(0,i.kt)("inlineCode",{parentName:"td"},"js-sources")," in packages and RTS. possibly preprocessed")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"rts.js")),(0,i.kt)("td",{parentName:"tr",align:"center"},"generated part of RTS (apply functions and similarly repetitive things)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"runmain.js")),(0,i.kt)("td",{parentName:"tr",align:"center"},"single line just starts ",(0,i.kt)("inlineCode",{parentName:"td"},"main"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"all.js")),(0,i.kt)("td",{parentName:"tr",align:"center"},"complete runnable program, created by combining ",(0,i.kt)("inlineCode",{parentName:"td"},"out.js"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"lib.js"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"rts.js")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"runmain.js"))))),(0,i.kt)("p",null,"Most of the work done by the linker is producing ",(0,i.kt)("inlineCode",{parentName:"p"},"out.js"),", and that's what we'll be focusing on in the next sections."),(0,i.kt)("h2",{id:"building-outjs"},"Building ",(0,i.kt)("inlineCode",{parentName:"h2"},"out.js")),(0,i.kt)("p",null,"The linker builds ",(0,i.kt)("inlineCode",{parentName:"p"},"out.js")," by collecting all code reachable from ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," (and a few other symbols required by the RTS) and generating the required initialization code for all top-level data. The code is found in object files. These object files have the following structure:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Section"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Header"),(0,i.kt)("td",{parentName:"tr",align:"center"},"version number and offsets of other sections")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"String table"),(0,i.kt)("td",{parentName:"tr",align:"center"},"shared string table, referred to by ",(0,i.kt)("inlineCode",{parentName:"td"},"Dependencies")," and ",(0,i.kt)("inlineCode",{parentName:"td"},"Code"),", to avoid duplication in file and memory")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Dependencies"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Dependency data, internally between binding groups and externally to symbols in other object files")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Code"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Compiled Haskell code stored as serialized JavaScript AST and metadata. Code is organized in binding groups")))),(0,i.kt)("p",null,"The object files contain binding groups of mutually dependent bindings. These are the smallest units of code that can be linked. Each binding group has some associated metadata required for initialization of the heap objects in the group. The metadata contains for example constructor tags (e.g. 1 for ",(0,i.kt)("inlineCode",{parentName:"p"},"Nothing"),", 2 for ",(0,i.kt)("inlineCode",{parentName:"p"},"Just"),"), the arity of functions and static reference tables."),(0,i.kt)("p",null,"From a high level, the procedure that the linker follows is this:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Step"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Read object files from dependencies into memory")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Decode dependency part of all object files in dependencies (includes reading the string tables)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Using dependency data, find all code reachable from ",(0,i.kt)("inlineCode",{parentName:"td"},"main"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Decode reachable binding groups")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Render AST to JavaScript")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"Construct initializers from metadata")))),(0,i.kt)("p",null,"We avoid decoding (deserializing) the binding groups that do end up in the linked result to keep the memory consumption lower. Still the linker requires a lot of memory for larger programs, so we may need to make more improvements in the future."),(0,i.kt)("h2",{id:"the-compactor"},"The Compactor"),(0,i.kt)("p",null,"The compactor is an optional link-time transformation step that reduces code size. It consists of a lightweight (i.e. no expensive operations like dataflow analysis) rewrite of the code contained in the object files. The compactor is disabled when linking with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-debug")," flag. There are a few steps involved."),(0,i.kt)("h3",{id:"renaming-private-symbols"},"Renaming private symbols"),(0,i.kt)("p",null,"Haskell names are quite long by default: they need to be globally unique, hence they contain their defining unit-id and module name. For example: ",(0,i.kt)("inlineCode",{parentName:"p"},"mtl-2.2.2-somehash-Control.Monad.State.Lazy.execState_go1")," (special characters would be z-encoded but it isn't shown here)."),(0,i.kt)("p",null,"Private symbols are only referred to from within the same module. It doesn't matter which JavaScript name we pick for them, as long as there is no overlap between the names from different modules. The compactor renames all the private symbols using a global sequence to ensure short names that do not overlap."),(0,i.kt)("h3",{id:"block-initializer"},"Block Initializer"),(0,i.kt)("p",null,"Without the compactor, the linker generates an ",(0,i.kt)("inlineCode",{parentName:"p"},"h$initObj")," initialization call (or ",(0,i.kt)("inlineCode",{parentName:"p"},"h$o"),") call for each global Haskell heap value. The code for this can get quite big. The compactor collects all heap objects to be initialized in a single large array and encodes the metadata in a string. This makes the initialization code much more compact."),(0,i.kt)("h3",{id:"deduplication"},"Deduplication"),(0,i.kt)("p",null,"An optional step in the compactor is deduplication of code. When deduplication is enabled with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-dedupe")," flag, the compactor looks for functionally equivalent pieces of JavaScript in the output and merges them. This can result in a significant reduction of code size."),(0,i.kt)("h2",{id:"incremental-linking"},"Incremental Linking"),(0,i.kt)("p",null,"The linker supports building programs that are loaded incrementally. This is used for example for Template Haskell. The process that runs the Template Haskell stays alive during compilation of a whole module. When the first Template Haskell expression is compiled, it is linked against all its dependencies (including the RTS) and the resulting JavaScript code is sent over to be run in the evaluator process."),(0,i.kt)("p",null,"As subsequent Template Haskell expressions are evaluated in the same process, there is no need to load already loaded dependencies (including the RTS) again and it is much more efficient to avoid doing so. Therefore the linker keeps track of which dependencies have already been linked and each subsequent TH expression is only linked against dependencies that are not already loaded in the evaluator process."),(0,i.kt)("p",null,"It's also possible for users to use this functionality directly, with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-generate-base"),' to create a "linker state" file along with the regular ',(0,i.kt)("inlineCode",{parentName:"p"},"jsexe")," files. Another program can then be linked with ",(0,i.kt)("inlineCode",{parentName:"p"},"-use-base=state_file"),", resulting in a program which leaves out everything already present in the first program."),(0,i.kt)("h2",{id:"future-improvements"},"Future Improvements"),(0,i.kt)("p",null,"Memory consumption is the biggest problem in the linker at the moment. Possible ways to achieve this are compression, more efficient representation of the data structures or more incremental loading of the parts from the object files that we need."),(0,i.kt)("p",null,"In terms of functionality, we don't take advantage of JavaScript modules yet. It would be good if we could improve the linker to support linking a library as a JavaScript module. We should also consider making use of ",(0,i.kt)("inlineCode",{parentName:"p"},"foreign export javascript")," for this purpose."))}u.isMDXComponent=!0}}]);