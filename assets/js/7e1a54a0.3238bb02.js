"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[6505],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(n),c=i,u=m["".concat(p,".").concat(c)]||m[c]||h[c]||r;return n?a.createElement(u,o(o({ref:t},d),{},{components:n})):a.createElement(u,o({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},783:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return s},assets:function(){return d},toc:function(){return h},default:function(){return c}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],l={slug:"2022-07-20-js-backend-prim-types",title:"Primitive Type Representation in GHC's upcoming JS-backend",date:"July 20, 2022",authors:["doyougnu","sylvain"],tags:["ghc","javascript","explanation","knowledge_engineering"]},p="Table of Contents",s={permalink:"/2022-07-20-js-backend-prim-types",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2022-07-20-js-backend-prim-types.md",source:"@site/blog/2022-07-20-js-backend-prim-types.md",title:"Primitive Type Representation in GHC's upcoming JS-backend",description:"1.  GHC Primitives",date:"2022-07-20T00:00:00.000Z",formattedDate:"July 20, 2022",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"javascript",permalink:"/tags/javascript"},{label:"explanation",permalink:"/tags/explanation"},{label:"knowledge_engineering",permalink:"/tags/knowledge-engineering"}],readingTime:10.455,truncated:!1,authors:[{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"}],frontMatter:{slug:"2022-07-20-js-backend-prim-types",title:"Primitive Type Representation in GHC's upcoming JS-backend",date:"July 20, 2022",authors:["doyougnu","sylvain"],tags:["ghc","javascript","explanation","knowledge_engineering"]},prevItem:{title:"The GHCJS Linker",permalink:"/2022-07-26-the-ghcjs-linker"},nextItem:{title:"Lightweight Haskell Threads on JavaScript",permalink:"/2022-07-18-lightweight-threads-on-JavaScript"}},d={authorsImageUrls:[void 0,void 0]},h=[{value:"The Easy Cases",id:"the-easy-cases",children:[],level:2},{value:"ByteArray#, MutableByteArray#, SmallArray#, MutableSmallArray#,",id:"bytearray-mutablebytearray-smallarray-mutablesmallarray",children:[],level:2},{value:"Addr# and StablePtr#",id:"addr-and-stableptr",children:[],level:2},{value:"Numbers: The Involved Case",id:"numbers-the-involved-case",children:[{value:"Working with 64-bit Types",id:"working-with-64-bit-types",children:[],level:3},{value:"Unwrapped Number Optimization",id:"unwrapped-number-optimization",children:[],level:3}],level:2},{value:"But what about the other stuff!",id:"but-what-about-the-other-stuff",children:[],level:2}],m={toc:h};function c(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#orge86cd4a"},"GHC Primitives"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#org75a0c27"},"The Easy Cases")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#org5eb1aee"},"ByteArray#, MutableByteArray#, SmallArray#, MutableSmallArray#,")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#org0de7f9e"},"Addr# and StablePtr#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#orgfa8aeb4"},"Numbers: The Involved Case"),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#orgc9d245e"},"Working with 64-bit Types")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#org453f9cc"},"Unwrapped Number Optimization")))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"#org2e2e79e"},"But what about the other stuff!"))))),(0,r.kt)("p",null,"One of the key challenges in any novel backend is representing GHC primitive\ntypes in the new backend. For JavaScript, this is especially tricky, as\nJavaScript only has 8 primitive types and some of those types, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," do\nnot directly map to any Haskell primitive type, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8#"),". This post walks\nthrough the most important GHC primitives and describes our implementation for\neach in the JavaScript backend. This post is intended to be an\nexplanation-oriented post, light on details, but just enough to understand how\nthe system works."),(0,r.kt)("a",{id:"orge86cd4a"}),(0,r.kt)("h1",{id:"ghc-primitives"},"GHC Primitives"),(0,r.kt)("p",null,"There are 36 ",(0,r.kt)("inlineCode",{parentName:"p"},"primtype"),"s that GHC defines in ",(0,r.kt)("inlineCode",{parentName:"p"},"primops.txt.pp"),":"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Char#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Int8#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Int16#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Int32#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Int64#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Int#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Word8#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Word16#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Word32#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Word64#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Word#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Double#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Float#"),","),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Array#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"MutableArray#"),",, ",(0,r.kt)("inlineCode",{parentName:"li"},"SmallArray#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"SmallMutableArray#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"ByteArray#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"MutableByteArray#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Addr#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"MutVar#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"TVar#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"MVar#"),","),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"IOPort#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"State#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"RealWorld"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ThreadId#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Weak#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"StablePtr#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"StableName#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Compact#"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"BCO"),","),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"Fun"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Proxy#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"StackSnapshot#")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"VECTOR"))),(0,r.kt)("p",null,"Some of these are unsupported in the JS-backend, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"VECTOR")," or lower\npriority such as ",(0,r.kt)("inlineCode",{parentName:"p"},"StackSnapshot#"),". We","\u2019","ll begin with the easy cases."),(0,r.kt)("a",{id:"org75a0c27"}),(0,r.kt)("h2",{id:"the-easy-cases"},"The Easy Cases"),(0,r.kt)("p",null,"The easy cases are the cases that are implemented as JavaScript objects. In\ngeneral, this is the big hammer used when nothing else will do. We","\u2019","ll expand on\nthe use of objects","\u2014","especially representing heap objects","\u2014","in a future post,\nbut for the majority of cases we mimic the STG-machine behavior for GHC heap\nobjects using JavaScript heap objects. For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'var someConstructor =\n    { f  =                   // entry function of the datacon worker\n    , m  = 0                 // garbage collector mark\n    , d1 = first arg         // First data field for the constructor\n    , d2 = arity = 2: second arg // second field, or object containing the remaining fields\n           arity > 2: { d1, d2, ...} object with remaining args (starts with "d1 = x2"!)\n    }\n')),(0,r.kt)("p",null,"This is the general recipe; we define a JavaScript object that contains\nproperties which correspond to the entry function of the heap object; in this\ncase that is the entry function, ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," for a constructor, some meta data for garbage\ncollection ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),", and pointers to the fields of the constructor or whatever else the\nheap object might need. Using JavaScript objects allows straightforward\ntranslations of several GHC types. For example ",(0,r.kt)("inlineCode",{parentName:"p"},"TVar"),"s and ",(0,r.kt)("inlineCode",{parentName:"p"},"MVar"),"s:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// stg.js.pp\n/** @constructor */\nfunction h$TVar(v) {\n    TRACE_STM("creating TVar, value: " + h$collectProps(v));\n    this.val        = v;           // current value\n    this.blocked    = new h$Set(); // threads that get woken up if this TVar is updated\n    this.invariants = null;        // invariants that use this TVar (h$Set)\n    this.m          = 0;           // gc mark\n    this._key       = ++h$TVarN;   // for storing in h$Map/h$Set\n#ifdef GHCJS_DEBUG_ALLOC\n    h$debugAlloc_notifyAlloc(this);\n#endif\n}\n\n// stm.js.pp\nfunction h$MVar() {\n  TRACE_SCHEDULER("h$MVar constructor");\n  this.val     = null;\n  this.readers = new h$Queue();\n  this.writers = new h$Queue();\n  this.waiters = null;  // waiting for a value in the MVar with ReadMVar\n  this.m       = 0; // gc mark\n  this.id      = ++h$mvarId;\n#ifdef GHCJS_DEBUG_ALLOC\n  h$debugAlloc_notifyAlloc(this);\n#endif\n}\n')),(0,r.kt)("p",null,"Notice that both implementations defined properties specific to the semantics of\nthe Haskell type. JavaScript functions which create these objects follow the\nnaming convention ",(0,r.kt)("inlineCode",{parentName:"p"},"h$<something>")," and reside in ",(0,r.kt)("em",{parentName:"p"},"Shim")," files. ",(0,r.kt)("em",{parentName:"p"},"Shim")," files are\nJavaScript files that the JS-backend links against and are written in pure\nJavaScript. This allows us to save some compile time by not generating code\nwhich doesn","\u2019","t change, and decompose the backend into JavaScript modules."),(0,r.kt)("p",null,"This strategy is also how functions are implemented in the JS-backend. Function\nobjects are generated by ",(0,r.kt)("inlineCode",{parentName:"p"},"StgToJS.Expr.genExpr")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"StgToJS.Apply.genApp")," but\nfollow this recipe:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"var myFUN =\n { f  = <function itself>\n , m  = <garbage collector mark>\n , d1 = free variable 1\n , d2 = free variable 2\n }\n")),(0,r.kt)("p",null,"To summarize; for most cases we write custom JavaScript objects which hold\nwhatever machinery is needed as properties to satisfy the expected semantics of\nthe Haskell type. This is the strategy that implements: ",(0,r.kt)("inlineCode",{parentName:"p"},"TVar"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MVar"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"MutVar")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Fun"),"."),(0,r.kt)("a",{id:"org5eb1aee"}),(0,r.kt)("h2",{id:"bytearray-mutablebytearray-smallarray-mutablesmallarray"},"ByteArray#, MutableByteArray#, SmallArray#, MutableSmallArray#,"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray#")," and friends map to JavaScript's\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"},(0,r.kt)("inlineCode",{parentName:"a"},"ArrayBuffer")),"\nobject. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayBuffer")," object provides a fixed-length, raw binary data\nbuffer. To index into the ",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayBuffer")," we need to know the type of data the\nbuffer is expected to hold. So we make engineering tradeoff; we allocate typed\nviews of the buffer payload once at buffer allocation time. This prevents\nallocations from views later when we might be handling the buffer in a hot loop,\nat the cost of slower initialization. For example, consider the ",(0,r.kt)("inlineCode",{parentName:"p"},"mem.js.pp"),"\nshim, which defines ",(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray#"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// mem.js.pp\nfunction h$newByteArray(len) {\n  var len0 = Math.max(h$roundUpToMultipleOf(len, 8), 8);\n  var buf = new ArrayBuffer(len0);\n  return { buf: buf\n         , len: len\n         , i3: new Int32Array(buf)\n         , u8: new Uint8Array(buf)\n         , u1: new Uint16Array(buf)\n         , f3: new Float32Array(buf)\n         , f6: new Float64Array(buf)\n         , dv: new DataView(buf)\n         , m: 0\n         }\n}\n")),(0,r.kt)("p",null," ",(0,r.kt)("inlineCode",{parentName:"p"},"buf")," is the payload of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray#"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"len")," is the length of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray#"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"i3")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"dv")," are the ",(0,r.kt)("em",{parentName:"p"},"views")," of the payload; each view is an\nobject which interprets the raw data in ",(0,r.kt)("inlineCode",{parentName:"p"},"buf")," differently according to type. For\nexample, ",(0,r.kt)("inlineCode",{parentName:"p"},"i3")," interprets ",(0,r.kt)("inlineCode",{parentName:"p"},"buf")," as holding ",(0,r.kt)("inlineCode",{parentName:"p"},"Int32"),", while ",(0,r.kt)("inlineCode",{parentName:"p"},"dv")," interprets ",(0,r.kt)("inlineCode",{parentName:"p"},"buf"),"\nas a\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView"},(0,r.kt)("inlineCode",{parentName:"a"},"DataView")),"\nand so on. The final property, ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),", is the garbage collector marker."),(0,r.kt)("a",{id:"org0de7f9e"}),(0,r.kt)("h2",{id:"addr-and-stableptr"},"Addr# and StablePtr#"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Addr#")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"StablePtr#")," are implemented as a pair of ",(0,r.kt)("inlineCode",{parentName:"p"},"ByteArray#")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int#"),"\noffset into the array. We","\u2019","ll focus on ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr#")," because ",(0,r.kt)("inlineCode",{parentName:"p"},"StablePtr#")," is the\nsame implementation, with the exception that the ",(0,r.kt)("inlineCode",{parentName:"p"},"StablePtr#")," is tracked in the\nglobal variable ",(0,r.kt)("inlineCode",{parentName:"p"},"h$stablePtrBuf"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr#"),"s do not have an explicit constructor,\nrather they are implicitly constructed. For example, consider ",(0,r.kt)("inlineCode",{parentName:"p"},"h$rts_mkPtr"),"\nwhich creates a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ptr")," that contains an ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr#"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"function h$rts_mkPtr(x) {\n  var buf, off = 0;\n  if(typeof x == 'string') {\n\n    buf = h$encodeUtf8(x);\n    off = 0;\n  } else if(typeof x == 'object' &&\n     typeof x.len == 'number' &&\n     x.buf instanceof ArrayBuffer) {\n\n    buf = x;\n    off = 0;\n  } else if(x.isView) {\n\n    buf = h$wrapBuffer(x.buffer, true, 0, x.buffer.byteLength);\n    off = x.byteOffset;\n  } else {\n\n    buf = h$wrapBuffer(x, true, 0, x.byteLength);\n    off = 0;\n  }\n  return (h$c2(h$baseZCGHCziPtrziPtr_con_e, (buf), (off)));\n}\n")),(0,r.kt)("p",null,"The function does some type inspection to check for the special case on\n",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". If we do not have a string then a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ptr"),", which contains an ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr#"),", is\nreturned. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Addr#")," is implicitly constructed by allocating a new\n",(0,r.kt)("inlineCode",{parentName:"p"},"ArrayBuffer")," and an offset into that buffer. The ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," case is an idempotent\ncheck; if the input is already such a ",(0,r.kt)("inlineCode",{parentName:"p"},"Ptr"),", then just return the input. The\ncases which do the work are the cases which call to ",(0,r.kt)("inlineCode",{parentName:"p"},"h$wrapBuffer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// mem.js.pp\nfunction h$wrapBuffer(buf, unalignedOk, offset, length) {\n  if(!unalignedOk && offset && offset % 8 !== 0) {\n    throw ("h$wrapBuffer: offset not aligned:" + offset);\n  }\n  if(!buf || !(buf instanceof ArrayBuffer))\n    throw "h$wrapBuffer: not an ArrayBuffer"\n  if(!offset) { offset = 0; }\n  if(!length || length < 0) { length = buf.byteLength - offset; }\n  return { buf: buf\n         , len: length\n         , i3: (offset%4) ? null : new Int32Array(buf, offset, length >> 2)\n         , u8: new Uint8Array(buf, offset, length)\n         , u1: (offset%2) ? null : new Uint16Array(buf, offset, length >> 1)\n         , f3: (offset%4) ? null : new Float32Array(buf, offset, length >> 2)\n         , f6: (offset%8) ? null : new Float64Array(buf, offset, length >> 3)\n         , dv: new DataView(buf, offset, length)\n         };\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"h$wrapBuffer")," is a utility function that does some offset checks and performs\nthe allocation for the typed views as described above."),(0,r.kt)("a",{id:"orgfa8aeb4"}),(0,r.kt)("h2",{id:"numbers-the-involved-case"},"Numbers: The Involved Case"),(0,r.kt)("p",null,"Translating numbers has three issues. First, JavaScript has no concept of\nfixed-precision 64-bit types such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Int64#")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Word64#"),". Second, JavaScript\nbitwise operators only support ",(0,r.kt)("em",{parentName:"p"},"signed")," 32-bit values (except the unsigned\n",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift"},"right\nshift"),"\noperator of course). Third, numbers are atomic types and do not require any\nspecial properties for correct semantics, thus using wrapping objects gains us\nnothing at the cost of indirection."),(0,r.kt)("a",{id:"orgc9d245e"}),(0,r.kt)("h3",{id:"working-with-64-bit-types"},"Working with 64-bit Types"),(0,r.kt)("p",null,"To express 64-bit numerics, we simply use two 32-bit numbers, one to express\nthe high bits, one for the low bits. For example, consider comparing two ",(0,r.kt)("inlineCode",{parentName:"p"},"Int64#:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// arith.js.pp\nfunction h$hs_ltInt64(h1,l1,h2,l2) {\n  if(h1 === h2) {\n    var l1s = l1 >>> 1;\n    var l2s = l2 >>> 1;\n    return (l1s < l2s || (l1s === l2s && ((l1&1) < (l2&1)))) ? 1 : 0;\n  } else {\n    return (h1 < h2) ? 1 : 0;\n  }\n}\n")),(0,r.kt)("p",null,"The less than comparison function expects four inputs, two for each ",(0,r.kt)("inlineCode",{parentName:"p"},"Int64#")," in\nHaskell. The first number is represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"h1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"l1")," (",(0,r.kt)("em",{parentName:"p"},"high")," and ",(0,r.kt)("em",{parentName:"p"},"low"),"),\nand similarly the second number is represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"h2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"l2"),". The comparison\nis straightforward, we check equivalence of our high bits, if equal then we\ncheck the lower bits while being careful with signedness. No surprises here."),(0,r.kt)("p",null,"For the bitwise operators we store both ",(0,r.kt)("inlineCode",{parentName:"p"},"Word32#")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Word#")," as 32-bit signed\nvalues, and then map any values greater or equal ",(0,r.kt)("inlineCode",{parentName:"p"},"2^31")," bits to negative values.\nThis way we stay within the 32-bit range even though in Haskell these types only\nsupport nonnegative values."),(0,r.kt)("a",{id:"org453f9cc"}),(0,r.kt)("h3",{id:"unwrapped-number-optimization"},"Unwrapped Number Optimization"),(0,r.kt)("p",null,"The JS backend uses JavaScript values to represent both Haskell heap objects and\nunboxed values (note that this isn't the only possible implementation, see\n",(0,r.kt)("sup",{parentName:"p",id:"fnref-1"},(0,r.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),'). As such, it doesn\'t require that all heap objects have the same\nrepresentation (e.g. a JavaScript object with a "tag" field indicating its type)\nbecause we can rely on JS introspection for the same purpose (especially\n',(0,r.kt)("inlineCode",{parentName:"p"},"typeof"),"). Hence this optimization consists in using a more efficient JavaScript\ntype to represent heap objects when possible, and to fallback on the generic\nrepresentation otherwise."),(0,r.kt)("p",null,"This optimization particularly applies to ",(0,r.kt)("inlineCode",{parentName:"p"},"Boxed")," numeric values (",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Word"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"Int8"),", etc.) which can be directly represented with a JavaScript number,\nsimilarly to how unboxed ",(0,r.kt)("inlineCode",{parentName:"p"},"Int#"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Word#"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8#"),", etc. values are represented."),(0,r.kt)("p",null,"Pros:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Fewer allocations and indirections: instead of one JavaScript object with a\nfield containing a number value, we directly have the number value.")),(0,r.kt)("p",null,"Cons:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"More complex code to deal with heap objects that can have different\nrepresentations")),(0,r.kt)("p",null,"The optimization is applicable when:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"We have a single data type with a single data constructor."),(0,r.kt)("li",{parentName:"ol"},"The constructor holds a single field that ",(0,r.kt)("em",{parentName:"li"},"can only")," be a particular type.")),(0,r.kt)("p",null,"If these invariants hold then, we remove the wrapping object and instead refer\nto the value held by the constructor directly. ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8")," is the simplest case for\nthis optimization. In Haskell we have:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"data Int8 = Int8 Int8#\n")),(0,r.kt)("p",null,"Notice that this definition satisfies the requirements. A direct translation in\nthe JS backend would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// An Int8 Thunk represented as an Object with an entry function, f\n// and payload, d1.\nvar anInt8 = { d1 = <Int8# payload>\n             , f  : entry function which would scrutinize the payload\n             }\n")),(0,r.kt)("p",null,"We can operationally distinguish between a ",(0,r.kt)("inlineCode",{parentName:"p"},"Thunk")," and an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8")," because these\nwill have separate types in the ",(0,r.kt)("inlineCode",{parentName:"p"},"StgToJS")," GHC pass and will have separate types\n(",(0,r.kt)("inlineCode",{parentName:"p"},"object")," vs ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),") at runtime. In contrast, in Haskell an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8")," may\nactually be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Thunk")," until it is scrutinized ",(0,r.kt)("em",{parentName:"p"},"and then")," becomes the ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8"),"\npayload (i.e., call-by-need). So this means that we will always know when we\nhave an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int8")," rather than a ",(0,r.kt)("inlineCode",{parentName:"p"},"Thunk")," and therefore we can omit the wrapper\nobject and convert this code to just:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// no object, just payload\nvar anInt8 = = <Int8# payload>\n")),(0,r.kt)("p",null,"For the interested reader, this optimization takes place in the JavaScript code\ngenerator module ",(0,r.kt)("inlineCode",{parentName:"p"},"GHC.StgToJS.Arg"),", specifically the functions ",(0,r.kt)("inlineCode",{parentName:"p"},"allocConStatic"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"isUnboxableCon"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"primRepVt"),"."),(0,r.kt)("a",{id:"org2e2e79e"}),(0,r.kt)("h2",{id:"but-what-about-the-other-stuff"},"But what about the other stuff!"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Char#"),": is represented by a ",(0,r.kt)("inlineCode",{parentName:"li"},"number"),", i.e., the ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Code_point"},"code point")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Float#/Double#"),": Both represented as a JavaScript Double. This means that\n",(0,r.kt)("inlineCode",{parentName:"li"},"Float#")," has excess precision and thus we do not generate exactly the same\nanswers as other platforms which are IEEE754 compliant. Full emulation of\nsingle precision Floats does not seem to be worth the effort as of writing.\nOur implementation represents these in a ",(0,r.kt)("inlineCode",{parentName:"li"},"ByteArray#"),", where each ",(0,r.kt)("inlineCode",{parentName:"li"},"Float#"),"\ntakes 4 bytes in the ",(0,r.kt)("inlineCode",{parentName:"li"},"ByteArray#"),". This means that the precision is reduced\nto a 32-bit Float.")),(0,r.kt)("div",{className:"footnotes"},(0,r.kt)("hr",{parentName:"div"}),(0,r.kt)("ol",{parentName:"div"},(0,r.kt)("li",{parentName:"ol",id:"fn-1"},"An alternative approach would be to use some JS ArrayBuffers as memory\nblocks into which Haskell values and heap objects would be allocated. As an\nexample this is the approach used by the Asterius compiler. The RTS would\nthen need to be much more similar to the C RTS and the optimization\npresented in this section wouldn't apply because we couldn't rely on\nintrospection of JS values.",(0,r.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}c.isMDXComponent=!0}}]);