"use strict";(globalThis.webpackChunkengineering_iog_io=globalThis.webpackChunkengineering_iog_io||[]).push([[793],{5680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>m});var r=a(6540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach(function(t){n(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function s(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var l=r.createContext({}),p=function(e){var t=r.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},g=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef(function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,g=s(e,["components","mdxType","originalType","parentName"]),h=p(a),u=n,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return a?r.createElement(m,o(o({ref:t},g),{},{components:a})):r.createElement(m,o({ref:t},g))});function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:n,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8525:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=a(8168),n=(a(6540),a(5680));const i={slug:"2024-05-02-ghc-update",title:"IOG GHC Update #28",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},o=void 0,s={permalink:"/2024-05-02-ghc-update",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2024-05-02-ghc-update-28.md",source:"@site/blog/2024-05-02-ghc-update-28.md",title:"IOG GHC Update #28",description:"Triweekly update from the GHC DevX team at IOG.",date:"2024-05-02T00:00:00.000Z",formattedDate:"May 2, 2024",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"ghc-update",permalink:"/tags/ghc-update"}],readingTime:1.365,hasTruncateMarker:!0,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"},{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"}],frontMatter:{slug:"2024-05-02-ghc-update",title:"IOG GHC Update #28",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},prevItem:{title:"IOG GHC Update #29",permalink:"/2024-05-23-ghc-update"},nextItem:{title:"IOG GHC Update #27",permalink:"/2024-04-11-ghc-update"}},l={authorsImageUrls:[void 0,void 0,void 0]},p=[],g={toc:p},h="wrapper";function c({components:e,...t}){return(0,n.yg)(h,(0,r.A)({},g,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("p",null,"Triweekly update from the GHC DevX team at IOG."),(0,n.yg)("p",null,"Previous updates can be found ",(0,n.yg)("a",{parentName:"p",href:"https://engineering.iog.io/tags/ghc-update"},"here"),"."),(0,n.yg)("ul",null,(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Sylvain: completed and merged someone's patch opened for 4 years to make GHC\ngenerate better LLVM IR for complete switches.\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24717"},"GHC#24717"),",\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12491"},"GHC!12491"),".")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Sylvain: fixed issue with code using DeriveLift and when building\ntemplate-haskell.\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22229"},"GHC#22229"),",\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12456"},"GHC!12456"),".")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Sylvain: fixed a segfault in GHCi when using breakpoints.\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24712"},"GHC#24712"),",\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12500"},"GHC!12500"))),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Sylvain: fixed a JS codegen issue because GHC generates code that computes\nwith RUBBISH literals. There may be more to it as it's not really supposed to\nhappen, but at least the generated JS code is valid code now .\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24664"},"GHC#24664"),",\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12463"},"GHC!12463"),".")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Jeff: After a long exhausting battle with the GHC testsuite, jeff expanded the testsuite capabilites to track binary sizes for each backend in GHC's CI and their dependencies. ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12372#c591f85f122007bac88228c5ff6fd76b40e6a811"},"MR")," is merging now.")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Jeff: Published the ",(0,n.yg)("a",{parentName:"p",href:"https://haskell.foundation/hs-opt-handbook.github.io/src/Measurement_Observation/Binary_Profiling/linux_perf.html#perf-chapter"},"perf")," chapter for the ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/haskellfoundation/hs-opt-handbook.github.io"},"Haskell Optimization Handbook"),".")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Hamish: added support for the JS backend in Miso\n",(0,n.yg)("a",{parentName:"p",href:"https://github.com/dmjio/miso/pull/738"},"Miso#738"),". This led to a discussion\nabout generated code size. Sylvain opened two issues about ideas to reduce\ncode size (",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24743"},"GHC#24743")," and\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24744"},"GHC#24744"),") and one MR to\nprepare for #24743\n",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12538"},"GHC!12538"),".")),(0,n.yg)("li",{parentName:"ul"},(0,n.yg)("p",{parentName:"li"},"Luite: Made a new implementation of the functionality of starting/stopping\nprofiling counters for cost centre profiling ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12478"},"GHC!12478"),".\nThis implementation is simpler than the previous one ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12440"},"GHC!12440"),",\nbut requires reading a global variable for each counter increment. Initial performance\nmeasurements have shown that the cost is minor. We haven't merged this yet because of ongoing\nwork on even finer control of cost centre counters (multiple counters per cost centre stack and per-thread\nsettings), which might supersede this patch."))))}c.isMDXComponent=!0}}]);