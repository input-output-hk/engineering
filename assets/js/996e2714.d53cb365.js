"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[2224],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return g}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=p(a),g=r,m=u["".concat(s,".").concat(g)]||u[g]||c[g]||i;return a?n.createElement(m,o(o({ref:t},h),{},{components:a})):n.createElement(m,o({ref:t},h))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1934:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return h},toc:function(){return c},default:function(){return g}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],l={slug:"2024-08-15-ghc-update",title:"IOG GHC Update #33",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},s=void 0,p={permalink:"/2024-08-15-ghc-update",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2024-08-15-ghc-update-33.md",source:"@site/blog/2024-08-15-ghc-update-33.md",title:"IOG GHC Update #33",description:"Triweekly update from the GHC DevX team at IOG.",date:"2024-08-15T00:00:00.000Z",formattedDate:"August 15, 2024",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"ghc-update",permalink:"/tags/ghc-update"}],readingTime:2.355,truncated:!0,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"},{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"}],frontMatter:{slug:"2024-08-15-ghc-update",title:"IOG GHC Update #33",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},nextItem:{title:"IOG GHC Update #32",permalink:"/2024-07-24-ghc-update"}},h={authorsImageUrls:[void 0,void 0,void 0]},c=[{value:"High-level Summary",id:"high-level-summary",children:[],level:2},{value:"Details",id:"details",children:[],level:2}],u={toc:c};function g(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Triweekly update from the GHC DevX team at IOG."),(0,i.kt)("p",null,"Previous updates can be found ",(0,i.kt)("a",{parentName:"p",href:"https://engineering.iog.io/tags/ghc-update"},"here"),"."),(0,i.kt)("h2",{id:"high-level-summary"},"High-level Summary"),(0,i.kt)("p",null,"The team is continuing the work on characterizing and upstreaming some GHC patches that are\nonly present in haskell.nix-provided GHCs. Other work has been done to prepare for the GHC 9.12 fork in September."),(0,i.kt)("h2",{id:"details"},"Details"),(0,i.kt)("p",null,"Jeff: triaged all haskell.nix patches to decide which should be upstreamed."),(0,i.kt)("p",null,"Sylvain: fixed CI of his ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/haskus-utils-variant"},"haskus-utils-variant")," package that is used by ",(0,i.kt)("a",{parentName:"p",href:"https://www.haskell.org/ghcup/"},"ghcup")," and that was causing ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/NixOS/nixpkgs/issues/212716#issuecomment-2290942272"},"build failure in nixpkgs"),". In the process I've fixed an issue in doctests about error links produced by GHC 9.10 ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sol/doctest/pull/448"},"doctest#448"),"."),(0,i.kt)("p",null,"Sylvain: encountered and fixed an issue where GHC would pick the wrong ",(0,i.kt)("inlineCode",{parentName:"p"},"ghcversion.h")," file which defines CPP constants such as ",(0,i.kt)("inlineCode",{parentName:"p"},"__GLASGOW_HASKELL__")," (GHC version used). As a result some CPP conditionals were incorrectly evaluated for the GHC version used and some packages failed to build. ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/haskell/cabal/issues/10229"},"cabal#10229")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25106"},"GHC#25106")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13070"},"GHC!13070")),(0,i.kt)("p",null,"Sylvain: fixed documentation in GHC's users guide about JS callbacks. ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24377"},"GHC#24377")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13119"},"GHC!13119")),(0,i.kt)("p",null,"Sylvain: removed hack used in GHC's rts to support old versions of Cabal. The hack consisted in always linking with a compiled ",(0,i.kt)("inlineCode",{parentName:"p"},".c")," file in order to force cabal to create a library otherwise only composed of ",(0,i.kt)("inlineCode",{parentName:"p"},".js")," files. The hack is no longer needed since GHC used a more recent Cabal now. ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25138"},"GHC#25138")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13106"},"GHC!13106")),(0,i.kt)("p",null,"Luite: Worked on improving locking for the GHC external interpreter (",(0,i.kt)("inlineCode",{parentName:"p"},"iserv")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ghc-interp.js"),") to fix problems with ",(0,i.kt)("inlineCode",{parentName:"p"},"-j")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25083"},"GHC#25083")),(0,i.kt)("p",null,"Luite: Looking into making the Windows toolchain choices more flexible, allowing ",(0,i.kt)("inlineCode",{parentName:"p"},"gcc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"msvcrt")," instead of just ",(0,i.kt)("inlineCode",{parentName:"p"},"clang"),"/",(0,i.kt)("inlineCode",{parentName:"p"},"ucrt"),"."),(0,i.kt)("p",null,"Sylvain: fixed a bug with 64-bit literals compiled with a 32-bit compiler that were truncated. The current fix is only temporary as it disables some optimizations for 64-bit literals when compiled with a 32-bit compiler. A proper fix is still in the making and will be much more invasive and difficult to backport. ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24893"},"GHC#24893")," ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13096"},"GHC!13096"),". The ticket tracking the proper fix is ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25151"},"GHC#25151")),(0,i.kt)("p",null,"Sylvain: adapted a patch from haskell.nix to support ",(0,i.kt)("inlineCode",{parentName:"p"},"AARCH64_R_NONE")," relocations in the RTS linker ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13113"},"GHC!13113")),(0,i.kt)("p",null,"Sylvain: wrote about ",(0,i.kt)("a",{parentName:"p",href:"https://hsyl20.fr/posts/2024-08-07-about-ghcs-stability.html"},"GHC's stability")," and ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25105#note_579482"},"support mutable fields in data constructors")),(0,i.kt)("p",null,"Sylvain: done some refactoring of the linker code ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13136"},"GHC!13136")," and ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13142"},"GHC!13142")),(0,i.kt)("p",null,"Jeff: Attempted to convert GHC's Word64Set to a bitmap for more efficient memory representations. This is a follow on from ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12687"},"GHC!12687"),". Unfortunately, this won't work in GHC because GHC uses the top 8 most significant bits of a Unique to tag information about the Unique. Next step is to implement a ",(0,i.kt)("a",{parentName:"p",href:"https://roaringbitmap.org/"},"roaring bitmap")," instead."),(0,i.kt)("p",null,"Jeff: Experimented with a more memory efficient ",(0,i.kt)("inlineCode",{parentName:"p"},"LambdaFormInfo")," (",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13131"},"GHC!13131"),") inspired by some data-oriented programming techniques. Initial results were quite good: ~ 1% allocation improvement in many cases but not all. This was just a shot in the dark, next step here is to apply similar techniques but to data types that we empirically know are hot loops in the compiler."))}g.isMDXComponent=!0}}]);