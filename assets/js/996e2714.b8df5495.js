"use strict";(globalThis.webpackChunkengineering_iog_io=globalThis.webpackChunkengineering_iog_io||[]).push([[8520],{4048:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=a(8168),n=(a(6540),a(5680));const i={slug:"2024-08-15-ghc-update",title:"IOG GHC Update #33",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},o=void 0,l={permalink:"/2024-08-15-ghc-update",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2024-08-15-ghc-update-33.md",source:"@site/blog/2024-08-15-ghc-update-33.md",title:"IOG GHC Update #33",description:"Triweekly update from the GHC DevX team at IOG.",date:"2024-08-15T00:00:00.000Z",formattedDate:"August 15, 2024",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"ghc-update",permalink:"/tags/ghc-update"}],readingTime:2.355,hasTruncateMarker:!0,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"},{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"}],frontMatter:{slug:"2024-08-15-ghc-update",title:"IOG GHC Update #33",authors:["sylvain","doyougnu","luite"],tags:["ghc","ghc-update"]},prevItem:{title:"IOG GHC Update #34",permalink:"/2024-09-05-ghc-update"},nextItem:{title:"IOG GHC Update #32",permalink:"/2024-07-24-ghc-update"}},s={authorsImageUrls:[void 0,void 0,void 0]},p=[{value:"High-level Summary",id:"high-level-summary",level:2},{value:"Details",id:"details",level:2}],g={toc:p},h="wrapper";function c({components:e,...t}){return(0,n.yg)(h,(0,r.A)({},g,t,{components:e,mdxType:"MDXLayout"}),(0,n.yg)("p",null,"Triweekly update from the GHC DevX team at IOG."),(0,n.yg)("p",null,"Previous updates can be found ",(0,n.yg)("a",{parentName:"p",href:"https://engineering.iog.io/tags/ghc-update"},"here"),"."),(0,n.yg)("h2",{id:"high-level-summary"},"High-level Summary"),(0,n.yg)("p",null,"The team is continuing the work on characterizing and upstreaming some GHC patches that are\nonly present in haskell.nix-provided GHCs. Other work has been done to prepare for the GHC 9.12 fork in September."),(0,n.yg)("h2",{id:"details"},"Details"),(0,n.yg)("p",null,"Jeff: triaged all haskell.nix patches to decide which should be upstreamed."),(0,n.yg)("p",null,"Sylvain: fixed CI of his ",(0,n.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/haskus-utils-variant"},"haskus-utils-variant")," package that is used by ",(0,n.yg)("a",{parentName:"p",href:"https://www.haskell.org/ghcup/"},"ghcup")," and that was causing ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/NixOS/nixpkgs/issues/212716#issuecomment-2290942272"},"build failure in nixpkgs"),". In the process I've fixed an issue in doctests about error links produced by GHC 9.10 ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/sol/doctest/pull/448"},"doctest#448"),"."),(0,n.yg)("p",null,"Sylvain: encountered and fixed an issue where GHC would pick the wrong ",(0,n.yg)("inlineCode",{parentName:"p"},"ghcversion.h")," file which defines CPP constants such as ",(0,n.yg)("inlineCode",{parentName:"p"},"__GLASGOW_HASKELL__")," (GHC version used). As a result some CPP conditionals were incorrectly evaluated for the GHC version used and some packages failed to build. ",(0,n.yg)("a",{parentName:"p",href:"https://github.com/haskell/cabal/issues/10229"},"cabal#10229")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25106"},"GHC#25106")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13070"},"GHC!13070")),(0,n.yg)("p",null,"Sylvain: fixed documentation in GHC's users guide about JS callbacks. ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24377"},"GHC#24377")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13119"},"GHC!13119")),(0,n.yg)("p",null,"Sylvain: removed hack used in GHC's rts to support old versions of Cabal. The hack consisted in always linking with a compiled ",(0,n.yg)("inlineCode",{parentName:"p"},".c")," file in order to force cabal to create a library otherwise only composed of ",(0,n.yg)("inlineCode",{parentName:"p"},".js")," files. The hack is no longer needed since GHC used a more recent Cabal now. ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25138"},"GHC#25138")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13106"},"GHC!13106")),(0,n.yg)("p",null,"Luite: Worked on improving locking for the GHC external interpreter (",(0,n.yg)("inlineCode",{parentName:"p"},"iserv")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"ghc-interp.js"),") to fix problems with ",(0,n.yg)("inlineCode",{parentName:"p"},"-j")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25083"},"GHC#25083")),(0,n.yg)("p",null,"Luite: Looking into making the Windows toolchain choices more flexible, allowing ",(0,n.yg)("inlineCode",{parentName:"p"},"gcc")," and ",(0,n.yg)("inlineCode",{parentName:"p"},"msvcrt")," instead of just ",(0,n.yg)("inlineCode",{parentName:"p"},"clang"),"/",(0,n.yg)("inlineCode",{parentName:"p"},"ucrt"),"."),(0,n.yg)("p",null,"Sylvain: fixed a bug with 64-bit literals compiled with a 32-bit compiler that were truncated. The current fix is only temporary as it disables some optimizations for 64-bit literals when compiled with a 32-bit compiler. A proper fix is still in the making and will be much more invasive and difficult to backport. ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/24893"},"GHC#24893")," ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13096"},"GHC!13096"),". The ticket tracking the proper fix is ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25151"},"GHC#25151")),(0,n.yg)("p",null,"Sylvain: adapted a patch from haskell.nix to support ",(0,n.yg)("inlineCode",{parentName:"p"},"AARCH64_R_NONE")," relocations in the RTS linker ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13113"},"GHC!13113")),(0,n.yg)("p",null,"Sylvain: wrote about ",(0,n.yg)("a",{parentName:"p",href:"https://hsyl20.fr/posts/2024-08-07-about-ghcs-stability.html"},"GHC's stability")," and ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/25105#note_579482"},"support mutable fields in data constructors")),(0,n.yg)("p",null,"Sylvain: done some refactoring of the linker code ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13136"},"GHC!13136")," and ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13142"},"GHC!13142")),(0,n.yg)("p",null,"Jeff: Attempted to convert GHC's Word64Set to a bitmap for more efficient memory representations. This is a follow on from ",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/12687"},"GHC!12687"),". Unfortunately, this won't work in GHC because GHC uses the top 8 most significant bits of a Unique to tag information about the Unique. Next step is to implement a ",(0,n.yg)("a",{parentName:"p",href:"https://roaringbitmap.org/"},"roaring bitmap")," instead."),(0,n.yg)("p",null,"Jeff: Experimented with a more memory efficient ",(0,n.yg)("inlineCode",{parentName:"p"},"LambdaFormInfo")," (",(0,n.yg)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/13131"},"GHC!13131"),") inspired by some data-oriented programming techniques. Initial results were quite good: ~ 1% allocation improvement in many cases but not all. This was just a shot in the dark, next step here is to apply similar techniques but to data types that we empirically know are hot loops in the compiler."))}c.isMDXComponent=!0},5680:(e,t,a)=>{a.d(t,{xA:()=>g,yg:()=>m});var r=a(6540);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach(function(t){n(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},g=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef(function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),h=p(a),u=n,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||i;return a?r.createElement(m,o(o({ref:t},g),{},{components:a})):r.createElement(m,o({ref:t},g))});function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:n,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);