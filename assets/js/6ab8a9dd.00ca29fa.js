"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[1096],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||r;return n?a.createElement(m,o(o({ref:t},d),{},{components:n})):a.createElement(m,o({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8342:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return d},toc:function(){return c},default:function(){return u}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],s={slug:"2022-12-13-ghc-js-backend-merged",title:"JavaScript backend merged into GHC",authors:["sylvain","doyougnu","luite","josh","moritz"],tags:["ghc","javascript","cross-compilation"]},l=void 0,p={permalink:"/2022-12-13-ghc-js-backend-merged",source:"@site/blog/2022-12-13-ghc-js-backend-merged.md",title:"JavaScript backend merged into GHC",description:"A new JavaScript backend was",date:"2022-12-13T00:00:00.000Z",formattedDate:"December 13, 2022",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"javascript",permalink:"/tags/javascript"},{label:"cross-compilation",permalink:"/tags/cross-compilation"}],readingTime:19.44,truncated:!1,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"},{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"},{name:"Joshua Meredith",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"josh"},{name:"Moritz Angermann",title:"Head of DevX @ IOG",url:"https://iog.io/en/",key:"moritz"}],frontMatter:{slug:"2022-12-13-ghc-js-backend-merged",title:"JavaScript backend merged into GHC",authors:["sylvain","doyougnu","luite","josh","moritz"],tags:["ghc","javascript","cross-compilation"]},nextItem:{title:"Model-Based Testing with QuickCheck",permalink:"/2022-09-28-introduce-q-d"}},d={authorsImageUrls:[void 0,void 0,void 0,void 0,void 0]},c=[{value:"Why JavaScript? Or, the Big Picture.",id:"why-javascript-or-the-big-picture",children:[],level:2},{value:"Why Haskell?",id:"why-haskell",children:[],level:2},{value:"Why a GHC backend?",id:"why-a-ghc-backend",children:[],level:2},{value:"Is GHCJS Dead?",id:"ghcjs",children:[],level:2},{value:"What is Missing From GHCJS?",id:"expectations",children:[],level:2},{value:"What&#39;s on the JS Backend&#39;s Roadmap?",id:"roadmap",children:[],level:2},{value:"What has Improved Compared to GHCJS?",id:"what-has-improved-compared-to-ghcjs",children:[{value:"Removing the Use of External Libraries",id:"removing-the-use-of-external-libraries",children:[],level:4},{value:"Reusing GHC&#39;s Build System: Hadrian",id:"reusing-ghcs-build-system-hadrian",children:[],level:4},{value:"Support for Running GHC&#39;s Test Suite",id:"support-for-running-ghcs-test-suite",children:[],level:4},{value:"Upgrading from GHC 8.10 to GHC 9.6",id:"upgrading-from-ghc-810-to-ghc-96",children:[],level:4},{value:"Fixing Some Performance Issues",id:"fixing-some-performance-issues",children:[],level:4},{value:"Removal of Custom File Extensions and Support for JavaScript Pragmas",id:"removal-of-custom-file-extensions-and-support-for-javascript-pragmas",children:[],level:4},{value:"Cleanup and Documentation",id:"blogs",children:[],level:4},{value:"Plugin Support in Cross-Compilers",id:"plugin-support-in-cross-compilers",children:[],level:4}],level:2},{value:"What About Libraries Using C Sources?",id:"what-about-libraries-using-c-sources",children:[],level:2},{value:"How to Help?",id:"contributing",children:[],level:2},{value:"tl;dr Just Tell Me How to Say Hello World",id:"build",children:[{value:"Checkout the GHC source",id:"checkout-the-ghc-source",children:[],level:4},{value:"Update the submodules",id:"update-the-submodules",children:[],level:4},{value:"Boot and Configure for JavaScript",id:"boot-and-configure-for-javascript",children:[],level:4},{value:"Build the JavaScript backend",id:"build-the-javascript-backend",children:[],level:4},{value:"Now Compile Hello World",id:"now-compile-hello-world",children:[],level:4}],level:2},{value:"Acknowledgements",id:"acknowledgements",children:[],level:2}],h={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A new JavaScript backend was\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/commit/cc25d52e0f65d54c052908c7d91d5946342ab88a"},"merged"),"\ninto GHC on November 30th, 2022! This means that the next release of GHC will be\nable to emit code that runs in web browsers without requiring any extra tools,\nenabling Haskell for both front-end and back-end web applications."),(0,r.kt)("p",null,"In this post, we, the GHC DevX team at ",(0,r.kt)("a",{parentName:"p",href:"https://iohk.io/"},"IOG"),", describe the\nchallenges we faced bringing GHCJS to GHC, how we overcame those challenges, and\nwhat's left to do. This post is rather long so we've provided these links in\ncase you would like to skip ahead:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"#ghcjs"},"Take me to the future of GHCJS"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"#expectations"},"Tell me what to expect"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"#roadmap"},"Show me the product roadmap"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"#contributing"},"Tell me how I can help"),(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("a",{parentName:"p",href:"#build"},"Just show me how to hello world! (Skip to build instructions)")),(0,r.kt)("h2",{id:"why-javascript-or-the-big-picture"},"Why JavaScript? Or, the Big Picture."),(0,r.kt)("p",null,"To put it simply, the number of users on the internet is as low as it will ever\nbe ",(0,r.kt)("em",{parentName:"p"},"right now"),", and it is almost guaranteed that those users use JavaScript. At\ntime of writing, JavaScript holds 97.3% of client-side programming ",(0,r.kt)("a",{parentName:"p",href:"https://w3techs.com/technologies/details/cp-javascript"},"market\nshare")," (not to mention\nmarket share of front-end technologies). Furthermore, JavaScript is not going to\ndisappear anytime soon. As more and more interactivity is pushed onto the\ninternet, JavaScript will become more entrenched because of backwards\ncompatibility, network effects and the amount of capital already devoted to it.\nJavaScript, like C and\n",(0,r.kt)("a",{parentName:"p",href:"https://cacm.acm.org/news/244370-cobol-programmers-are-back-in-demand-seriously/fulltext?mobile=false"},"COBOL"),"\nwill be with us for the foreseeable future. This makes JavaScript an attractive\ntarget; it provides portability, allows us to capitalize on the massive\ninvestments in the language and platform, and essentially eliminates the risk\nthat the we build our technology atop a disappearing or deprecating foundation."),(0,r.kt)("p",null,"WebAssembly is a promising target as well, and ",(0,r.kt)("a",{parentName:"p",href:"https://www.tweag.io/"},"Tweag"),"\nhas just merged a ",(0,r.kt)("a",{parentName:"p",href:"https://www.tweag.io/blog/2022-11-22-wasm-backend-merged-in-ghc/"},"WebAssembly\nbackend")," into\nGHC (great work and congrats!). WebAssembly is not as ubiquitous as\nJavaScript yet, and has a harder time interacting with JavaScript directly.\nHence, we believe that the WebAssembly and JavaScript backends provide different\nstrengths, and it is to the Haskell community's benefit to have and support\nboth code generation paths in GHC for different use cases and requirements."),(0,r.kt)("h2",{id:"why-haskell"},"Why Haskell?"),(0,r.kt)("p",null,"JavaScript has many problems ranging from the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.codeproject.com/Articles/182416/A-Collection-of-JavaScript-Gotchas"},"downstream"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://wtfjs.com/"},"effects")," of early ",(0,r.kt)("a",{parentName:"p",href:"https://dl.acm.org/doi/pdf/10.1145/3386327"},"design\ndecisions")," (that inhibit programmer\nproductivity and are subtle bug generators), to ecosystem ",(0,r.kt)("a",{parentName:"p",href:"https://lwn.net/Articles/681410/"},"security\nissues"),", to ",(0,r.kt)("a",{parentName:"p",href:"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"},"fundamental\nissues"),"\nwith asynchronous and concurrent programming."),(0,r.kt)("p",null,"These issues are problematic for our product domain. At IOG, a central\nengineering requirement is to create a code base that has a high degree of\ncorrectness. Haskell makes this easy; or to get a little technical, the\ncombination of Strong Static Hindley-Milner based typing allows us to write\nperformant, correct, and maintainable code. In addition to this, many of the\nproblems that occur in JavaScript are simply not expressible because of\nHaskell's type system and concurrency offerings."),(0,r.kt)("p",null,"There are, of course, competitors: ",(0,r.kt)("a",{parentName:"p",href:"https://www.purescript.org/"},"PureScript"),"\ntargets Javascript and provides a programmer experience close to Haskell's. The\nbenefit of using Haskell instead is code sharing: we can write the front-end of a\nweb app in Haskell that compiles to JavaScript and the back-end in Haskell that\ncompiles to machine code. In particular, the (de)serialization code (e.g.\nfrom/to JSON) is shared and cannot get out of sync between the front-end and the\nback-end."),(0,r.kt)("h2",{id:"why-a-ghc-backend"},"Why a GHC backend?"),(0,r.kt)("p",null,"Haskell is a language driven by its implementation in GHC. GHC development is\nvery active and GHC does not define a stable interface for compiler backends\nthat are independently maintained, which means that maintaining an out-of-tree\nbackend is costly."),(0,r.kt)("p",null,"The maintenance burden is not hypothetical; our teammate Luite Stegeman has been\ndeveloping a fork of GHC that emits JavaScript, called GHCJS, for close to 10\nyears and has experienced the pain first hand. Any changes to upstream GHC had\nto be adapted to the customized fork or GHCJS would fall behind. And fall behind\nit did: at the time of writing, GHCJS has stuck to using GHC 8.10, lagging\nbehind by three major releases and counting."),(0,r.kt)("p",null,"Similarly, the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/typelead/eta"},"Eta")," compiler","\u2014","which is\ntargeting the JVM","\u2014","faced the same issues and appears to be discontinued\n(compatibility with GHC 7.10.3's Haskell from 2015 is mentioned)."),(0,r.kt)("p",null,"Compounding the issue, the normal Haskell toolchain was not designed for an\nedge case like GHCJS. So GHCJS required that the normal tooling, e.g., Cabal and\nStack, could distinguish between GHC and GHCJS compilers. This\nmeant that the GHCJS developers had to maintain the GHC fork, develop GHCJS, and\npatch or contribute to Cabal and Stack. Simply put, the maintenance burden was\nmuch too high per developer. Examples of differences between GHCJS and GHC:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"GHCJS had a double version","\u2014","its own version and the version of GHC it was\nbased on","\u2014","and build tools had to deal with both"),(0,r.kt)("li",{parentName:"ul"},"GHCJS used non-standard file extension (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},".js_o")," and ",(0,r.kt)("inlineCode",{parentName:"li"},".js_a")," for objects\nand static libraries respectively) and custom file formats (still true for\n",(0,r.kt)("inlineCode",{parentName:"li"},".o")," but no longer true for ",(0,r.kt)("inlineCode",{parentName:"li"},".a"),")")),(0,r.kt)("p",null,"So instead of spending engineering time and energy ",(0,r.kt)("em",{parentName:"p"},"responding")," to ecosystem\nchanges and maintenance, the DevX team decided the best course of action was to\nenhance GHC's cross-compilation support and add a proper JavaScript backend\nbased on GHCJS. We feel that this adds value to the entire Haskell ecosystem,\nkeeps the JavaScript backend in sync with GHC, provides a better user experience\nfor all, reduces maintenance costs, and greatly improves the backends in GHC in\ngeneral. By implementing support for a JavaScript backend in GHC, we also\nimprove GHC's support for cross-compilation (and testing cross-compilers), which\nis directly applicable to the WebAssembly, iOS, and Android backends in GHC."),(0,r.kt)("h2",{id:"ghcjs"},"Is GHCJS Dead?"),(0,r.kt)("p",null,"Not yet! As it stands, the JavaScript backend doesn't provide all the features\nprovided by GHCJS. In particular it doesn't support Template Haskell and we've\nremoved the extended GHCJS FFI syntax to refine its design. See our roadmap\nbelow for more details."),(0,r.kt)("p",null,"Nevertheless GHCJS is unlikely to be updated to use a GHC version more recent\nthan 8.10.x. So from our point of view it is in maintenance mode until the\nJavaScript backend totally subsumes its features. New maintainers who want to\ncontinue the development of GHCJS until its feature set has been fully subsumed\nby mainline GHC are of course welcome."),(0,r.kt)("h2",{id:"expectations"},"What is Missing From GHCJS?"),(0,r.kt)("p",null,"The JavaScript backend borrows a lot of code from GHCJS, but not all of it.\nHere are the main differences between GHCJS and the JavaScript backend:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS was stuck on GHC version 8.10 while the JavaScript backend follows GHC HEAD.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS's incremental linking support (\"base\" bundles) hasn't been ported. This\nfeature required too many changes (such as adding new command-line flags) and\nwould have been backend-specific. This might be implemented in the future if\nit proves to be useful for the newer Template Haskell implementation, for example.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS's JavaScript code optimizer hasn't been ported. The code was trying to\ndo too much all at once and consequently was fragile and slow. We plan to\nwork on an intermediate representation between STG and JavaScript to perform\nthe same optimizations with better performance, maintainability, and\nreliability.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS's compactor (link time optimizations) code hasn't been ported. Some\noptimizations have been reimplemented (e.g. global renaming of local\nidentifiers), but some other are lacking (e.g. compacting initialization code).\nWe plan to work on this as part of a larger effort on refactoring the code\ngenerator, the linker, and some aspects of the runtime system.\nMore details are available in ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22352"},"GHC issue #22352"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS's hacky support for plugins hasn't been ported.\nInstead we implemented a new way to load plugins from shared libraries that\nworks in any GHC cross-compiler. See\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20964"},"#20964")," and\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7377"},"!7377"),"."),(0,r.kt)("p",{parentName:"li"},"The common and convenient approach to load plugins still isn't supported by\nGHC when it is used as a cross-compiler (see\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/14335"},"#14335")," for more\ndetails).")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS's support for Template Haskell hasn't been ported. GHCJS had its own implementation\nof an external interpreter (THRunner) which has been used as an inspiration\nto implement GHC's external interpreter (IServ).\nWhile serving the same purpose, IServ is quite different from\nTHRunner and can't be directly used as a substitute for it.\nRetrofitting THRunner into Iserv is our next priority. More details on\n",(0,r.kt)("a",{parentName:"p",href:"https://engineering.iog.io/2022-05-17-javascript-template-haskell-external-interpreter"},"https://engineering.iog.io/2022-05-17-javascript-template-haskell-external-interpreter"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"GHCJS supported an extended FFI import syntax allowing Javascript code to be\ninlined (the FFI import string supports templates of Javascript code with\nplaceholders for arguments). This hasn't been ported because adding a\nJavaScript parser to GHC was difficult and complex, and the imported code\nmade no safety guarantees whatsoever. For now, only JavaScript function calls\nare supported.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Any command-line flag introduced by GHCJS has not been ported. We didn't make\nany change to GHC's command line in this work except for adding a ",(0,r.kt)("inlineCode",{parentName:"p"},"-ddump-js"),"\nflag. Other options will be added later as needed.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The JavaScript backend itself hasn't been optimized and we even removed some\nundocumented uses of NFData from GHCJS's code. We intend to optimize\nthe JavaScript backend in a principled way (e.g. by first gathering evidence\nwith profiling)."))),(0,r.kt)("h2",{id:"roadmap"},"What's on the JS Backend's Roadmap?"),(0,r.kt)("p",null,"Our top priorities are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Implementing Template Haskell support."),(0,r.kt)("li",{parentName:"ul"},"Reducing generated JavaScript code size."),(0,r.kt)("li",{parentName:"ul"},"Modernizing the generated JavaScript code. The code generator adapted from\nGHCJS does not use more modern JavaScript features such as fat-arrows (",(0,r.kt)("inlineCode",{parentName:"li"},"=>"),"),\n",(0,r.kt)("inlineCode",{parentName:"li"},"symbols")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"let")," bindings. We aim for the JavaScript backend to emit\nJavaScript that comports with ",(0,r.kt)("a",{parentName:"li",href:"https://tc39.es/ecma262/"},"ECMA-262"),"."),(0,r.kt)("li",{parentName:"ul"},"Enhancing the run-time performance of the generated code")),(0,r.kt)("h2",{id:"what-has-improved-compared-to-ghcjs"},"What has Improved Compared to GHCJS?"),(0,r.kt)("p",null,"Or, why did it take you so long to port a stripped GHCJS into GHC? While it may\nseem like such a task should be relatively quick","\u2014","especially in a language\nwith such a good refactoring story like Haskell","\u2014","there were numerous road\nblocks that we needed to remove before adding the backend. In particular, here\nwere the troublesome bits:"),(0,r.kt)("h4",{id:"removing-the-use-of-external-libraries"},"Removing the Use of External Libraries"),(0,r.kt)("p",null,"GHCJS used libraries that aren't already dependencies of GHC, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"text"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"lens"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"attoparsec"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"aeson"),". As we didn't want to add new dependencies to GHC, we've\nrefactored the code to avoid them. Examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"we've replaced ",(0,r.kt)("inlineCode",{parentName:"li"},"Text")," with GHC's ",(0,r.kt)("inlineCode",{parentName:"li"},"ShortText")," (which provides a similar API)\nand finally with GHC's ",(0,r.kt)("inlineCode",{parentName:"li"},"FastString")," in most cases (which is usually more\nperformant)."),(0,r.kt)("li",{parentName:"ul"},"we've replaced a lot of lens-heavy code with its non-lens equivalents, because\nGHC does not use lenses itself, and a design requirement was to stay within\nexisting code conventions."),(0,r.kt)("li",{parentName:"ul"},"we've replaced ",(0,r.kt)("inlineCode",{parentName:"li"},"pretty")," with GHC's pretty-printer (",(0,r.kt)("inlineCode",{parentName:"li"},"SDoc"),", etc.)."),(0,r.kt)("li",{parentName:"ul"},"we've replaced ",(0,r.kt)("inlineCode",{parentName:"li"},"binary")," with GHC's ",(0,r.kt)("inlineCode",{parentName:"li"},"Binary")," instances.")),(0,r.kt)("p",null,"GHCJS used to provide its own ",(0,r.kt)("inlineCode",{parentName:"p"},"base")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"prim")," libraries: ",(0,r.kt)("inlineCode",{parentName:"p"},"ghcjs-base")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"ghcjs-prim"),". We've merged those into the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"base")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ghc-prim"),"\nlibraries."),(0,r.kt)("h4",{id:"reusing-ghcs-build-system-hadrian"},"Reusing GHC's Build System: Hadrian"),(0,r.kt)("p",null,"GHCJS has a reputation for being complex to build. It relied on custom build\nscripts to deal with the GHC fork it uses. The JavaScript backend however is as\neasy to build as any other GHC. It doesn't require any wrapper script, only the\n",(0,r.kt)("inlineCode",{parentName:"p"},"emconfigure")," tool provided by the\n",(0,r.kt)("a",{parentName:"p",href:"https://emscripten.org/docs/getting_started/downloads.html"},"Emscripten"),"\nproject."),(0,r.kt)("p",null,"With a fresh checkout of the GHC source tree, you can now build a GHC with the\nJavaScript backend with just these commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"> ./boot\n> emconfigure ./configure --target=js-unknown-ghcjs\n> ./hadrian/build --bignum=native -j\n")),(0,r.kt)("p",null,"Note that if this doesn't work, up to date instructions and troubleshootings can\nbe found on ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript-backend"},"https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript-backend")),(0,r.kt)("p",null,"The Hadrian build system has been adapted to support Cabal's ",(0,r.kt)("inlineCode",{parentName:"p"},"js-sources"),"\nstanzas that are to support user-provided ",(0,r.kt)("inlineCode",{parentName:"p"},".js")," files. Both the ",(0,r.kt)("inlineCode",{parentName:"p"},"rts")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"base"),"\npackages required this feature."),(0,r.kt)("h4",{id:"support-for-running-ghcs-test-suite"},"Support for Running GHC's Test Suite"),(0,r.kt)("p",null,"GHC's entire test suite can now run and check the JavaScript backend! We had to\ntweak Hadrian to make this possible (to make Hadrian cross-compiler aware), but\nthe test suite has already found some bugs that we have since fixed."),(0,r.kt)("p",null,"However, in order to merge for the GHC 9.6 release we had to disable many tests\nbecause of missing features (Template Haskell, Haskell Program Coverage (HPC),\ncompact regions, etc.) or because the generated code would time out (not\nsurprising given the missing optimizer and compactor)."),(0,r.kt)("p",null,"But in the process of disabling those tests we've laid a good path forward.\nWe've added more precise properties to the test suite, which indicate the\nrequired features to run each test. So when we implement some feature, it will\nbe painless to re-enable all its tests. In addition, failing tests now have\nproper tickets in GHC's ",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/?sort=created_date&state=opened&label_name%5B%5D=javascript&first_page_size=100"},"issue tracker"),"."),(0,r.kt)("p",null,"We've spent some time trying to run the test suite on CI but this work wasn't\nready in time to be included in the initial commit with the rest of the backend.\nFor now, only some basic testing is done on CI: compiling a non trivial program\nthat uses the GHC library into JavaScript and executing it.\nNevertheless, we have a merge request in the works so that future contributions\nshould be properly validated by running the test suite on CI soon."),(0,r.kt)("p",null,"For the time being, the following command will run the\ntest suite locally:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"./hadrian/build --bignum=native -j2 test")),(0,r.kt)("p",null,"We use ",(0,r.kt)("inlineCode",{parentName:"p"},"-j2")," to avoid running too many tests in parallel as this could allocate\ntoo much memory and fail, which isn't surprising as the JavaScript backend\nhasn't been optimized for memory usage yet."),(0,r.kt)("h4",{id:"upgrading-from-ghc-810-to-ghc-96"},"Upgrading from GHC 8.10 to GHC 9.6"),(0,r.kt)("p",null,"The latest version of GHCJS is based on a fork of GHC 8.10.7. We spent a\nsignificant amount of time adapting the code generator to support GHC HEAD. In\npractice this meant:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Adding support for new primops, especially sized primitives."),(0,r.kt)("li",{parentName:"ul"},"Adapting to ",(0,r.kt)("inlineCode",{parentName:"li"},"ghc-bignum")," changes."),(0,r.kt)("li",{parentName:"ul"},"Adapting to internal changes."),(0,r.kt)("li",{parentName:"ul"},"Fixing support for polymorphism in kinds."),(0,r.kt)("li",{parentName:"ul"},"Fixing support for unlifted newtypes."),(0,r.kt)("li",{parentName:"ul"},"Fixing support for unboxed sums."),(0,r.kt)("li",{parentName:"ul"},"Many other fixes...")),(0,r.kt)("h4",{id:"fixing-some-performance-issues"},"Fixing Some Performance Issues"),(0,r.kt)("p",null,"As we haven't ported GHCJS's Compactor, output size was predictably incredibly\nlarge. So we've spent time re-implementing a crucial piece of the\nCompactor","\u2014","renaming and shortening of local variables","\u2014","using a different\napproach. Our new approach ended up being faster than GHCJS's compactor. For the\nGHC devs out there, as we first replaced the ",(0,r.kt)("inlineCode",{parentName:"p"},"Text")," type with the ",(0,r.kt)("inlineCode",{parentName:"p"},"FastString"),"\ntype, the newer Compactor can now replace a ",(0,r.kt)("inlineCode",{parentName:"p"},"FastString"),"-based identifier with a\nnew identifier derived from the ",(0,r.kt)("inlineCode",{parentName:"p"},"FastString"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"Unique")," in constant time."),(0,r.kt)("h4",{id:"removal-of-custom-file-extensions-and-support-for-javascript-pragmas"},"Removal of Custom File Extensions and Support for JavaScript Pragmas"),(0,r.kt)("p",null,"GHCJS used the ",(0,r.kt)("inlineCode",{parentName:"p"},".js.pp")," file extension to identify JavaScript files that needed\nto be passed through CPP before being valid JavaScript. Adding support for this\nextension in both Hadrian and GHC proved to be more work than just adding\nsupport for JavaScript pragmas. So we decided to do the latter; similarly to\nHaskell extension pragmas, you can now write ",(0,r.kt)("inlineCode",{parentName:"p"},"//#OPTIONS: CPP")," in your\nJavaScript files to enable the CPP pass, and the file extension is always ",(0,r.kt)("inlineCode",{parentName:"p"},".js"),"."),(0,r.kt)("p",null,"While we're on the topic of file extensions, technically ",(0,r.kt)("inlineCode",{parentName:"p"},".js")," files don't have\nto be compiled into ",(0,r.kt)("inlineCode",{parentName:"p"},".o")," files (contrary to C/C++/Haskell/etc. files) at all.\nHowever, build systems (Hadrian, Cabal...) and compilers (GHC) expect this. So\nfor consistency with other backends, we've added a fake compilation pass for\n",(0,r.kt)("inlineCode",{parentName:"p"},".js")," files too. They are now renamed into ",(0,r.kt)("inlineCode",{parentName:"p"},".o")," files with a ",(0,r.kt)("inlineCode",{parentName:"p"},"//JAVASCRIPT"),"\nheader added to distinguish them from object files produced by the JavaScript\nbackend (and from Emscripten, in the future)."),(0,r.kt)("h4",{id:"blogs"},"Cleanup and Documentation"),(0,r.kt)("p",null,"GHC provides some utilities (pretty-printer, binary serialization, string\ninterning, etc.) that GHCJS did not make use of. So we adapted the GHCJS code to\nexploit these utilities, keep the JavaScript backend similar to other backends,\nand for better performance."),(0,r.kt)("p",null,"Three of us (out of four) were totally new to GHCJS's code base.\nWe strived to grok the code and to make it understandable by adding\na lot of comments and refactoring.\nThroughout this process we logged our learning in our engineering blog\nto explain some (sadly not all) technical details about GHCJS's internals:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-05-17-javascript-template-haskell-external-interpreter/"},"https://engineering.iog.io/2022-05-17-javascript-template-haskell-external-interpreter/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary/"},"https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-07-18-lightweight-threads-on-JavaScript/"},"https://engineering.iog.io/2022-07-18-lightweight-threads-on-JavaScript/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-07-20-js-backend-prim-types/"},"https://engineering.iog.io/2022-07-20-js-backend-prim-types/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-07-26-the-ghcjs-linker/"},"https://engineering.iog.io/2022-07-26-the-ghcjs-linker/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-08-18-js-backend-ffi/"},"https://engineering.iog.io/2022-08-18-js-backend-ffi/")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://engineering.iog.io/2022-09-23-ghcjs-heap-representation/"},"https://engineering.iog.io/2022-09-23-ghcjs-heap-representation/"))),(0,r.kt)("h4",{id:"plugin-support-in-cross-compilers"},"Plugin Support in Cross-Compilers"),(0,r.kt)("p",null,"GHC doesn't support plugins when built as a cross-compiler (cf\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/14335"},"#14335"),"). This is because it\ncannot yet support two environments at once: one for the target code (JavaScript\ncode here) and one for the host (e.g. native x86 or AArch64 code for the\nplugin). We've spent a lot of time making it more modular (see the ",(0,r.kt)("a",{parentName:"p",href:"https://hsyl20.fr/home/files/papers/2022-ghc-modularity.pdf"},"Modularizing\nGHC")," white paper we\npublished earlier this year and Sylvain's ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/OHGH5HLOCEM"},"lightning\ntalk")," at HIW 2022) but there is a lot more to do\nto achieve this (cf\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/17957"},"#17957"),")."),(0,r.kt)("p",null,"GHCJS used a fragile hack to support plugins: at plugin loading time it would\nsubstitute the plugin unit with another corresponding one from another package\ndatabase (For the non-GHC devs out there interested in GHC Units see this\n",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/blob/master/compiler/GHC/Unit.hs"},"note"),").\nThis was fragile because it could violate GHC's single environment assumptions."),(0,r.kt)("p",null,"GHCJS's hack did not get ported. Nevertheless we have implemented a new way for\nGHC to load plugins directly from libraries instead of packages\n(",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/20964"},"#20964"),"/",(0,r.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7377"},"!7377"),").\nThis method doesn't require GHC to load module interfaces for the plugin and its\ndependencies, hence workarounds GHC's limitations."),(0,r.kt)("h2",{id:"what-about-libraries-using-c-sources"},"What About Libraries Using C Sources?"),(0,r.kt)("p",null,"Libraries that use C sources (",(0,r.kt)("inlineCode",{parentName:"p"},"c-sources")," Cabal stanza) aren't supported by the\nJavaScript backend. In the future we plan to use Emscripten to compile C sources\nand then to generate some adapter code for them, but this isn't done yet."),(0,r.kt)("p",null,"For now, there are two ways to fix libraries that use C sources.\nThe C code can either be rewritten in Javascript, or it can be rewritten in\nHaskell.\nThen it is possible to use Cabal predicates (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"arch(js)"),") to select between\nthe different versions."),(0,r.kt)("p",null,"We do have a preference for writing pure Haskell versions because it is more\nfuture proof.\nFor example if someone adds some new backends for Lua, Java, CLR, etc. then the\nHaskell version can be directly compiled by that backend and there is no extra work.\nIn contrast, if the C source is rewritten in JavaScript, then it would need to\nbe rewritten ",(0,r.kt)("em",{parentName:"p"},"for each")," backend."),(0,r.kt)("p",null,"That is the approach we've taken when we wrote the ",(0,r.kt)("inlineCode",{parentName:"p"},"ghc-bignum")," library.\n",(0,r.kt)("inlineCode",{parentName:"p"},"Ghc-bignum"),' provides a "native" implementation written in Haskell that is\nfunctionally equivalent to the GMP based implementation. Of course, besides\nbeing more future proof the Haskell version is just more pleasant to write than\nthe Javascript version.'),(0,r.kt)("p",null,'Note that GHCJS came with a "shim" library where a shim is JavaScript source\ncode specifically for some package. For example, GHCJS provided shims for\npackages like ',(0,r.kt)("inlineCode",{parentName:"p"},"text"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"process"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"hashable"),". We do not intend the JavaScript\nbackend to provide shims so these JavaScript sources will have to be upstreamed\nor reimplemented in Haskell."),(0,r.kt)("p",null,"Note that the linking behavior is different due to the interpreted nature of\nJavascript. In the JavaScript backend, we can link with libraries using foreign\nimports ",(0,r.kt)("em",{parentName:"p"},"even if")," the imported functions don't exist. Instead of failing at link\ntime (which is what usually happens with native code) a JavaScript exception is\nraised only when and if the imported function is called."),(0,r.kt)("h2",{id:"contributing"},"How to Help?"),(0,r.kt)("p",null,"We have now reached our first milestone; anyone can easily build and test the\nJavaScript backend, and anyone can open bug reports or offer patches for the\nJavaScript backend on GHC's GitLab."),(0,r.kt)("p",null,"For those who offered their help this year: thank you! Until now it was\ndifficult to split the work into independent tasks (one fix led to a new\nfailure, which led to an architectural issue, etc.) and it was difficult to\ncoordinate with people outside of our team. However, we're now in a much better\nposition to discuss suggestions and to test/review patches in the spirit of open\nsource."),(0,r.kt)("h2",{id:"build"},"tl;dr Just Tell Me How to Say Hello World"),(0,r.kt)("p",null,"You need:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://emscripten.org/docs/getting_started/downloads.html"},"Emscripten"),"\nversion 3.14 or better. Be sure that your emscripten is bundled with either\nLLVM 15 or an up to date, patched LLVM 14."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://nodejs.org/en/"},"Nodejs"),", latest stable version. Only if you want to\nrun the compiled JavaScript with node.")),(0,r.kt)("p",null,"Most Linux distributions will have the necessary LLVM patches. If you're on NixOS,\nyou'll need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"llvm_git")," and hope for the best. ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/doyougnu/ghc.nix"},"This\nfork")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"ghc.nix")," will also be useful to\nyou."),(0,r.kt)("h4",{id:"checkout-the-ghc-source"},"Checkout the GHC source"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"git clone --recurse-submodules https://gitlab.haskell.org/ghc/ghc.git\ncd ghc # ensure you are in the ghc source tree for the following commands\n")),(0,r.kt)("h4",{id:"update-the-submodules"},"Update the submodules"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"git submodule update --init --recursive\n")),(0,r.kt)("h4",{id:"boot-and-configure-for-javascript"},"Boot and Configure for JavaScript"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"./boot && emconfigure ./configure --target=js-unknown-ghcjs\n")),(0,r.kt)("p",null,"You should see ",(0,r.kt)("inlineCode",{parentName:"p"},"configure")," finish and report something similar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"----------------------------------------------------------------------\nConfigure completed successfully.\n\n   Building GHC version  : 9.5.20220819\n          Git commit id  : 08c3c4783c72d3173d79ccda2ac282e2d3e04e34\n\n   Build platform        : x86_64-unknown-linux\n   Host platform         : x86_64-unknown-linux\n   Target platform       : js-unknown-ghcjs\n\n   Bootstrapping using   : /nix/store/4bkmkc7c98m4qyszsshnw9iclzzmdn4n-ghc-9.2.3-with-packages/bin/ghc\n      which is version   : 9.2.3\n      with threaded RTS? : YES\n\n   Using (for bootstrapping) : /nix/store/yzs8390walgk2rwl6i5li2g672hdn0kv-gcc-wrapper-11.3.0/bin/cc\n   Using clang               : /nix/store/p894nlicv53firllwgrfxfi51jzckh5l-emscripten-3.1.15/bin/emcc\n      which is version       : 15.0.0\n      linker options         : \n   Building a cross compiler : YES\n   Unregisterised            : NO\n   TablesNextToCode          : YES\n   Build GMP in tree         : NO\n   hs-cpp       : /nix/store/p894nlicv53firllwgrfxfi51jzckh5l-emscripten-3.1.15/bin/emcc\n   hs-cpp-flags : -E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs\n   ar           : /nix/store/p894nlicv53firllwgrfxfi51jzckh5l-emscripten-3.1.15/bin/emar\n   ld           : /nix/store/p894nlicv53firllwgrfxfi51jzckh5l-emscripten-3.1.15/bin/emcc\n   nm           : /nix/store/0dp0bfg9sncg7bjy389zwyg2gskknm6b-emscripten-llvm-3.1.15/bin/llvm-nm\n   objdump      : /nix/store/zgvxnf9047rdd8g8kq2zxxm9k6kfqf8b-binutils-2.38/bin/objdump\n   ranlib       : /nix/store/p894nlicv53firllwgrfxfi51jzckh5l-emscripten-3.1.15/bin/emranlib\n   otool        : otool\n   install_name_tool : install_name_tool\n   windres      : \n   dllwrap      : \n   genlib       : \n   Happy        : /nix/store/ijdmyaj6i6hgx5ll0lxxgcm9b0xn8nma-happy-1.20.0/bin/happy (1.20.0)\n   Alex         : /nix/store/qzgm2m7p7xc0fnyj4vy3jcmz8pvbg9p7-alex-3.2.6/bin/alex (3.2.6)\n   sphinx-build : /nix/store/27dk5i52465a4azjr2dqmrhyc0m4lpf2-python3.9-sphinx-4.5.0/bin/sphinx-build\n   xelatex      : /nix/store/8jc2258h4nqzqjy303zzkssd3ip675pf-texlive-combined-2021/bin/xelatex\n   makeinfo     : /run/current-system/sw/bin/makeinfo\n   git          : /nix/store/vsr2cn15h7cbwd5vqsam2ab2jzwfbyf9-git-2.36.0/bin/git\n   cabal-install : /nix/store/cjmd2qv1b5pdw4lxh1aw4xwwy4ibnb2p-cabal-install-3.6.2.0/bin/cabal\n\n   Using LLVM tools\n      clang : clang\n      llc   : llc\n      opt   : opt\n\n   HsColour was not found; documentation will not contain source links\n\n   Tools to build Sphinx HTML documentation available: YES\n   Tools to build Sphinx PDF documentation available: YES\n   Tools to build Sphinx INFO documentation available: YES\n----------------------------------------------------------------------\n")),(0,r.kt)("p",null,"Be sure to verify that ",(0,r.kt)("inlineCode",{parentName:"p"},"ar"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ld"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nm")," and friends point to the emscripten\nversions, i.e., the output shows ",(0,r.kt)("inlineCode",{parentName:"p"},"<tool> : <some-path>-emscripten-<tool>"),"."),(0,r.kt)("h4",{id:"build-the-javascript-backend"},"Build the JavaScript backend"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"./hadrian/build --bignum=native -j\n")),(0,r.kt)("h4",{id:"now-compile-hello-world"},"Now Compile Hello World"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-hs"},'module Main where\n\nmain :: IO ()\nmain = putStrLn "Hello JS!"\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ <path-to-ghc-root-dir>/_build/ghc-stage1 -fforce-recomp Main.hs\n$ ./Main\n$ Hello JS!\n")),(0,r.kt)("p",null,"Under the hood ",(0,r.kt)("inlineCode",{parentName:"p"},"Main")," is just a JavaScript program written as a script with\n",(0,r.kt)("inlineCode",{parentName:"p"},"nodejs")," as the interpreter. This means you can treat the compiled program like\nany other JavaScript program: loading it into JavaScript tooling or hack on it\nby hand. This also means that all compiled programs, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Main"),", are\nhuman-readable, for example here are the first ten lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"$ head Main\n#!/usr/bin/env node\nvar h$currentThread = null;\nvar h$stack = null;\nvar h$sp = 0;\nvar h$initStatic = [];\nvar h$staticThunks = {};\nvar h$staticThunksArr = [];\nvar h$CAFs = [];\nvar h$CAFsReset = [];\nvar h$regs = [];\n")),(0,r.kt)("p",null,"The program begins with a shebang instructing the operating system to send the\nrest of the file to ",(0,r.kt)("inlineCode",{parentName:"p"},"nodejs"),". The remaining lines are our actual program, which\nstarts with global variables that the runtime system, garbage collector, and\nscheduler need. Now human-readable is not the same as easy to understand, for\nexample here is the logic that implements a ",(0,r.kt)("inlineCode",{parentName:"p"},"Maybe"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function h$baseZCGHCziMaybeziJust_con_e() { return h$rs() };\nfunction h$baseZCGHCziMaybeziJust_e() {\nvar h$$13be2042 = h$r2;\nh$r1 = h$c1(h$baseZCGHCziMaybeziJust_con_e, h$$13be2042);\nreturn h$rs();\n};\nfunction h$baseZCGHCziMaybeziNothing_con_e() { return h$rs() };\n")),(0,r.kt)("p",null,"If you would like to understand this code and how the JavaScript backend works\nin general please see ",(0,r.kt)("a",{parentName:"p",href:"#blogs"},"our other blog posts"),". In any case, we invite you\nto try it out, hack, and be merry!"),(0,r.kt)("h2",{id:"acknowledgements"},"Acknowledgements"),(0,r.kt)("p",null,"We want to thank Jan Hrcek, and David Thrane Christiansen for their time, labor,\ncomments, and suggestions on drafts of this blog post."))}u.isMDXComponent=!0}}]);