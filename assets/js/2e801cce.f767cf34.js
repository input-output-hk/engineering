"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[9450],{6029:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"ghc-update-2022-04","metadata":{"permalink":"/ghc-update-2022-04","source":"@site/blog/2022-05-13-ghc-update-2022-04.md","title":"GHC April 2022 Update","description":"Welcome to the (rather late) April 2022 monthly update from the GHC DevX team at IOG. Since the last update we\'ve continued work on the upcoming JavaScript backend for GHC. Unfortunately, we have nothing to show quite yet but that doesn\'t mean nothing has happened! On the contrary, we\'ve made great progress and are close to that crucial first milestone hello world. Besides our work on the JavaScript backend, we were pleased to finally push through the Modularizing GHC paper that Sylvain has been working on for 2+ years! It causes quite the splash on the Haskell discourse and reddit, we recommend reading it if you haven\'t already (links below). Alright, enough introduction let\'s get into the update.","date":"2022-05-13T00:00:00.000Z","formattedDate":"May 13, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":1.94,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"},{"name":"Jeffrey M. Young","title":"Haskell DevX Engineer @ IOG","url":"https://iog.io/en/","key":"doyougnu"}],"frontMatter":{"slug":"ghc-update-2022-04","title":"GHC April 2022 Update","authors":["sylvain","doyougnu"],"tags":["ghc"]},"nextItem":{"title":"Setting up Csaba\'s External STG Interpreter","permalink":"/2022-05-02-setup-ext-stg-interp"}},"content":"Welcome to the (rather late) April 2022 monthly update from the GHC DevX team at IOG. Since the last update we\'ve continued work on the upcoming JavaScript backend for GHC. Unfortunately, we have nothing to show quite yet but that doesn\'t mean nothing has happened! On the contrary, we\'ve made great progress and are close to that crucial first milestone `hello world`. Besides our work on the JavaScript backend, we were pleased to finally push through the [Modularizing GHC](https://hsyl20.fr/home/posts/2022-05-03-modularizing-ghc-paper.html) paper that Sylvain has been working on for 2+ years! It causes quite the splash on the Haskell discourse and reddit, we recommend reading it if you haven\'t already (links below). Alright, enough introduction let\'s get into the update.\\n\\n## JavaScript Backend\\n\\nWe have made the following progresses in the implementation of a JavaScript\\nbackend for GHC (adapted from GHCJS):\\n\\n- **linker**: ported GHCJS\'s linker code into GHC. A lot of code was duplicated from GHC and\\n  slightly modified for GHCJS\'s needs, making the process far from trivial.\\n\\n- **testsuite**: fixed Hadrian to run GHC\'s testsuite with cross-compilers\\n  [!7850](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7850). There are\\n  remaining issues though (see\\n  [#21292](https://gitlab.haskell.org/ghc/ghc/-/issues/21292)).\\n\\n- **build system**: fixes for GHC\'s configure script were ported (e.g. support for\\n  the \\"ghcjs\\" target in ``config.sub``). GHCJS\'s custom\\n  build script was integrated into ``configure.ac``. We can now\\n  configure the build with: ``./configure --target=js-unknown-ghcjs``\\n\\n- **TH**: we have conducted some experiments to find the best way to bridge GHCJS\'s\\n  TH runner and GHC\'s external interpreter. This will be described in details in\\n  a future blog post.\\n\\n- **FFI**: basic support for JavaScript FFI has been ported from GHCJS to GHC. We\\n  haven\'t ported the JavaScript parser, so we have dropped the fancy import\\n  syntax (e.g. \\"$1.xyz\\"). It should be enough to build boot libraries and we\\n  will add JS parsing support later.\\n\\nAt this stage, we are working on building boot libraries and on supporting\\nlinking with the JS RTS.\\n\\nDevelopment happens in the following branch: https://gitlab.haskell.org/ghc/ghc/-/tree/wip/js-staging\\n\\n\\n## Modularity paper\\n\\nSylvain, Jeffrey, and John Ericson (from Obsidian Systems) wrote a paper about\\n\\"modularizing GHC\\" using domain-driven design.\\n\\n- Announce blog post: https://hsyl20.fr/home/posts/2022-05-03-modularizing-ghc-paper.html\\n- Paper: https://hsyl20.fr/home/files/papers/2022-ghc-modularity.pdf\\n- Reddit: https://www.reddit.com/r/haskell/comments/uhdu4l/modularizing_ghc_paper/\\n- Discourse: https://discourse.haskell.org/t/modularizing-ghc-paper/4471\\n\\nWe\'ve got a lot of great feedback about it (expect a first revision soon).\\nWe also got a GHC contribution directly inspired by the paper (see\\n[!8160](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/8160)) which was\\nvery welcome!"},{"id":"2022-05-02-setup-ext-stg-interp","metadata":{"permalink":"/2022-05-02-setup-ext-stg-interp","source":"@site/blog/2022-05-02-setup-ext-stg-interp.md","title":"Setting up Csaba\'s External STG Interpreter","description":"Table of Contents","date":"2022-05-02T00:00:00.000Z","formattedDate":"May 2, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"},{"label":"stg","permalink":"/tags/stg"},{"label":"tooling","permalink":"/tags/tooling"},{"label":"profiling","permalink":"/tags/profiling"},{"label":"optimization","permalink":"/tags/optimization"}],"readingTime":17.305,"truncated":false,"authors":[{"name":"Jeffrey M. Young","title":"Haskell DevX Engineer @ IOG","url":"https://iog.io/en/","key":"doyougnu"}],"frontMatter":{"slug":"2022-05-02-setup-ext-stg-interp","title":"Setting up Csaba\'s External STG Interpreter","date":"May 2, 2022","authors":["doyougnu"],"tags":["ghc","stg","tooling","profiling","optimization"]},"prevItem":{"title":"GHC April 2022 Update","permalink":"/ghc-update-2022-04"},"nextItem":{"title":"On the inlining of Integer and Natural operations","permalink":"/2022-04-28-on-the-inlining-of-integer-and-natural-operations"}},"content":"## Table of Contents\\n- [Making sense of the project](#orgfeb334e)\\n- [Building a working external STG interpreter](#org1d461dc)\\n  - [ghc.nix](#orgb670539)\\n  - [Building ghc-wpc](#orgbb3f1d5)\\n  - [Building the stg tooling](#org9ef4bc5)\\n- [Building the external-stg-interpreter](#org4a2eaf9)\\n- [Linking the external-stg-interpreter](#org1d34a2e)\\n- [The whole setup process on a demo](#org2daa4b8)\\n- [Summary](#org8193a1a)\\n  - [File Descriptions](#org940ba90)\\n  - [Step-by-Step guide for running the interpreter on your code](#org8e9f409)\\n\\nHaskell is a great language camouflaged by lackluster tooling. This situation\\nhas led to well-known problems (who could forget Cabal hell?). A less discussed\\nproblem is what I will call the &ldquo;Black-box syndrome&rdquo;: It is hard to\\nknow *exactly* what the memory representation and runtime performance of my\\nHaskell programs are[^1]. Now black-box syndrome is not *only* a problem,\\nit is also one of the nice features in the language since like all good\\nabstractions it elides things I&rsquo;d rather not care about, at least most of\\nthe time. In other words, I am happy I don&rsquo;t have to do manual memory\\nmanipulation!\\n\\nHowever, when I have my optimization hat on, I run face first into black-box syndrome. The crux of the problem is a tension between the need for observation during performance engineering and optimization, and the need to ship fast code. During development we want to be able to open up a system, see exactly how it is working, make tweaks, package it back up and test again. I want to be able to answer questions like &ldquo;Why is my executable this size?&rdquo;, &ldquo;Which code is a hot loop?&rdquo;, or &ldquo;When does my code do direct, known or unknown function calls?&rdquo;.\\n\\nIn order to answer these questions we need the ability to observe *every part of that system as the machine experiences it*, without this ability we have no way to make progress other than test, change some code, compile and test again in an ad-hoc manner. And therein lies the problem, most Haskell tooling is insufficient to provide the observability that we would like, instead the tooling often expects and requires us to make source code changes to our program or even recompile all of our libraries and code for a profiling way. This leads to the idea and *the expectation* in the Haskell community that Haskell programs are hard to optimize because the barrier to entry for optimization has artificially increased.\\n\\n[Csaba Hruska](https://www.patreon.com/csaba_hruska) has recently been making headway in this area with his work on the [GRIN](https://youtu.be/iXhh0NSR67k) compiler and an external STG interpreter. His STG interpreter (and patched ghc) exactly solve these problems and he has demonstrated dumping the entire call graph of large Haskell projects, filter to hot loops and finding unknown function calls in these graphs. If you haven&rsquo;t seen his [demo](https://www.youtube.com/watch?v=wt6iCgYmVGA&t=2054s) be sure to watch it, it is well worth your time.\\n\\nThis post is the first in a new blog series. In this blog series we&rsquo;re going to kick the tires on the external STG interpreter see what it can do, and what we can uncover in some popular libraries by using it. In particular, I&rsquo;m interested in running it on projects I&rsquo;ve previously optimized&#x2014;such as ghc itself, containers, unordered-containers&#x2014;using the standard methods: ticky-ticky profiling, prof, flamegraphs, heap profiling, ghc-debug, cachegrind etc. This post, however, will be focused on setting up the patched ghc and interpreter on a NixOS system. My goals are threefold:\\n\\n1.  Give an overview of the project and project layout to lower barrier to entry for the system.\\n2.  Give step by step instructions on setting up the interpreter on a nix-based system and provide a forked github repo for nix users. This should allow nix users to just `git clone foo` and `nix-build` (spoiler: it won&rsquo;t be that easy but still not hard.)\\n3.  Popularize Csaba&rsquo;s project! It is a refreshing take on Haskell optimization and compilation.\\n\\n\\n<a id=\\"orgfeb334e\\"></a>\\n\\n# Making sense of the project\\n\\nThe external STG interpreter is part of the [GRIN compiler](https://github.com/grin-compiler) project. We are not doing anything with the GRIN compiler (yet!) and so we are only interested in [The GHC whole compiler project](https://github.com/grin-compiler/ghc-whole-program-compiler-project). The whole-compiler-project has several sub-projects that we&rsquo;ll be building and using directly:\\n\\n-   [external-stg](https://github.com/grin-compiler/ghc-whole-program-compiler-project/tree/master/external-stg): This subproject provides utilites we&rsquo;ll be using, in particular `mkfullpak`\\n-   [external-stg-interpreter](https://github.com/grin-compiler/ghc-whole-program-compiler-project/tree/master/external-stg-interpreter): This is the actual STG interpreter. The good news is that this is independent of the rest of the project and can be built just like a regular Haskell executable\\n-   [ghc-wpc](https://github.com/grin-compiler/ghc-wpc/tree/b51ab235f5c07caa5eb3dd3b40487f67f50fb838): This is a fork of `ghc-8.10.x` (I&rsquo;m not sure exactly which version it forks to be honest) which we must build in order to use the external STG interpreter. Ghc-wpc serves as a frontend for the external-stg-interpreter.\\n\\n\\n<a id=\\"org1d461dc\\"></a>\\n\\n# Building a working external STG interpreter\\n\\nThe external STG interpreter can be built like any regular haskell executable. But in order to use the interpreter we have to build `ghc-wpc`. `ghc-wpc` is necessary because it serves as a frontend for the STG interpreter. It compiles a Haskell program like normal and then dumps an enriched STG IR to file. This file is then run through a utility `gen-exe` (gen-exe is an executable built in the [external-stg-compiler](https://github.com/grin-compiler/ghc-whole-program-compiler-project/tree/master/external-stg-compiler) sub-project) which picks up the compilation pipeline from the STG IR and creates an executable like we would expect from a normal compilation pipeline.\\n\\nThe major difference between this process and the usual compiler pipeline is that `ghc-wpc` leaves enough compiler information on disk for the rest of the tooling to consume, namely, in files with a `*.o_stgbin` (this is STG IR generated at compile time), and `*.o_stgapp` (project linker and dependency information) extension. Thus, once we build this custom ghc version we can use it to build the source code we wish to analyze and begin our optimization work.\\n\\nFor the rest of this tutorial I&rsquo;ll be referencing my [fork](https://github.com/doyougnu/ghc-whole-program-compiler-project) of the `ghc-whole-compiler-project` that includes everything you need if you want to follow along, including `.nix` files for creating a `nix-shell` which will prepare a suitable environment to run the entire toolchain.\\n\\n\\n<a id=\\"orgb670539\\"></a>\\n\\n## ghc.nix\\n\\nThe usual way to build ghc using a nix based system is with the [ghc.nix](https://github.com/alpmestan/ghc.nix) project. Ghc.nix provides a `default.nix` with a suitable environment to run hadrian and build ghc. For `ghc-wpc` we&rsquo;ll need some special packages, and we need our boot compiler to be *exactly* `ghc-8.3.3`. The custom `ghc.nix` file is included in my fork, I&rsquo;ve taken the liberty to pin the nixpkgs to the right version for `ghc-8.3.3`. So let&rsquo;s begin:\\n\\nClone the forked repo:\\n\\n```bash\\n$ git clone https://github.com/doyougnu/ghc-whole-program-compiler-project.git\\n\\n$ cd ghc-whole-program-compiler-project\\n\\n$ tree -L 1\\n.\\n\u251c\u2500\u2500 dist-newstyle\\n\u251c\u2500\u2500 external-stg\\n\u251c\u2500\u2500 external-stg-compiler\\n\u251c\u2500\u2500 external-stg-interpreter\\n\u251c\u2500\u2500 ghc.nix.wpc\\n\u251c\u2500\u2500 ghc-wpc\\n\u251c\u2500\u2500 lambda\\n\u251c\u2500\u2500 mod-pak\\n\u251c\u2500\u2500 README.md\\n\u251c\u2500\u2500 shell.nix\\n\u251c\u2500\u2500 stack.yaml\\n\u2514\u2500\u2500 stack.yaml.lock\\n```\\n\\nYou&rsquo;ll find the patched `ghc.nix` included (`ghc.nix.wpc`) and a `shell.nix` for a `nix-shell`. The `shell.nix` file simply references `ghc.nix.wpc/default.nix` with the appropriate options:\\n\\n```nix\\n$ cat shell.nix\\nimport (./ghc.nix.wpc/default.nix) {\\nuseClang = true;\\nwithHadrianDeps = true;\\nwithIde   = false;\\nwithLlvm  = true;\\n}\\n```\\n\\n\\n<a id=\\"orgbb3f1d5\\"></a>\\n\\n## Building ghc-wpc\\n\\nNow we can enter a nix-shell and build `ghc-wpc`:\\n\\n```bash\\n$ pwd\\n/home/doyougnu/programming/haskell/ghc-whole-program-compiler-project\\n\\n$ nix-shell shell.nix  # or just nix-shell\\ntrace: checking if /home/doyougnu/programming/haskell/ghc-whole-program-compiler-project/hadrian/hadrian.cabal is present:  no\\nRecommended ./configure arguments (found in $CONFIGURE_ARGS:\\nor use the configure_ghc command):\\n\\n  --with-gmp-includes=/nix/store/sznfxigwvrvn6ar3nz3f0652zsld9xqj-gmp-6.2.0-dev/include\\n  --with-gmp-libraries=/nix/store/447im4mh8gmw85dkrvz3facg1jsbn6c7-gmp-6.2.0/lib\\n  --with-curses-includes=/nix/store/84g84bg47xxg01ba3nv0h418v5v3969n-ncurses-6.1-20190112-dev/include\\n  --with-curses-libraries=/nix/store/xhhkr936b9q5sz88jp4l29wljbbcg39k-ncurses-6.1-20190112/lib\\n  --with-libnuma-includes=/nix/store/bfrcskjspk9a179xqqf1q9xqafq5s8d2-numactl-2.0.13/include\\n  --with-libnuma-libraries=/nix/store/bfrcskjspk9a179xqqf1q9xqafq5s8d2-numactl-2.0.13/lib\\n  --with-libdw-includes=/nix/store/sv6f05ngaarba50ybr6fdfc7cciv6nbv-elfutils-0.176/include\\n  --with-libdw-libraries=/nix/store/sv6f05ngaarba50ybr6fdfc7cciv6nbv-elfutils-0.176/lib\\n  --enable-dwarf-unwind\\n\\n[nix-shell:~/programming/haskell/ghc-whole-program-compiler-project]$\\n```\\n\\nNow we need to `cd` into `ghc-wpc` and tweak the hadrian build.\\n\\n**MAJOR CONSTRAINT: You must build ghc-wpc with hadrian/build-stack**, if you build in any other way you&rsquo;ll run into shared object errors, see this [ticket](https://github.com/grin-compiler/ghc-whole-program-compiler-project/issues/4) for details.\\n\\nSo in order to build `ghc-wpc` with stack we&rsquo;ll have to tweak the `stack.yaml` file. **You must do this since it is not included in the fork**:\\n\\nQuick side note: To make the formatting nicer I truncate\\n`nix-shell:~/foo/bar/baz/ghc-whole-program-compiler-project` to just `...`, so\\n`nix-shell:.../ghc-wpc` is equivalent to\\n`~/path/to/ghc-whole-compiler-project/ghc-wpc`.\\n\\n```bash\\n[nix-shell:...]$ cd ghc-wpc/hadrian/\\n\\n[nix-shell:.../ghc-wpc/hadrian]$ cat stack.yaml\\nresolver: lts-15.5\\n\\npackages:\\n- \'.\'\\n- \'GHC-Cabal\'\\n\\nsystem-ghc: true\\n\\nnix:\\n   enable: true\\n   shell-file: ../../shell.nix\\n```\\n\\nThe changes are: (1) tell `stack` we are using `nix`, and (2) reference the `shell.nix` file which points to `ghc.wpc.nix` at the root of the project, i.e., `ghc-whole-program-compiler-project/shell.nix`.\\n\\nNow we should be able to begin our build, return to the root of `ghc-wpc` and run the following:\\n\\n```bash\\n[nix-shell:.../ghc-wpc/hadrian]$ cd ..\\n\\n[nix-shell:.../ghc-wpc]$ ./boot && ./configure\\n\\n[nix-shell:.../ghc-wpc]$ hadrian/build-stack -j\\n```\\n\\nand go get some coffee since this will take some time. Once it finishes you should have the `ghc-wpc` binary in `_build/stage1/bin`\\n\\n```bash\\n[nix-shell:.../ghc-wpc]$ ls -l _build/stage1/bin/\\ntotal 8592\\n-rwxr-xr-x 1 doyougnu users 1843752 Apr 29 23:01 ghc\\n-rw-r--r-- 1 doyougnu users   11082 Apr 29 23:01 ghc.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users  660128 Apr 29 22:50 ghc-pkg\\n-rw-r--r-- 1 doyougnu users    9977 Apr 29 22:50 ghc-pkg.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users 4624680 Apr 29 23:01 haddock\\n-rw-r--r-- 1 doyougnu users   16883 Apr 29 23:01 haddock.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users   49344 Apr 29 22:25 hp2ps\\n-rw-r--r-- 1 doyougnu users    2504 Apr 29 22:25 hp2ps.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users  716440 Apr 29 22:35 hpc\\n-rw-r--r-- 1 doyougnu users    9959 Apr 29 22:35 hpc.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users  738544 Apr 29 22:35 hsc2hs\\n-rw-r--r-- 1 doyougnu users   10264 Apr 29 22:35 hsc2hs.dyn_o_ghc_stgapp\\n-rwxr-xr-x 1 doyougnu users   58384 Apr 29 22:34 runghc\\n-rw-r--r-- 1 doyougnu users    8864 Apr 29 22:34 runghc.dyn_o_ghc_stgapp\\n```\\n\\nNotice that this build dumped `*.<way>_o_ghc_stgapp` files!\\n\\n\\n<a id=\\"org9ef4bc5\\"></a>\\n\\n## Building the stg tooling\\n\\nNow that we have a working `ghc-wpc` we need to build the rest of the project by pointing `stack` to the `ghc-wpc` binary in `ghc-wpc/_build/stage1/bin`. That is, we must change the `ghc-whole-program-compiler-project/stack.yaml` file:\\n\\n```bash\\n[nix-shell:~/programming/haskell/ghc-whole-program-compiler-project]$ cat stack.yaml\\nresolver: lts-16.13\\n\\nallow-newer: true\\n\\npackages:\\n  - \'external-stg-compiler\'\\n  - \'external-stg\'\\n\\nghc-options:\\n  \\"$everything\\": -fno-stgbin -fno-stgapp -optcxx-std=c++17\\n\\nextra-deps:\\n  - async-pool-0.9.1@sha256:4015140f896c3f1652b06a679b0ade2717d05557970c283ea2c372a71be2a6a1,1605\\n  - souffle-haskell-1.1.0\\n  - zip-1.7.0\\n\\n\\n# use custom ext-stg whole program compiler GHC\\ncompiler:     ghc-8.11.0\\nskip-ghc-check: true\\n\\nnix:\\n  enable: false\\n\\n\\n# use local GHC (for development)\\nsystem-ghc: true\\nextra-path:\\n  - /home/doyougnu/programming/haskell/ghc-whole-program-compiler-project/ghc-wpc/_build/stage1/bin\\n\\n# DEBUG INFO\\n#dump-logs: all\\n#build:\\n#  keep-tmp-files: true\\n#  cabal-verbose: true\\n```\\n\\nThe changes are: (1) set `compiler: ghc-8.11.0` (the `ghc-wpc` fork), (2) set `skip-ghc-check: true` so that stack doesn&rsquo;t complain about the ghc version, (3) set `nix.enable: false`, confusingly if you leave this as true then stack will try to use `nixpkgs` to get a ghc binary, but we want it to use our local binary so we disable this even though we&rsquo;ll still be in our original nix-shell (4) set `system-path: true` to tell stack we will be using a ghc we have on our system, and finally (5) set `extra-path: <path-to-ghc-wpc-binary>`.\\n\\nNow we can run stack and install the stg tooling:\\n\\n```bash\\n[nix-shell:...]$ stack --stack-root `pwd`/.stack-root install\\nTrouble loading CompilerPaths cache: UnliftIO.Exception.throwString called with:\\n\\nCompiler file metadata mismatch, ignoring cache\\nCalled from:\\n  throwString (src/Stack/Storage/User.hs:277:8 in stack-2.7.5-9Yv1tjrmAU3JiZWCo86ldN:Stack.Storage.User)\\n\\nWARNING: Ignoring tagged\'s bounds on template-haskell (>=2.8 && <2.17); using template-haskell-2.17.0.0.\\nReason: allow-newer enabled.\\nWARNING: Ignoring aeson\'s bounds on template-haskell (>=2.9.0.0 && <2.17); using template-haskell-2.17.0.0.\\nReason: allow-newer enabled.\\nWARNING: Ignoring th-abstraction\'s bounds on template-haskell (>=2.5 && <2.17); using template-haskell-2.17.0.0.\\nReason: allow-newer enabled.\\nWARNING: Ignoring unliftio-core\'s bounds on base (>=4.5 && <4.14); using base-4.14.0.0.\\nReason: allow-newer enabled.\\nWARNING: Ignoring souffle-haskell\'s bounds on megaparsec (>=7.0.5 && <8); using megaparsec-8.0.0.\\nstack --stack-root `pwd`/.stack-root install\\n... # bunch of output\\n...\\n...\\nCopied executables to /home/doyougnu/.local/bin:\\n- dce-fullpak\\n- ext-stg\\n- fullpak\\n- gen-exe\\n- gen-exe2\\n- gen-obj\\n- gen-obj2\\n- mkfullpak\\n- show-ghc-stg\\n\\nWarning: Installation path /home/doyougnu/.local/bin not found on the PATH environment variable.\\n```\\n\\nYou can add `~/.local/bin` to your `PATH` if you want, I&rsquo;ll just be directly referencing these binaries as we go.\\n\\n\\n<a id=\\"org4a2eaf9\\"></a>\\n\\n# Building the external-stg-interpreter\\n\\nWe are almost all done, all that is left is to build the external-stg-interpreter and run a small script that links everything together into a shared object for the interpreter. So:\\n\\n```bash\\n[nix-shell:...]$ cd external-stg-interpreter/\\n\\n[nix-shell:.../external-stg-interpreter]$ stack install\\n...  # bunch of output\\n...\\nCopied executables to /home/doyougnu/.local/bin:\\n- ext-stg\\n- ext-stg-interpreter\\n- fullpak\\n- mkfullpak\\n\\nWarning: Installation path /home/doyougnu/.local/bin not found on the PATH environment variable.\\n```\\n\\nNow we have our `ext-stg-interpreter` built! There are a few caveats I want to point out here. I&rsquo;ve modified `ghc-whole-program-compiler-project/external-stg-interpreter/stack.yaml` to load the right packages and use nix:\\n\\n```bash\\n[nix-shell:.../external-stg-interpreter]$ cat stack.yaml\\nresolver: lts-16.13\\n\\npackages:\\n  - \'.\'\\n  - \'external-stg\'\\n\\nextra-deps:\\n  - souffle-haskell-2.1.0\\n  - primitive-0.7.1.0\\n  - zip-1.7.0\\n\\nnix:\\n  enable: true\\n  packages: [ zlib, libffi, pkg-config, bzip2 ]\\n```\\n\\nNotice the `nix:` block. We could have just as easily built this using `nix` directly or using our `shell.nix` file.\\n\\n\\n<a id=\\"org1d34a2e\\"></a>\\n\\n# Linking the external-stg-interpreter\\n\\nThe only task left is to link into a shared object library called\\n`libHSbase-4.14.0.0.cbits.so`. To do that we need to use the script called, `c`,\\nin `ghc-whole-program-compiler-project/external-stg-interpreter/data`. This\\nscript is a bit of a hack, it generates the shared object file so that we can link the symbols requested by the C\\nFFI in `base`, but it populates those functions with our replacements, which do absolutely nothing. For example, we supply a fake garbage collect:\\n```c\\n// in .../external-stg-interpreter/data/cbits.so-script/c-src/fake_rts.c\\n...\\nvoid performGC(void) {\\n}\\n\\nvoid performMajorGC(void) {\\n}\\n...\\n```\\n\\nThis works because we won\'t be using the runtime system at all, we\'ll be using\\nthe external STG interpreter instead, however we still need to provide these\\nsymbols in order to link. ****MAJOR NOTE: this file must be next to any\\n\\\\*.fullpak file you&rsquo;ll be running the interpreter on**** or else\\nyou&rsquo;ll get an undefined symbol error during linking, for example:\\n\\n```bash\\n[nix-shell:.../external-stg-interpreter/data]$ ls\\ncbits.so-script  ghc-rts-base.fullpak  minigame-strict.fullpak\\n\\n### notice no .so file\\n[nix-shell:.../external-stg-interpreter/data]$ ~/.local/bin/ext-stg-interpreter ghc-rts-base.fullpak\\next-stg-interpreter: user error (dlopen: ./libHSbase-4.14.0.0.cbits.so: cannot open shared object file: No such file or directory)\\n\\n## we error\'d out because it was missing, also\\n## if you get this error then you have an old cbits.so file and need to rerun the c script\\n[nix-shell:.../external-stg-interpreter/data]$ ~/.local/bin/ext-stg-interpreter ghc-rts-base.fullpak\\next-stg-interpreter: user error (dlopen: ./libHSbase-4.14.0.0.cbits.so: undefined symbol: getProcessElapsedTime)\\n```\\n\\nTo link the interpreter we need to run `c` in the `data/cbits.so-script` sub-folder:\\n\\n```bash\\n[nix-shell:.../external-stg-interpreter]$ cd data/cbits.so-script/\\n\\n[nix-shell:.../external-stg-interpreter/data/cbits.so-script]$ ls\\nar  c  cbits-rts.dyn_o  c-src  libHSbase-4.14.0.0.cbits.so  stub-base.dyn_o\\n\\n[nix-shell:.../external-stg-interpreter/data/cbits.so-script]$ ./c\\n++ ls ar/libHSbase-4.14.0.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSbindings-GLFW-3.3.2.0-Jg9TvsfYUZwD0ViIP0H2Tz-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSbytestring-0.10.9.0-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHScriterion-measurement-0.1.2.0-73BCI2Fnk7qE8QjjTa1xNa-ghc8.11.0.20210324.dyn_o_cbits.a ar/libHSghc-8.11.0.20210306-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSGLUT-2.7.0.15-1pzTWDEZBcYHcS36qZ2lpp-ghc8.11.0.20201112.dyn_o_cbits.a ar/libHSGLUT-2.7.0.15-1pzTWDEZBcYHcS36qZ2lpp-ghc8.11.0.20210324.dyn_o_stubs.a ar/libHShashable-1.3.0.0-Kn7aNSFvzgo2qY16wYzuCX-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSinteger-gmp-1.0.3.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSlambdacube-quake3-engine-0.1.0.0-7CKLP3Rqgq0PR81lhlwlR-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSmersenne-random-pure64-0.2.2.0-ExYg8DmthtrLG9JevQbt2m-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSOpenGLRaw-3.3.4.0-5vXBlmbOM3AIT7GRYfpE3o-ghc8.11.0.20201112.dyn_o_cbits.a ar/libHSprimitive-0.7.0.1-2k3g9qX0zz16vEv34R307m-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSprocess-1.6.8.2-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHStext-1.2.4.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSunix-2.7.2.2-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSunix-2.7.2.2-ghc8.11.0.20210220.dyn_o_stubs.a ar/libHSzlib-0.6.2.1-1I6DmfbLEyTBgDZI7SbZfW-ghc8.11.0.20210306.dyn_o_stubs.a\\n++ ls stub-base.dyn_o/Blank_stub.dyn_o stub-base.dyn_o/ClockGetTime_stub.dyn_o stub-base.dyn_o/Internals_stub.dyn_o stub-base.dyn_o/RUsage_stub.dyn_o\\n++ ls cbits-rts.dyn_o/StgPrimFloat.dyn_o cbits-rts.dyn_o/TTY.dyn_o\\n++ ls c-src/fake_rts.c c-src/hack.c c-src/hschooks.c\\n+ gcc -o libHSbase-4.14.0.0.cbits.so -shared -Wl,--whole-archive ar/libHSbase-4.14.0.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSbindings-GLFW-3.3.2.0-Jg9TvsfYUZwD0ViIP0H2Tz-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSbytestring-0.10.9.0-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHScriterion-measurement-0.1.2.0-73BCI2Fnk7qE8QjjTa1xNa-ghc8.11.0.20210324.dyn_o_cbits.a ar/libHSghc-8.11.0.20210306-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSGLUT-2.7.0.15-1pzTWDEZBcYHcS36qZ2lpp-ghc8.11.0.20201112.dyn_o_cbits.a ar/libHSGLUT-2.7.0.15-1pzTWDEZBcYHcS36qZ2lpp-ghc8.11.0.20210324.dyn_o_stubs.a ar/libHShashable-1.3.0.0-Kn7aNSFvzgo2qY16wYzuCX-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSinteger-gmp-1.0.3.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSlambdacube-quake3-engine-0.1.0.0-7CKLP3Rqgq0PR81lhlwlR-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSmersenne-random-pure64-0.2.2.0-ExYg8DmthtrLG9JevQbt2m-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSOpenGLRaw-3.3.4.0-5vXBlmbOM3AIT7GRYfpE3o-ghc8.11.0.20201112.dyn_o_cbits.a ar/libHSprimitive-0.7.0.1-2k3g9qX0zz16vEv34R307m-ghc8.11.0.20210306.dyn_o_cbits.a ar/libHSprocess-1.6.8.2-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHStext-1.2.4.0-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSunix-2.7.2.2-ghc8.11.0.20210220.dyn_o_cbits.a ar/libHSunix-2.7.2.2-ghc8.11.0.20210220.dyn_o_stubs.a ar/libHSzlib-0.6.2.1-1I6DmfbLEyTBgDZI7SbZfW-ghc8.11.0.20210306.dyn_o_stubs.a -Wl,--no-whole-archive stub-base.dyn_o/Blank_stub.dyn_o stub-base.dyn_o/ClockGetTime_stub.dyn_o stub-base.dyn_o/Internals_stub.dyn_o stub-base.dyn_o/RUsage_stub.dyn_o cbits-rts.dyn_o/StgPrimFloat.dyn_o cbits-rts.dyn_o/TTY.dyn_o -fPIC c-src/fake_rts.c c-src/hack.c c-src/hschooks.c -lm -lgmp -ltinfo -lGL -lX11 -lXi -lXrandr -lXxf86vm -lXcursor -lXinerama -lpthread\\n```\\n\\nThis will produce `libHSbase-4.14.0.0.cbits.so` in the immediate directory:\\n\\n```bash\\n[nix-shell:.../external-stg-interpreter/data/cbits.so-script]$ ls -l\\ntotal 984\\ndrwxr-xr-x 2 doyougnu users   4096 Apr 27 14:10 ar\\n-rwxr-xr-x 1 doyougnu users    300 Apr 27 14:10 c\\ndrwxr-xr-x 2 doyougnu users   4096 Apr 27 14:10 cbits-rts.dyn_o\\ndrwxr-xr-x 2 doyougnu users   4096 Apr 27 14:10 c-src\\n-rwxr-xr-x 1 doyougnu users 986008 Apr 30 11:50 libHSbase-4.14.0.0.cbits.so    ## <----- new\\ndrwxr-xr-x 2 doyougnu users   4096 Apr 27 14:10 stub-base.dyn_o\\n```\\n\\nNow we can test our interpreter by running it on the `*.fullpak` files in `external-stg-interpreter/data`:\\n\\n```bash\\n[nix-shell:.../external-stg-interpreter/data/cbits.so-script]$ cd ..\\n\\n[nix-shell:.../external-stg-interpreter/data]$ ls\\ncbits.so-script  ghc-rts-base-call-graph-summary  ghc-rts-base-call-graph.tsv  ghc-rts-base.fullpak  libHSbase-4.14.0.0.cbits.so  minigame-strict.fullpak\\n\\n## remove the old .so file\\n[nix-shell:.../external-stg-interpreter/data]$ rm libHSbase-4.14.0.0.cbits.so\\n\\n## soft-link to the one we just built\\n[nix-shell:.../external-stg-interpreter/data]$ ln -s cbits.so-script/libHSbase-4.14.0.0.cbits.so libHSbase-4.14.0.0.cbits.so\\n\\n[nix-shell:.../external-stg-interpreter/data]$ ls -l\\ntotal 79220\\ndrwxr-xr-x 6 doyougnu users     4096 Apr 30 11:50 cbits.so-script\\n-rw-r--r-- 1 doyougnu users       48 Apr 30 11:47 ghc-rts-base-call-graph-summary\\n-rw-r--r-- 1 doyougnu users    28238 Apr 30 11:47 ghc-rts-base-call-graph.tsv\\n-rw-r--r-- 1 doyougnu users 22450708 Apr 27 14:10 ghc-rts-base.fullpak\\nlrwxrwxrwx 1 doyougnu users       43 Apr 30 11:55 libHSbase-4.14.0.0.cbits.so -> cbits.so-script/libHSbase-4.14.0.0.cbits.so  ### <---- new\\n-rw-r--r-- 1 doyougnu users 58630129 Apr 27 14:10 minigame-strict.fullpak\\n\\n[nix-shell:.../external-stg-interpreter/data]$ ~/.local/bin/ext-stg-interpreter ghc-rts-base.fullpak\\nhello\\nhello\\nssHeapStartAddress: 53522\\nssTotalLNECount: 69\\nssClosureCallCounter: 360\\nexecuted closure id count: 114\\ncall graph size: 150\\n\\n[nix-shell:.../external-stg-interpreter/data]$ ls -l\\ntotal 79220\\ndrwxr-xr-x 6 doyougnu users     4096 Apr 30 11:50 cbits.so-script\\n-rw-r--r-- 1 doyougnu users       48 Apr 30 11:56 ghc-rts-base-call-graph-summary    ### <---- interpreter output\\n-rw-r--r-- 1 doyougnu users    28238 Apr 30 11:56 ghc-rts-base-call-graph.tsv        ### <---- interpreter output\\n-rw-r--r-- 1 doyougnu users 22450708 Apr 27 14:10 ghc-rts-base.fullpak\\nlrwxrwxrwx 1 doyougnu users       43 Apr 30 11:55 libHSbase-4.14.0.0.cbits.so -> cbits.so-script/libHSbase-4.14.0.0.cbits.so\\n-rw-r--r-- 1 doyougnu users 58630129 Apr 27 14:10 minigame-strict.fullpak\\n```\\n\\nAnd it works, we have two new files, `<foo>-call-graph-summary` and `<foo>-call-graph.tsv` which we can analyze to inspect the behavior of our program (more on this later).\\n\\n\\n<a id=\\"org2daa4b8\\"></a>\\n\\n# The whole setup process on a demo\\n\\nThat was a rather involved example, to make clear the dependencies and steps required to run this on your own code the rest of this tutorial will run the interpreter on two of Csaba&rsquo;s demo&rsquo;s from his skillshare talk. First let&rsquo;s grab the code:\\n\\n```bash\\n$ pwd\\n/home/doyougnu/programming/haskell\\n\\n$ git clone https://github.com/grin-compiler/ext-stg-interpreter-presentation-demos.git\\n\\n$ ls\\next-stg-interpreter-presentation-demos ghc-whole-program-compiler-project ..\\n```\\n\\nNow we&rsquo;ll run the first demo which is a simply fold over a list:\\n\\n```bash\\n$ nix-shell ghc-whole-program-compiler-project/shell.nix\\ntrace: checking if /home/doyougnu/programming/haskell/hadrian/hadrian.cabal is present:  no\\nRecommended ./configure arguments (found in $CONFIGURE_ARGS:\\nor use the configure_ghc command):\\n\\n  --with-gmp-includes=/nix/store/sznfxigwvrvn6ar3nz3f0652zsld9xqj-gmp-6.2.0-dev/include\\n  --with-gmp-libraries=/nix/store/447im4mh8gmw85dkrvz3facg1jsbn6c7-gmp-6.2.0/lib\\n  --with-curses-includes=/nix/store/84g84bg47xxg01ba3nv0h418v5v3969n-ncurses-6.1-20190112-dev/include\\n  --with-curses-libraries=/nix/store/xhhkr936b9q5sz88jp4l29wljbbcg39k-ncurses-6.1-20190112/lib\\n  --with-libnuma-includes=/nix/store/bfrcskjspk9a179xqqf1q9xqafq5s8d2-numactl-2.0.13/include\\n  --with-libnuma-libraries=/nix/store/bfrcskjspk9a179xqqf1q9xqafq5s8d2-numactl-2.0.13/lib\\n  --with-libdw-includes=/nix/store/sv6f05ngaarba50ybr6fdfc7cciv6nbv-elfutils-0.176/include\\n  --with-libdw-libraries=/nix/store/sv6f05ngaarba50ybr6fdfc7cciv6nbv-elfutils-0.176/lib\\n  --enable-dwarf-unwind\\n\\n[nix-shell:~/programming/haskell]$ cd ext-stg-interpreter-presentation-demos/demo-01-tsumupto/\\n\\n[nix-shell:~/programming/haskell/ext-stg-interpreter-presentation-demos/demo-01-tsumupto]$ ../../ghc-whole-program-compiler-project/ghc-wpc/_build/stage1/bin/ghc -O2 tsumupto.hs\\n[1 of 1] Compiling Main             ( tsumupto.hs, tsumupto.o )\\nLinking tsumupto ...\\n$ cd ext-stg-interpreter-presentation-demos/demo-01-tsumupto\\n\\n$ ls\\ntsumupto  tsumupto.hi  tsumupto.hs  tsumupto.o  tsumupto.o_ghc_stgapp  tsumupto.o_modpak\\n```\\n\\nNote, that we have two new files: `*.o_ghc_stgapp` and `.o_modpak` as a result of building with `ghc-wpc`. If you try to run this from outside the nix-shell you&rsquo;ll get an error about missing `mkmodpak`:\\n\\n```bash\\n$ ../../ghc-whole-program-compiler-project/ghc-wpc/_build/stage1/bin/ghc -O2 tsumupto.hs\\n[1 of 1] Compiling Main             ( tsumupto.hs, tsumupto.o )\\nghc: could not execute: mkmodpak\\n```\\n\\nNow that we have those files we can run the interpreter, but first though we need to make a `*.fullpak` file from the `*.o_ghc_stgapp` file and create a symbolic link to `libHSbase-4.14.0.0.cbits.so`:\\n\\n```bash\\n## make the fullpack file\\n$ ~/.local/bin/mkfullpak tsumupto.o_ghc_stgapp\\nall modules: 259\\napp modules: 113\\napp dependencies:\\n... # bunch of output\\n...\\nmain                                                         Main\\ncreating tsumupto.fullpak\\n\\n## create the link to the shared object file\\n$ ln -s ../../ghc-whole-program-compiler-project/external-stg-interpreter/data/cbits.so-script/libHSbase-4.14.0.0.cbits.so libHSbase-4.14.0.0.cbits.so\\n\\n## the final directory should look like this\\n$ ls\\nlibHSbase-4.14.0.0.cbits.so  tsumupto  tsumupto.fullpak  tsumupto.hi  tsumupto.hs  tsumupto.o  tsumupto.o_ghc_stgapp  tsumupto.o_modpak\\n```\\n\\nAnd now we can run the interpreter:\\n\\n```bash\\n$ ~/.local/bin/ext-stg-interpreter tsumupto.fullpak\\n50005000\\nssHeapStartAddress: 44082\\nssTotalLNECount: 43\\nssClosureCallCounter: 30275\\nexecuted closure id count: 112\\ncall graph size: 146\\n```\\n\\nThe first line is the output of the program and the rest are diagnostics that the interpreter outputs. More importantly we should have a tab-separated csv file and call graph file in our local directory after running the interpreter:\\n\\n```bash\\n$ ls -l\\ntotal 23876\\nlrwxrwxrwx 1 doyougnu users      114 Apr 30 12:21 libHSbase-4.14.0.0.cbits.so -> ../../ghc-whole-program-compiler-project/external-stg-interpreter/data/cbits.so-script/libHSbase-4.14.0.0.cbits.so\\n-rwxr-xr-x 1 doyougnu users  9442648 Apr 30 12:12 tsumupto\\n-rw-r--r-- 1 doyougnu users       53 Apr 30 12:23 tsumupto-call-graph-summary   ### <---- interpreter output\\n-rw-r--r-- 1 doyougnu users    27490 Apr 30 12:23 tsumupto-call-graph.tsv       ### <---- interpreter output\\n-rw------- 1 doyougnu users 14922366 Apr 30 12:19 tsumupto.fullpak\\n-rw-r--r-- 1 doyougnu users     1769 Apr 30 12:12 tsumupto.hi\\n-rw-r--r-- 1 doyougnu users      207 Apr 28 22:56 tsumupto.hs\\n-rw-r--r-- 1 doyougnu users     4488 Apr 30 12:12 tsumupto.o\\n-rw-r--r-- 1 doyougnu users     8817 Apr 30 12:12 tsumupto.o_ghc_stgapp\\n-rw------- 1 doyougnu users     9803 Apr 30 12:12 tsumupto.o_modpak\\n```\\n\\nWhich can be loaded into `gephi` for closer inspection of the call graph of our program. Be sure to watch the rest of the demo in Csaba&rsquo;s talk for this part! For now we&rsquo;ll be going over using `gephi` and these files in our next blog post in this series, stay tuned!\\n\\n\\n<a id=\\"org8193a1a\\"></a>\\n\\n# Summary\\n\\n\\n<a id=\\"org940ba90\\"></a>\\n\\n## File Descriptions\\n\\n-   `foo.modpak`: A zip file which contains the Core, STG, CMM, source code, and assembly for the module `foo`\\n-   `foo.fullpak`: A zip file which contains the same information as `modpack` but for every module of the program rather than just module `foo`.\\n-   `foo.o_ghc_stgapp`: a yaml like file that contains:\\n    -   the module&rsquo;s dependencies including package dependencies\\n    -   a bunch of file paths for shared objects of the libraries\\n    -   the flags the module was built with\\n-   `libHSbase-4.14.0.0.cbits.so`: shared object file created by `ext-stg-interpreter/data/cbits.so-script.c`. Required to be in the same directory as `ext-stg-interpreter` will be invoked.\\n\\n\\n<a id=\\"org8e9f409\\"></a>\\n\\n## Step-by-Step guide for running the interpreter on your code\\n\\n1.  Build your project with `ghc-wpc/_build/stage1/bin` by directly invoking that `ghc` (as I did in the demo-01 project) or by pointing stack to it with `system-ghc` and `extra-path` in `stack.yaml`, or by passing `-w <path-to-ghc-wpc-binary` with cabal.\\n2.  Generate the `foo.fullpak` file with `mkfullpak foo.o_ghc_stgapp`\\n3.  Soft-link to `libHSbase-4.14.0.0.cbits.so` in the directory you will run the interpreter in. This file must be present when you run the interpreter!\\n4.  Now run the interpreter on `project.fullpak`\\n5.  Analyze `foo-call-graph-summary` and `foo-call-graph.tsv` with whatever tools make sense to you\\n\\n## Footnotes\\n\\n[^1]: This isn&rsquo;t completely true, there is the `RuntimeRep` type controls\\n  exactly this and the levity polymorphism work by [Richard\\n  Eisenberg](https://richarde.dev/). See [this\\n  video](https://www.youtube.com/watch?v=Mb_B-j8ePfc) for examples on using these\\n  features. We do plan to include a more thorough and real world example on using\\n  levity polymorphism for better performance in the [haskell optimization\\n  handbook](https://github.com/haskellfoundation/tech-proposals/pull/26)."},{"id":"2022-04-28-on-the-inlining-of-integer-and-natural-operations","metadata":{"permalink":"/2022-04-28-on-the-inlining-of-integer-and-natural-operations","source":"@site/blog/2022-04-28-on-the-inlining-of-integer-and-natural-operations-bot8CUQvoe-import.md","title":"On the inlining of Integer and Natural operations","description":"In this post I discuss the inlining of Integer and Natural operations in Haskell. It\u2019s a promising performance work I\u2019ve been conducting six months ago, which was blocked by an independent issue, but that I will likely resume soon as the issue has been fixed in the meantime.","date":"2022-04-28T00:00:00.000Z","formattedDate":"April 28, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":4.135,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"}],"frontMatter":{"slug":"2022-04-28-on-the-inlining-of-integer-and-natural-operations","title":"On the inlining of Integer and Natural operations","authors":["sylvain"],"tags":["ghc"],"custom_edit_url":null},"prevItem":{"title":"Setting up Csaba\'s External STG Interpreter","permalink":"/2022-05-02-setup-ext-stg-interp"},"nextItem":{"title":"GHC March 2022 Update","permalink":"/2022-04-19-ghc-march-2022-update"}},"content":"In this post I discuss the inlining of Integer and Natural operations in Haskell. It\u2019s a promising performance work I\u2019ve been conducting six months ago, which was blocked by an independent issue, but that I will likely resume soon as the issue has been fixed in the meantime.\\n\\n---\\n\\n\\nTo follow this post, you must know that `Natural` numbers are represented as follows in `ghc-bignum`:\\n\\n```haskell\\n-- | Natural number\\n--\\n-- Invariant: numbers <= WORD_MAXBOUND use the `NS` constructor\\ndata Natural\\n   = NS !Word#\\n   | NB !BigNat#\\n```\\n\\nSmall naturals are represented with a `Word#` and large ones with a `BigNat#` (a `ByteArray#`).\\n\\nNow consider the following simple example using Natural:\\n\\n```haskell\\n-- | Add 2 to a Word. Use Natural to avoid Word overflow\\nfoo :: Word -> Natural\\nfoo x = fromIntegral x + 2\\n```\\n\\nThere are only small naturals involved: `fromIntegral x` is small because `x` is a `Word`, and `2` is small. We could hope that GHC would use `Word#` primops to implement this and would allocate a `Natural` heap object for the result *only*. However it\u2019s not what happens currently, even in GHC HEAD. In the following STG dump, we can see that a `Natural` heap object is allocated for `x` before calling `naturalAdd` (`let` bindings in STG reflect heap allocations):\\n\\n```haskell\\nfoo1 = NS! [2##];\\n\\nfoo =\\n    \\\\r [x_sXn]\\n        case x_sXn of {\\n        W# x#_sXp ->\\n        let { sat_sXq = NS! [x#_sXp]; } in  naturalAdd sat_sXq foo1;\\n        };\\n```\\n\\nLet\u2019s look at `naturalAdd`:\\n\\n```haskell\\n-- | Add two naturals\\nnaturalAdd :: Natural -> Natural -> Natural\\n{-# NOINLINE naturalAdd #-}\\nnaturalAdd (NS x) (NB y) = NB (bigNatAddWord# y x)\\nnaturalAdd (NB x) (NS y) = NB (bigNatAddWord# x y)\\nnaturalAdd (NB x) (NB y) = NB (bigNatAdd x y)\\nnaturalAdd (NS x) (NS y) =\\n   case addWordC# x y of\\n      (# l,0# #) -> NS l\\n      (# l,c  #) -> NB (bigNatFromWord2# (int2Word# c) l)\\n```\\n\\nWe are clearly in the last case where both arguments are small. It seems beneficial to allow this function to be inlined. If we did we would get:\\n\\n```javascript\\nfoo =\\n    \\\\r [x_s158]\\n        case x_s158 of {\\n        W# x#_s15a ->\\n        case addWordC# [x#_s15a 2##] of {\\n        (#,#) l_s15c ds_s15d ->\\n        case ds_s15d<TagProper> of ds1_s15e {\\n          __DEFAULT ->\\n              case int2Word# [ds1_s15e] of sat_s15f {\\n              __DEFAULT ->\\n              case bigNatFromWord2# sat_s15f l_s15c of ds2_s15g {\\n              __DEFAULT -> NB [ds2_s15g];\\n              };\\n              };\\n          0# -> NS [l_s15c];\\n        };\\n        };\\n        };\\n```\\n\\nwhich produces much better assembly code, especially if there is no carry:\\n\\n```\\n    addq $2,%rax       ; add 2 to a machine word\\n\\tsetc %bl           ; test the carry.\\n\\tmovzbl %bl,%ebx    ; it could be done\\n\\ttestq %rbx,%rbx    ; more efficiently\\n\\tjne _blk_c17c      ; with \\"jc\\"\\n_blk_c17i:\\n\\tmovq $NS_con_info,-8(%r12) ; alloc NS datacon value\\n\\tmovq %rax,(%r12)           ; with the addition result as payload.\\n\\tleaq -7(%r12),%rbx         ; make it the first argument\\n\\taddq $8,%rbp               ; and then\\n\\tjmp *(%rbp)                ; call continuation\\n...\\n```\\n\\nSo why aren\u2019t we always inlining `naturalAdd`? We even explicitly disallow it with a `NOINLINE` pragma. The reason is that `naturalAdd` and friends are involved in constant-folding rules.\\n\\nFor example, consider:\\n\\n```haskell\\nbar :: Natural -> Natural\\nbar x = x + 2\\n\\nbaz = bar 0x12345678913245678912345679123456798\\n```\\n\\nCurrently we get the following Core:\\n\\n```haskell\\nbar1 = NS 2##\\n\\nbar = \\\\ x_aHU -> naturalAdd x_aHU bar1\\n\\nbaz = NB 99114423092485377935703335253042771879834\\n```\\n\\nYou can see that `baz`  is a constant thanks to constant-folding.\\n\\nHowever if we let `naturalAdd` inline we get:\\n\\n```haskell\\nbaz\\n  = case bigNatAddWord# 99114423092485377935703335253042771879832 2##\\n    of ds_d11H\\n    { __DEFAULT ->\\n    NB ds_d11H\\n    }\\n```\\n\\n`baz` is no longer a constant.\\n\\nA solution would be to add constant-folding rules for `BigNat#` functions, such as `bigNatAddWord#`. This is exactly what we have started doing in [#20361](https://gitlab.haskell.org/ghc/ghc/-/issues/20361). Our new plan is:\\n\\n* Make `BigNat#` operation `NOINLINE` and add constant-folding rules for them\\n* Make Integer/Natural operations `INLINEABLE` (expose their unfolding)\\n* Hence rely on constant-folding for `Word#/Int#/BigNat#` to provide constant folding for `Integer` and `Natural`\\n\\nThe good consequences of this plan are:\\n\\n* Less allocations when bignum operations are inlined and some of the arguments are known to be small/big or fully known (constant).\\n* `Integer` and `Natural` are less magical: you can implement your own similar types and expect the same performance without having to add new rewrite rules\\n\\nThere were some unforeseen difficulties with this plan though:\\n\\n\\n1. Some of the rewrite rules we need involve unboxed values such as `BigNat#` and `Word#` and the weren\u2019t supported. Luckily, this has been recently fixed ([#19313](https://gitlab.haskell.org/ghc/ghc/-/issues/19313)) by removing the \u201capp invariant\u201d ([#20554](https://gitlab.haskell.org/ghc/ghc/-/issues/20554)). Thanks Joachim! That\u2019s the reason why we could resume this work now.\\n2. Some unfoldings (RHSs) become bigger due to the inlining of bignum operations. Hence they may not themselves be inlined further due to inlining thresholds even if it would be beneficial. A better inlining heuristic would fix this (see [#20516](https://gitlab.haskell.org/ghc/ghc/-/issues/20516)). It will likely be the topic of the next post."},{"id":"2022-04-19-ghc-march-2022-update","metadata":{"permalink":"/2022-04-19-ghc-march-2022-update","source":"@site/blog/2022-04-19-ghc-march-2022-update-jeDstmSW5A-import.md","title":"GHC March 2022 Update","description":"JS Backend","date":"2022-04-19T00:00:00.000Z","formattedDate":"April 19, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":2.4,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"}],"frontMatter":{"slug":"2022-04-19-ghc-march-2022-update","title":"GHC March 2022 Update","authors":["sylvain"],"tags":["ghc"],"custom_edit_url":null},"prevItem":{"title":"On the inlining of Integer and Natural operations","permalink":"/2022-04-28-on-the-inlining-of-integer-and-natural-operations"},"nextItem":{"title":"haskell.nix March Update","permalink":"/2022-04-08-haskell-nix-march-update"}},"content":"## JS Backend\\n\\nIn March the team focused on porting more GHCJS code to GHC head.\\n\\n* Most of us are new to GHCJS\u2019s codebase so we are taking some time to better understand it and to better document it as code gets integrated into GHC head.\\n* Development process: initially we had planned to integrate features one after the others into GHC head. However it was finally decided that features would be merged into a [wip/javascript-backend](https://gitlab.haskell.org/ghc/ghc/-/commits/wip/javascript-backend) branch first and then later merged into GHC head. After trying this approach we decided to work directly into another branch: [wip/js-staging](https://gitlab.haskell.org/ghc/ghc/-/commits/wip/js-staging) . Opening merge requests that can\u2019t be tested against a branch that isn\u2019t GHC head didn\u2019t bring any benefit and slowed us too much.\\n* Documentation: we wrote a document comparing the different approaches to target JavaScript/WebAssembly [ https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript](https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript)\\n* RTS: some parts of GHCJS\u2019s RTS are generated from Haskell code, similarly to code generated with the genapply program in the C RTS. This code has been ported to GHC head. As JS linking---especially linking with the RTS---will only be performed by GHC in the short term, we plan to make it generate this code dynamically at link time.\\n* Linker: most of GHCJS\u2019s linker code has been adapted to GHC head. Because of the lack of modularity of GHC, a lot of GHC code was duplicated into GHCJS and slightly modified. Now that both codes have diverged we need to spend some time making them converge again, probably by making the Linker code in GHC more modular.\\n* Adaptation to GHC head: some work is underway to replace GHCJS\u2019s Objectable type-class with GHC\u2019s Binary type-class which serves the same purpose. Similarly a lot of uses of Text have been replaced with GHC\u2019s ShortText or FastString.\\n* Template Haskell: GHCJS has its own TH runner which inspired GHC\u2019s external interpreter (\u201cIserv\u201d) programs. We have been exploring options to port TH runner code as an Iserv implementation. The Iserv protocol uses GADTs to represent its messages which requires more boilerplate code to convert them into JS because we can\u2019t automatically derive aeson instances for them.\\n* Plugins: we have an MR adding support for \u201cexternal static plugins\u201d to GHC [!7377](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7377). Currently it only supports configuring plugins *via* environment variables. We have been working on adding support for command-line flags instead.\\n* Testsuite: we have fixed GHC\u2019s build system so that it can run GHC\u2019s testsuite when GHC is built as a cross-compiler ([!7850](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7850)). There is still some work to do (tracked in [#21292](https://gitlab.haskell.org/ghc/ghc/-/issues/21292)) to somehow support tests that *run* compiled programs: with cross-compilers, target programs can\u2019t be directly executed by the host architecture.\\n\\n## Misc\\n\\n* [Performance book](https://github.com/haskellfoundation/tech-proposals/pull/26): some time was spent on the infrastructure (CI) and on switching the format of the book to ReStructured Text\\n* Modularity: some time was spent discussing GHC\u2019s design and refactoring (c.f. [!7442](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7442) and [#20927](https://gitlab.haskell.org/ghc/ghc/-/issues/20927))."},{"id":"2022-04-08-haskell-nix-march-update","metadata":{"permalink":"/2022-04-08-haskell-nix-march-update","source":"@site/blog/2022-04-08-haskell-nix-march-update-XOLP1OBCuw-import.md","title":"haskell.nix March Update","description":"Changes","date":"2022-04-08T00:00:00.000Z","formattedDate":"April 8, 2022","tags":[{"label":"nix","permalink":"/tags/nix"}],"readingTime":1.99,"truncated":false,"authors":[],"frontMatter":{"slug":"2022-04-08-haskell-nix-march-update","title":"haskell.nix March Update","authors":[],"tags":["nix"],"custom_edit_url":null},"prevItem":{"title":"GHC March 2022 Update","permalink":"/2022-04-19-ghc-march-2022-update"},"nextItem":{"title":"GHC February 2022 Update","permalink":"/2022-03-09-ghc-february-2022-update"}},"content":"## Changes\\n\\n* To cross compile Haskell code for windows a `wine` process must be used to evaluate Template Haskell code at compile time.  Some times this code needs DLLs to be present for the Template Haskell code to run.  We had been maintaining a list of DLLs manually ([#1400](https://github.com/input-output-hk/haskell.nix/pull/1400) for instance added `secp256k1`).  A more general solution ([#1405](https://github.com/input-output-hk/haskell.nix/pull/1405)) was found that uses the `pkgsHostTarget` environment variable to obtain a list of all the packages dependencies.  Then the DLLs from the are made available to the `wine` process running the Template Haskell code.  This should make more libraries build correctly while reducing unnecessary dependencies.\\n* The way Haskell.nix cleans source trees has changed with [#1403](https://github.com/input-output-hk/haskell.nix/pull/1403), [#1409](https://github.com/input-output-hk/haskell.nix/pull/1409) and [#1418](https://github.com/input-output-hk/haskell.nix/pull/1418).  When using Nix `>=2.4` source in the store is now filtered in the same way it is locally.  This has a couple of key advantages:\\n  * It makes it less likely that results on CI systems (where the source is likely to be in the store) will differ from results for local builds (where the source is in a cloned git repository).\\n  * Potential for reducing load on CI.  Although more work may be needed, this kind of filtering combined with the experimental content addressing features of Nix reduce the required rebuilds.\\n* In the past rather cryptic error messages were given when an attempt was made to use an old version of GHC on a platform Haskell.nix did not support it.  In some cases Haskell.nix would even attempt to build GHC and only fail after some time.  Better error messages are now given right away when an attempt is made to use a GHC version that is not supported for a particular platform [#1411](https://github.com/input-output-hk/haskell.nix/pull/1411)\\n\\n## Version Updates\\n\\n* GHC 9.2.2 was added [#1394](https://github.com/input-output-hk/haskell.nix/pull/1394)\\n\\n## Bug fixes\\n\\n* `gitMinimal` replaces `git` to reduce the dependency tree of `cabalProject` functions [#1387](https://github.com/input-output-hk/haskell.nix/pull/1387)\\n* Less used of `allowSubstitutes=false` [#1389](https://github.com/input-output-hk/haskell.nix/pull/1389)\\n* Fixed `aarch64-linux` builds by using correct boot compiler [#1390](https://github.com/input-output-hk/haskell.nix/pull/1390)\\n* `icu-i18n` package mapping added to make `text-icu` build [#1395](https://github.com/input-output-hk/haskell.nix/pull/1395)\\n* Fixes needed for newer `nixpkgs` versions\\n  * Use list for `configureFlags` [#1396](https://github.com/input-output-hk/haskell.nix/pull/1396)\\n  * The spdx json file is in a `.json` output [#1397](https://github.com/input-output-hk/haskell.nix/pull/1397)\\n  * `gdk_pixbuf` is now `gdk-pixbuf` [#1398](https://github.com/input-output-hk/haskell.nix/pull/1398)\\n* Replaced deprecated NixOS binary cache settings in docs [#1410](https://github.com/input-output-hk/haskell.nix/pull/1410)\\n* Enable static build of `secp256k1` on musl [#1413](https://github.com/input-output-hk/haskell.nix/pull/1413)\\n\\nFinally, we\u2019d like to thank all the awesome contributors, who make\xa0`haskell.nix`\xa0a thriving open source project!\xa0:heart:"},{"id":"2022-03-09-ghc-february-2022-update","metadata":{"permalink":"/2022-03-09-ghc-february-2022-update","source":"@site/blog/2022-03-09-ghc-february-2022-update-bnE9FHoNRc-import.md","title":"GHC February 2022 Update","description":"JS backend","date":"2022-03-09T00:00:00.000Z","formattedDate":"March 9, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":1.87,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"}],"frontMatter":{"slug":"2022-03-09-ghc-february-2022-update","title":"GHC February 2022 Update","authors":["sylvain"],"tags":["ghc"],"custom_edit_url":null},"prevItem":{"title":"haskell.nix March Update","permalink":"/2022-04-08-haskell-nix-march-update"},"nextItem":{"title":"2021 GHC update","permalink":"/2022-03-01-2021-ghc-update"}},"content":"## JS backend\\n\\nThis month we worked on adapting code from GHCJS to merge into GHC head. We also started discussing the implementation process publicly and especially with our colleagues at Well-Typed.\\n\\n* Ticket about adapting GHCJS\u2019 code into a proper JS backend for GHC has been opened \\\\[[#21078](https://gitlab.haskell.org/ghc/ghc/-/issues/21078)\\\\]. Feedback was very positive!\\n* There were discussions about the process and an agreement to target GHC 9.6 release \\\\[[email on ghc-devs](https://mail.haskell.org/pipermail/ghc-devs/2022-February/020580.html), [wiki page](https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript-backend)\\\\]\\n* `deriveConstants` is a program used to generate some header file included in the rts package. While it is mainly useful for native targets, we had to make it support Javascript targets \\\\[[!7585](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7585)\\\\]\\n* Javascript is going to be the first official target platform supported by GHC that has its own notion of managed heap objects. Hence we may need a new `RuntimeRep` to represent these values for Haskell codes interacting with JS codes via FFI. We opened [!7577](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7577) into which we tried to make this new `RuntimeRep` non JS specific so that it could be reused for future backends targeting other managed platforms (e.g. CLR, JVM). It triggered a lot of discussions summarized in [#21142](https://gitlab.haskell.org/ghc/ghc/-/issues/21142).\\n* GHCJS\u2019s code generator was ported to GHC head \\\\[[!7573](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7573)\\\\]. In its current state, we can generate Javascript unoptimised code -- the optimiser hasn\u2019t been ported yet -- by compiling a module with `-c -fjavascript`. It required many changes, not only to adapt to changes between GHC 8.10 and GHC head but also to avoid adding new package dependencies. It was also an opportunity to refactor and to document the code, which is still a work in progress.\\n* GHC doesn\u2019t use any lens library, hence to port the code generator we had to replace lenses with usual record accessors. It turned out that `case` alternatives in STG lacked them because they were represented with a triple. We took the opportunity to introduce a proper record type for them  [!7652](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7652)\\n\\n## Plutus-apps JS demo\\n\\n* We improved the proof of concept JavaScript library for generating Plutus transactions with a given set of constraints and lookups, exposing functionality from the `plutus-ledger-constraints` package. \\\\[[Report](https://github.com/hamishmack/plutus-apps/blob/1f331225853f502807aab370f82ec975bdec38ee/plutus-pab/mktx/README.md)\\\\]\\n\\n## Reporting\\n\\n* we wrote a blog post about the work we have done in 2021 as it wasn\u2019t covered anywhere else: <https://engineering.iog.io/2022-03-01-2021-ghc-update>"},{"id":"2022-03-01-2021-ghc-update","metadata":{"permalink":"/2022-03-01-2021-ghc-update","source":"@site/blog/2022-03-01-2021-ghc-update-g8gkJay36G-import.md","title":"2021 GHC update","description":"IOG is committed to improving Haskell developer experience, both by sponsoring the Haskell Foundation and by directly founding a team committed to this task: the Haskell DX team.","date":"2022-03-01T00:00:00.000Z","formattedDate":"March 1, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":8.415,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"}],"frontMatter":{"slug":"2022-03-01-2021-ghc-update","title":"2021 GHC update","authors":["sylvain"],"tags":["ghc"],"custom_edit_url":null},"prevItem":{"title":"GHC February 2022 Update","permalink":"/2022-03-09-ghc-february-2022-update"},"nextItem":{"title":"haskell.nix February Update","permalink":"/2022-03-01-haskell-nix-february-update"}},"content":"IOG is committed to improving Haskell developer experience, both by [sponsoring the Haskell Foundation](https://iohk.io/en/blog/posts/2020/11/04/iohk-sponsors-new-haskell-foundation) and by directly founding a team committed to this task: the Haskell DX team.\\n\\nThe team now tries to provide regular (monthly) updates about its work. This post is a bit longer because it covers all of 2021 which has not been covered anywhere else.\\n\\n## Code generation\\n\\n* Added a new backend for AArch64 architectures, especially to support Apple\u2019s M1. Previously AArch64 was only supported via the LLVM based backend which is much slower. \\\\[[!5884](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5884)\\\\]\\n* Added support for Apple\u2019s M1 calling convention. In GHC 9.2.1 it implied making lifted sized types (e.g. `Word8`, `Int16`...) use their unlifted counterparts (e.g. `Word8#`, `Int16#`...); in GHC 8.10.7 \u2013 a minor release \u2013\xa0 a less invasive but more fragile solution was implemented \\\\[[commit](https://gitlab.haskell.org/ghc/ghc/-/commit/c49250d88915db6acf88d2574db827cc2c4fa080)\\\\].\\n* Fixed a very old GHC issue \\\\[[#1257](https://gitlab.haskell.org/ghc/ghc/-/issues/1257)\\\\] by making GHCi support unboxed values \\\\[[!4412](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4412)\\\\]: ByteCode is now generated from STG instead of directly from Core. It allows more Haskell codes to be supported by HLS and it even allows GHC code to be loaded into GHCi \\\\[[link](https://mail.haskell.org/pipermail/ghc-devs/2021-October/020345.html)\\\\].\\n* Fixed a bug in the Cmm sinking pass that led to register corruption at runtime with the C backend. Even if we don\u2019t use the C backend, fixing this avoided spurious errors in CI jobs using it \\\\[[#19237](https://gitlab.haskell.org/ghc/ghc/-/issues/19237),[!5755](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5755/)\\\\]\\n* Fixed a register clobbering issue for 64-bit comparisons generated with the 32-bit x86 NCG backend \\\\[[commit](https://gitlab.haskell.org/ghc/ghc/-/commit/ecd6d14215eb40ac441c075e432ddaa0237f3c72)\\\\].\\n* Fixed generation of switches on sized literals in StgToCmm \\\\[[!6211](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6211)\\\\]\\n* Fixed LLVM shifts \\\\[[#19215](https://gitlab.haskell.org/ghc/ghc/-/issues/19215),[!4822](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4822)\\\\]\\n\\n## Linker\\n\\n* Fixed an off-by-one error in the MachO (Darwin) linker \\\\[[!6041](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6041/)\\\\]. The fix is simple but the debugging session was epic!\\n* Fix to avoid linking plugin units unconditionally with target code, which is wrong in general but even more so when GHC is used as a cross-compiler: plugins and target code aren\u2019t for the same platform \\\\[[#20218](https://gitlab.haskell.org/ghc/ghc/-/issues/20218),[!6496](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6496)\\\\]\\n\\n## Cross-compilation\\n\\n* With John Ericson (Obsidian Systems) we finally made GHC independent of its target \\\\[[!6791](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6791),[!6539](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6539)\\\\]. It means that there is no need to rebuild GHC to make it target another platform, so it now becomes possible to add support for a `--target=...` command-line flag \\\\[[#11470](https://gitlab.haskell.org/ghc/ghc/-/issues/11470)\\\\]. It also means that a cross-compiling GHC could build plugins for its host platform in addition to building code for its target platform.\\n* A side-effect of the previous bullet is that primops\u2019 types are now platform independent. Previously some of them would use Word64 on 32-bit architectures and Word on 64-bit architectures: now Word64 is used on every platform. A side-effect of this side-effect is that we had to make Word64 as efficient as Word: it now benefits from the same optimizations (constant folding [#19024](https://gitlab.haskell.org/ghc/ghc/-/issues/19024), etc.). On 32-bit platforms, it reduced allocations by a fair amount in some cases: e.g. -25.8% in T9203 test and -11.5% when running haddock on base library \\\\[[!6167](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6167)\\\\]. We hope it will benefit other 32-bit architectures such as JavaScript or WebAssembly.\\n* GHC built as a cross-compiler doesn\u2019t support compiler plugins \\\\[[#14335](https://gitlab.haskell.org/ghc/ghc/-/issues/14335)\\\\]. We have been working on refactoring GHC to make it support two separate environments in a given compiler session \u2013 one for target code and another for the plugin/compiler code. The implementation in \\\\[[!6748](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6748)\\\\] conflicts quite a lot with the support of multiple home-units that was added at about the same time. GHC needs to be refactored a lot more to correctly support this approach, so instead we implemented a different approach to load plugins which is more low-level and bypasses the issue \\\\[[#20964](https://gitlab.haskell.org/ghc/ghc/-/issues/20964), [!7377](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7377)\\\\].\\n* We made GHC consider the target platform instead of the host platform in guessOutputFile \\\\[[!6116](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6116)\\\\]\\n* Use target platform instead of host platform to detect literal overflows \\\\[[#17336](https://gitlab.haskell.org/ghc/ghc/-/issues/17336),[!4986](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4986)\\\\]\\n\\n## GHCJS\\n\\n* We updated GHCJS to use GHC 8.10.7 \\\\[[branch](https://github.com/ghcjs/ghcjs/tree/ghc-8.10)\\\\]\\n* We worked on making GHCJS\u2019s codebase more suitable for integration into GHC: reducing the number of dependencies, avoiding the use of Template Haskell, reusing GHC\u2019s build system, etc. There is now a GHCJS integrated into a GHC 8.10.7 fork \\\\[[branch](https://github.com/ghcjs/ghc/tree/ghc-8.10-ghcjs)\\\\].\\n* This experience led us to plan the realization of a JS backend into GHC head based on GHCJS. More information about this topic in our next report.\\n* We worked on making GHC\u2019s testsuite pass with GHCJS, triaging tests that legitimately fail on a JS platform from tests revealing real GHCJS issues. **\\\\[LINK\\\\]**\\n\\n## Windows\\n\\n* We seemed to be the first to try to build GHC on Windows with the updated GNU autotools 2.70 and this release made a breaking change to the way auxiliary files (config.guess, config.sub) were handled, breaking GHC\u2019s build ([#19189](https://gitlab.haskell.org/ghc/ghc/-/issues/19189#note_332168)). The root cause of the issue couldn\u2019t be easily solved so we modified GHC\u2019s build system to avoid the use of these auxiliary files, bypassing the issue. Most GHC devs won\u2019t ever notice that something was broken to begin with when they will update their GNU toolchain on Windows. \\\\[[!4768](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4768),[!4987](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4987),[!5065](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5065/)\\\\]\\n* Fixed cross-compilation of GHC from Linux to Windows using Hadrian \\\\[[#20657](https://gitlab.haskell.org/ghc/ghc/-/issues/20657),[!6945](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6945),[!6958](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6958)\\\\]\\n\\n## Numeric\\n\\n* Fixed Natural to Float/Double conversions to align with the method used for Integer to Float/Double and added missing rewrite rules \\\\[[!6004](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6004/)\\\\]\\n* Made most bignum literals be desugared into their final form in HsToCore stage instead of CoreToStg stage to ensure that Core optimizations were applied correctly to them \\\\[[#20245](https://gitlab.haskell.org/ghc/ghc/-/issues/20245),[!6376](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6376)\\\\]\\n* Some constant folding rules were missing and were added:\\n  * bitwise `and` primops when applied to a full mask (e.g. 0xFF for a 8-bit word). \\\\[[#20448](https://gitlab.haskell.org/ghc/ghc/-/issues/20448),[!6629](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6629)\\\\]\\n  * `negate` primops [#20347](https://gitlab.haskell.org/ghc/ghc/-/issues/20347),[!6535](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6535)\\n  * `timesInt2#` primop [#20374](https://gitlab.haskell.org/ghc/ghc/-/issues/20374),[!6531](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6531)\\n  * `ctz#/clz#/popCnt#` [#20376](https://gitlab.haskell.org/ghc/ghc/-/issues/20376),[!6532](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6532)\\n  * missing rewrite rule to make the implementation of `nat2Word#` efficient \\\\[[#15547](https://gitlab.haskell.org/ghc/ghc/-/issues/15547),[!6847](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6847)\\\\]\\n  * rules for `Natural` \\\\[[#15821](https://gitlab.haskell.org/ghc/ghc/-/issues/15821),[!4837](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4837)\\\\]\\n* Allowed some ghc-bignum operations to inline to get better performance, while still managing to keep constant-folding working \\\\[[#19641](https://gitlab.haskell.org/ghc/ghc/-/issues/19641),[!6677](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6677),[!6696](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6696),[!6306](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6306)\\\\]. There is some work left to do (cf [#20361](https://gitlab.haskell.org/ghc/ghc/-/issues/20361)) but it is blocked by [#19313](https://gitlab.haskell.org/ghc/ghc/-/issues/19313) which in turn is blocked by [#20554](https://gitlab.haskell.org/ghc/ghc/-/issues/20554) which should be fixed soon ([!6865](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6865), thanks Joachim!).\\n* The ubiquitous `fromIntegral` function used to have many associated rewrite rules to make it fast (avoiding heap allocation of a passthrough Integer when possible) that were difficult to manage due to the combinatorial number of needed rules ([#19907](https://gitlab.haskell.org/ghc/ghc/-/issues/19907), [#20062](https://gitlab.haskell.org/ghc/ghc/-/issues/20062)). We found a way to remove all these rules ([!5862](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5862)).\\n\\n## Technical debt & modularity\\n\\n* Made several component of the compiler independent of `DynFlags` (parsed command-line flags):\\n  * TmpFS (dealing with temporary files) \\\\[[!6186](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6186)\\\\]\\n  * Diagnostic options \\\\[[!6043](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6043)\\\\]\\n  * Tracing functions \\\\[[!5970](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5970)\\\\]\\n  * Logger \\\\[[!4757](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4757)\\\\]\\n  * Logger & Parser \\\\[[!5845](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5845)\\\\]\\n  * Hooks \\\\[[!4812](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4812)\\\\]\\n* Made the handling of \u201cpackage imports\u201d less fragile \\\\[[!6586](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6586)\\\\] and refactored some code related to dependencies and recompilation avoidance \\\\[[!6528](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6528),[!6346](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6346)\\\\].\\n* Abstracted plugin related fields from HscEnv \\\\[[!7175](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7175)\\\\]\\n* Made a home-unit optional in several places \\\\[[!7013](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7013/)\\\\]: the home-unit should only be required when compiling code, not when loading code (e.g. when loading plugins in cross-compilers [#14335](https://gitlab.haskell.org/ghc/ghc/-/issues/14335)).\\n* Made GHC no longer expose the (wrong) selected ghc-bignum backend with `ghc --info`. ghc-bignum now exposes a backendName function for this purpose \\\\[[#20495](https://gitlab.haskell.org/ghc/ghc/-/issues/20495),[!6903](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6903)\\\\]\\n* Moved `tmpDir` from Settings to `DynFlags` \\\\[[!6297](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6297/)\\\\]\\n* Removed use of `unsafePerfomIO` in `getProgName` \\\\[[!6137](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6137/)\\\\]\\n* Refactored warning flags handling \\\\[[!5815](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5815)\\\\]\\n* Made assertions use normal functions instead of CPP \\\\[[!5693](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5693)\\\\]\\n* Made the interpreter more independent of the driver \\\\[[!5627](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5627)\\\\]\\n* Replaced `ptext . sLit` with `text` \\\\[[!5625](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5625)\\\\]\\n* Removed broken \u201cdynamic-by-default\u201d setting \\\\[[#16782](https://gitlab.haskell.org/ghc/ghc/-/issues/16782),[!5467](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5467)\\\\]\\n* Abstracted some components from the compiler session state (`HscEnv`):\\n  * unit-related fields into a new `UnitEnv`datatype \\\\[[!5425](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5425)\\\\]\\n  * `FinderCache` and `NameCache`\\\\[[!4951](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4951)\\\\]\\n  * Loader state \\\\[[!5287](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5287)\\\\]\\n* Removed the need for a home unit-id to initialize an external package state (EPS) \\\\[[!5043](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5043)\\\\]\\n* Refactored `-dynamic-too` handling \\\\[[#19264](https://gitlab.haskell.org/ghc/ghc/-/issues/19264),[!4905](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4905)\\\\]\\n\\n## Performance\\n\\n* Made `divInt#, modInt# and divModInt#` branchless and inlineable \\\\[[#18067](https://gitlab.haskell.org/ghc/ghc/-/issues/18067),[#19636](https://gitlab.haskell.org/ghc/ghc/-/issues/19636),[!3229](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3229)\\\\]\\n* Fixed Integral instances for Word8/16/32 and `showWord` to use `quotRemWordN` \\\\[[!5891](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5891),[!5846](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5846/)\\\\]\\n* Improved performance of occurrence analysis \\\\[[#19989](https://gitlab.haskell.org/ghc/ghc/-/issues/19989),[!5977](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5977)\\\\]\\n* Fixed unnecessary pinned allocations in `appendFS` \\\\[[!5989](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5989/)\\\\]\\n* Added a rewrite rules for string literals:\\n  * Concatenation of string literals \\\\[[#20174](https://gitlab.haskell.org/ghc/ghc/-/issues/20174),[#16373](https://gitlab.haskell.org/ghc/ghc/-/issues/16373),[!6259](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6259)\\\\]\\n  * `(++) . unpackCString# \u21d2 unpackAppendCString#` leading to a 15% reduction in compilation time on a specific example. \\\\[[!6619](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6619)\\\\]\\n  * Compute SDoc literal size at compilation time \\\\[[#19266](https://gitlab.haskell.org/ghc/ghc/-/issues/19266), [!4901](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4901)\\\\]\\n* Fix for Dwarf strings generated by the NCG that were unnecessarily retained in the FastString table \\\\[[!6621](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6621)\\\\]\\n* Worked on improving inlining heuristics by taking into account applied constructors at call sites \\\\[[#20516](https://gitlab.haskell.org/ghc/ghc/-/issues/20516),[!6732](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6732)\\\\]. More work is needed though.\\n* Fixed [#20857](https://gitlab.haskell.org/ghc/ghc/-/issues/20857) by making the Id cache for primops used more often \\\\[[!7241](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7241)\\\\]\\n* Replaced some avoidable uses of `replicateM . length` with more efficient code \\\\[[!7198](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7198)\\\\]. No performance gain this time but the next reader of this code won\u2019t have to wonder if fixing it could improve performance.\\n* Made `exprIsCheapX` inline for modest but easy perf improvements \\\\[[!7183](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7183)\\\\]\\n* Removed an allocation in the code used to write text on a Handle (used by putStrLn, etc.) \\\\[[!7160](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7160)\\\\]\\n* Replaced inefficient list operations with more efficient `Monoid ([a],[b])` operations in the driver \\\\[[!7069](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7069)\\\\], leading to 1.9% reduction in compiler allocations in MultiLayerModules test.\\n* Disabled some callstack allocations in non-debug builds \\\\[[!6252](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6252/)\\\\]\\n* Made file copy in GHC more efficient \\\\[[!5801](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5801)\\\\]\\n* Miscellaneous pretty-printer enhancements \\\\[[!5226](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5226)\\\\]\\n* Type tidying perf improvements with strictness \\\\[[#14738](https://gitlab.haskell.org/ghc/ghc/-/issues/14738),[!4892](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4892)\\\\]\\n\\n## RTS\\n\\n* Fixed issues related to the RTS\u2019s ticker\\n  * Fixed some races \\\\[[#18033](https://gitlab.haskell.org/ghc/ghc/-/issues/18033),[#20132](https://gitlab.haskell.org/ghc/ghc/-/issues/20132),[!6201](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6201)\\\\]\\n  * Made the RTS open the file descriptor for its timer (`timerfd`) on Linux synchronously to avoid weird interactions with Haskell code manipulating file descriptors \\\\[[#20618](https://gitlab.haskell.org/ghc/ghc/-/issues/20618),[!6902](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6902)\\\\].\\n* Moved GHC\u2019s global variables used to manage Uniques into the RTS to fix plugin issues \\\\[[#19940](https://gitlab.haskell.org/ghc/ghc/-/issues/19940),[!5900](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5900)\\\\]\\n\\n## Build system / CI\\n\\n* Fixed Hadrian output to display warnings and errors after the multi screen long command lines \\\\[[#20490](https://gitlab.haskell.org/ghc/ghc/-/issues/20490),[!6690](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/6690)\\\\]\\n* Avoided the installation of a global `platformConstants` file; made GHC load constants from the RTS unit instead, allowing it to be reinstalled with different constants \\\\[[!5427](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5427)\\\\]\\n* Made `deriveConstants` output its file atomically \\\\[[#19684](https://gitlab.haskell.org/ghc/ghc/-/issues/19684),[!5520](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5520)\\\\]\\n* Made compression with `xz` faster on CI \\\\[[!5066](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/5066)\\\\]\\n* Don\u2019t build extra object with `-no-hs-main` \\\\[[#18938](https://gitlab.haskell.org/ghc/ghc/-/issues/18938),[!4974](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4974)\\\\]\\n* Add `hi-boot` dependencies with `ghc -M` \\\\[[#14482](https://gitlab.haskell.org/ghc/ghc/-/issues/14482),[!4876](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4876)\\\\]\\n\\n## Misc\\n\\n* Stack: fixed interface reading in `hi-file-parser` to support GHC 8.10 and 9.0 \\\\[[PR](https://github.com/commercialhaskell/hi-file-parser/pull/2), [Stack#5134](https://github.com/commercialhaskell/stack/issues/5134)\\\\]\\n* Enhanced pretty-printing of coercions in Core dumps \\\\[[!4856](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/4856)\\\\]"},{"id":"2022-03-01-haskell-nix-february-update","metadata":{"permalink":"/2022-03-01-haskell-nix-february-update","source":"@site/blog/2022-03-01-haskell-nix-february-update-wDy26Ro4GN-import.md","title":"haskell.nix February Update","description":"Documentation","date":"2022-03-01T00:00:00.000Z","formattedDate":"March 1, 2022","tags":[{"label":"nix","permalink":"/tags/nix"}],"readingTime":1.275,"truncated":false,"authors":[],"frontMatter":{"slug":"2022-03-01-haskell-nix-february-update","title":"haskell.nix February Update","authors":[],"tags":["nix"],"custom_edit_url":null},"prevItem":{"title":"2021 GHC update","permalink":"/2022-03-01-2021-ghc-update"},"nextItem":{"title":"GHC January 2022 update","permalink":"/2022-02-01-ghc-january-2022-update"}},"content":"## Documentation\\n\\n* A tutorial has been added on [building DWARF-enabled executables](https://outline.zw3rk.com/share/d461004d-1f2f-4d7a-95f2-4e20acb18cac) on linux systems.  There was also a related fix for building DWARF executables in a nix shell ([#1385](https://github.com/input-output-hk/haskell.nix/pull/1385))\\n\\n## Changes\\n\\n* Support for external Hackage repositories was improved by [#1370](https://github.com/input-output-hk/haskell.nix/pull/1370). We can now use an extra package repository just by adding a `repository` block to the `cabal.project` file.  This makes it easy to make use of an extra hackage databases such as [hackage.head](https://ghc.gitlab.haskell.org/head.hackage/) and [hackage-overlay-ghcjs](https://github.com/input-output-hk/hackage-overlay-ghcjs).  A `sha256` for the repository it can be added as a comment in the `repository` block or by including it in the `sha256map` argument.\\n\\n## Version Updates\\n\\n* nix-tools was updated to use the Cabal 3.6.2 and hnix 0.16 [nix-tools#113](https://github.com/input-output-hk/nix-tools/pull/113)\\n* Nixpkgs pins were bumped [#1371](https://github.com/input-output-hk/haskell.nix/pull/1371)\\n* Update booting on aarch64 linux to ghc 8.8.4 [1325](https://github.com/input-output-hk/haskell.nix/pull/1325) and [1374](https://github.com/input-output-hk/haskell.nix/pull/1374)\\n\\n## Bug fixes\\n\\n* Allow linking pcre statically with musl [#1363](https://github.com/input-output-hk/haskell.nix/pull/1363)\\n* Add gpiod to system nixpkgs map [#1359](https://github.com/input-output-hk/haskell.nix/pull/1359)\\n* Add poppler-cpp to png-config Nixpkgs map [#1373](https://github.com/input-output-hk/haskell.nix/pull/1373)\\n* Use the same logic that cabal-install uses for determining the path of a packages `.tar.gz` in a repository  [nix-tools#114](https://github.com/input-output-hk/nix-tools/pull/114)\\n* Fix libnuma dependency in rts.conf [1342](https://github.com/input-output-hk/haskell.nix/commit/18ebf60137dd2ff1be7363eb46f67ebfa366d1dd)\\n* Fix when \\"materialized\\" dir is deep [#1376](https://github.com/input-output-hk/haskell.nix/pull/1376)\\n* Prefer local building for `git-ls-files` [#1378](https://github.com/input-output-hk/haskell.nix/pull/1378) and [#1381](https://github.com/input-output-hk/haskell.nix/issues/1381)\\n* Fix stack cache generator `sha256` is a string not a lambda [#1383](https://github.com/input-output-hk/haskell.nix/pull/1383)\\n* Only pass `--index-state` to `cabal` when asked [#1384](https://github.com/input-output-hk/haskell.nix/pull/1384)\\n* Pass `enableDWARF` to `makeConfigFiles` to fix `-g3` support in `nix-shell` [#1385](https://github.com/input-output-hk/haskell.nix/pull/1385)\\n\\nFinally, we\u2019d like to thank all the awesome contributors, who make\xa0`haskell.nix`\xa0a thriving open source project!\xa0:heart:"},{"id":"2022-02-01-ghc-january-2022-update","metadata":{"permalink":"/2022-02-01-ghc-january-2022-update","source":"@site/blog/2022-02-01-ghc-january-2022-update-jTlkXUxJSn-import.md","title":"GHC January 2022 update","description":"Hopefully 2022 should be the year GHC will get a JavaScript backend without relying on GHCJS. This month the team has been busy planning the work that needs to be done to get there!","date":"2022-02-01T00:00:00.000Z","formattedDate":"February 1, 2022","tags":[{"label":"ghc","permalink":"/tags/ghc"}],"readingTime":0.9,"truncated":false,"authors":[{"name":"Sylvain Henry","title":"Haskell DevX Engineer @ IOG","email":"sylvain.henry@iohk.io","key":"sylvain"}],"frontMatter":{"slug":"2022-02-01-ghc-january-2022-update","title":"GHC January 2022 update","authors":["sylvain"],"tags":["ghc"],"custom_edit_url":null},"prevItem":{"title":"haskell.nix February Update","permalink":"/2022-03-01-haskell-nix-february-update"},"nextItem":{"title":"haskell.nix January Update","permalink":"/2022-02-01-haskell-nix-january-update"}},"content":"Hopefully 2022 should be the year GHC will get a JavaScript backend without relying on GHCJS. This month the team has been busy planning the work that needs to be done to get there!\\n\\n## Cross-compilation\\n\\n* GHCJS has been [updated](https://github.com/ghcjs/ghc/tree/ghc-8.10-ghcjs) to reduce the gap with GHC 8.10.7 codebase to the point that GHC\u2019s build system is used to build GHCJS\\n* Internal work planning for the integration of GHCJS into GHC\\n* A different approach to load plugins into cross-compilers has been implemented \\\\[[#20964](https://gitlab.haskell.org/ghc/ghc/-/issues/20964), [!7377](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7377)\\\\]\\n* GHCJS has been exercised to showcase compilation of some Plutus applications\\n\\n## Modularity\\n\\n* A few \u201csubsystems\u201d of GHC have been made more modular and reusable by making them independent of the command-line flags (`DynFlags`) \\\\[[#17957](https://gitlab.haskell.org/ghc/ghc/-/issues/17957), [!7158](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7158), [!7199](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7199), [!7325](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/7325)\\\\]. This work resulted in a 10% reduction in call sites to `DynFlags` and has now removed all references to `DynFlags` up to the `CoreToStg` pass, which is almost the entire backend of GHC.\\n\\n## Performance\\n\\n* Jeffrey wrote a new HF [proposal](https://github.com/haskellfoundation/tech-proposals/pull/26) about writing a Haskell Optimization handbook and has started working on it"},{"id":"2022-02-01-haskell-nix-january-update","metadata":{"permalink":"/2022-02-01-haskell-nix-january-update","source":"@site/blog/2022-02-01-haskell-nix-january-update-vNau7aVn4Q-import.md","title":"haskell.nix January Update","description":"January 2022","date":"2022-02-01T00:00:00.000Z","formattedDate":"February 1, 2022","tags":[{"label":"nix","permalink":"/tags/nix"}],"readingTime":1.215,"truncated":false,"authors":[],"frontMatter":{"slug":"2022-02-01-haskell-nix-january-update","title":"haskell.nix January Update","authors":[],"tags":["nix"],"custom_edit_url":null},"prevItem":{"title":"GHC January 2022 update","permalink":"/2022-02-01-ghc-january-2022-update"}},"content":"## **January 2022**\\n\\nThis month we merged some very significant improvements to the support for compiling for Android and iOS based AArch64 devices.\xa0 When the build system is also AArch64 template haskell can often be run locally.\xa0 This will make targeting mobile devices from AArch64 builders much easier.\\n\\nA long running branch containing bug fixes for cross compilation to JavaScript with GHCJS was merged.\xa0 One nice feature included is better support for adding bindings to C code compiled with emscripten.\xa0 In some cases it can be as easy as adding a single JavaScript file to the package with wrappers for the C functions.\\n\\n#### Changes\\n\\n* Much improved AArch64 support including Template Haskell (#1316)\\n* Improved GHCJS and support for calling C code compiled with emscripten (#1311)\\n* The environment variables LANG and LOCALE_ARCHIVE are no longer set in shells allowing the users prefered settings to persist (#1341).\\n* source-repo-override argument added for cabal projects to allow the location of source-repository-package packages to be replaced (#1354)\\n\\n#### Version Updates\\n\\n* GHC 9.0.2 was added to the available GHC versions (#1338)\\n* The nixpkgs pins for 21.05, 21.11 and unstable were all updated (#1334).\\n* Remaining uses of cabal 3.4 were updated to 3.6.2 (#1328)\\n\\n#### Bug fixes\\n\\n* Dwarf build of ghc 9.2.1 now skipped on hydra to work around 4GB hydra limit (#1333)\\n* Removed use of propagatedBuildInputs in ghc derivation (#1318).\\n* Caching of the check-hydra CI script was fixed (#1340)"}]}')}}]);