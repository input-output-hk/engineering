"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[7568],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,g=d["".concat(s,".").concat(u)]||d[u]||h[u]||i;return n?a.createElement(g,o(o({ref:t},c),{},{components:n})):a.createElement(g,o({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3764:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return c},toc:function(){return h},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={slug:"2023-02-09-ghc-update",title:"IOG GHC Update #3 (2023-02-09)",authors:["sylvain","doyougnu","luite","josh"],tags:["ghc","ghc-update"]},s=void 0,p={permalink:"/2023-02-09-ghc-update",source:"@site/blog/2023-02-09-ghc-update-2023-02-09.md",title:"IOG GHC Update #3 (2023-02-09)",description:"Biweekly update from the GHC DevX team at IOG.",date:"2023-02-09T00:00:00.000Z",formattedDate:"February 9, 2023",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"ghc-update",permalink:"/tags/ghc-update"}],readingTime:5.845,truncated:!1,authors:[{name:"Sylvain Henry",title:"Haskell DevX Engineer @ IOG",email:"sylvain.henry@iohk.io",key:"sylvain"},{name:"Jeffrey M. Young",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"doyougnu"},{name:"Luite Stegeman",title:"Haskell DevX Engineer @ IOG",email:"luite.stegeman@iohk.io",key:"luite"},{name:"Joshua Meredith",title:"Haskell DevX Engineer @ IOG",url:"https://iog.io/en/",key:"josh"}],frontMatter:{slug:"2023-02-09-ghc-update",title:"IOG GHC Update #3 (2023-02-09)",authors:["sylvain","doyougnu","luite","josh"],tags:["ghc","ghc-update"]},nextItem:{title:"GHC DevX Update 2023-01-26",permalink:"/2023-01-26-ghc-update"}},c={authorsImageUrls:[void 0,void 0,void 0,void 0]},h=[{value:"JavaScript backend",id:"javascript-backend",children:[{value:"Template Haskell",id:"template-haskell",children:[],level:3},{value:"JavaScript backend CI",id:"javascript-backend-ci",children:[],level:3},{value:"FileStat",id:"filestat",children:[],level:3},{value:"JavaScript RTS refactor",id:"javascript-rts-refactor",children:[],level:3},{value:"Warnings",id:"warnings",children:[],level:3},{value:"Fix for asynchronous exceptions",id:"fix-for-asynchronous-exceptions",children:[],level:3},{value:"Integer performance",id:"integer-performance",children:[],level:3},{value:"JavaScript EDSL",id:"javascript-edsl",children:[],level:3},{value:"Documentation",id:"documentation",children:[],level:3},{value:"Change from <code>js</code> to <code>javascript</code> architecture",id:"change-from-js-to-javascript-architecture",children:[],level:3}],level:2},{value:"Compiler performance",id:"compiler-performance",children:[{value:"More-strict <code>break</code>",id:"more-strict-break",children:[],level:3},{value:"Unboxed CodeBuffers",id:"unboxed-codebuffers",children:[],level:3},{value:"Optimization Handbook",id:"optimization-handbook",children:[],level:3},{value:"Constant folding for division operations",id:"constant-folding-for-division-operations",children:[],level:3}],level:2},{value:"GHCi",id:"ghci",children:[],level:2}],d={toc:h};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Biweekly update from the GHC DevX team at IOG."),(0,i.kt)("p",null,"Previous updates can be found ",(0,i.kt)("a",{parentName:"p",href:"https://engineering.iog.io/tags/ghc-update"},"here"),"."),(0,i.kt)("h2",{id:"javascript-backend"},"JavaScript backend"),(0,i.kt)("h3",{id:"template-haskell"},"Template Haskell"),(0,i.kt)("p",null,"Luite: fixed the support for one-shot mode (GHC's ",(0,i.kt)("inlineCode",{parentName:"p"},"-c")," command-line flag)\nin the TH JS linker."),(0,i.kt)("p",null,"Luite: Investigated a warning about the temporary directory not being removed\nafter running Template Haskell with the JavaScript backend. It turned out\nthat GHC's ",(0,i.kt)("inlineCode",{parentName:"p"},"GHC.Utils.TmpFs.newTempDir"),", which is used by the Template Haskell\nlinker, does not allow the newly created directory to be removed\n(see ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22952"},"#22952"),")."),(0,i.kt)("p",null,"Sylvain: cleaned up the ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9779"},"merge request"),",\nremoving unnecessary changes and adding documentation."),(0,i.kt)("h3",{id:"javascript-backend-ci"},"JavaScript backend CI"),(0,i.kt)("p",null,"Jeff: JavaScript backend CI was ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9552"},"finally\nmerged"),"! Now that we\nhave CI we are unblocked on several fronts, such as, implementing ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9825"},"faster\narithmetic")," and fixing\nsome ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9879"},"async\nexceptions"),". In\ngeneral, we can now have confidence that our work is progressing the JavaScript\nbackend to a better state."),(0,i.kt)("p",null,"Sylvain: fixed a spurious failure on JS CI due to some test ",(0,i.kt)("em",{parentName:"p"},"passing")," on fast runners\nwhile it was expected to fail (see ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9934"},"!9934"),")."),(0,i.kt)("p",null,"Josh: fixed some inaccurate test predicates ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9939"},"!9939")),(0,i.kt)("h3",{id:"filestat"},"FileStat"),(0,i.kt)("p",null,"Josh: rebased and merged ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9755"},"!9755"),".\nThis patch changes the representation of the JavaScript equivalent of the C ",(0,i.kt)("inlineCode",{parentName:"p"},"struct stat"),"\nto make its field offsets match the C ones: some Haskell codes directly access fields of\nthis structure using ",(0,i.kt)("inlineCode",{parentName:"p"},"hsc2hs")," to get the field offsets from the C headers."),(0,i.kt)("p",null,"This patch also adds fields to the JavaScript file stat that were previously not\nincluded, such as modification and access times."),(0,i.kt)("h3",{id:"javascript-rts-refactor"},"JavaScript RTS refactor"),(0,i.kt)("p",null,"Josh: rebased ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9794"},"!9794")," which consists\nin the refactor of the module generating some part of the RTS. The new JS CI job found a bug in the patch that\ncaused ~50 tests to time out, so waiting for CI to be set up before merging this MR was judicious."),(0,i.kt)("p",null,"This MR also became an opportunity to revisit some arbitrary cache sizes in the RTS code generator.\nThis is still ongoing work."),(0,i.kt)("h3",{id:"warnings"},"Warnings"),(0,i.kt)("p",null,'Luite: We accidently removed the check for the "javascript" calling convention on\nforeign imports, allowing this convention to be wrongly used on native platform.\nFixed in ',(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9880"},"!9880"),"."),(0,i.kt)("h3",{id:"fix-for-asynchronous-exceptions"},"Fix for asynchronous exceptions"),(0,i.kt)("p",null,"Luite: Fixed an issue in the garbage collector for the JavaScript backend:\nA thread that posts an asynchronous exception (",(0,i.kt)("inlineCode",{parentName:"p"},"throwTo"),") to another thread\nis temporarily suspended until the exception has been delivered. The\ngarbage collector did not correctly follow the list of threads suspended in\nthis way, potentially considering them unreachable and cleaning up data\nreferenced by them. See ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22836"},"#22836")," and\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9879"},"!9879"),"."),(0,i.kt)("h3",{id:"integer-performance"},"Integer performance"),(0,i.kt)("p",null,"Evaluating the following expression is very slow in general but especially with\nthe JS backend:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"1 `shiftL` (1 `shiftL` 20) :: Integer\n")),(0,i.kt)("p",null,"We've had to mark a test computing this as broken on CI because it triggers a\ntimeout error. Luckily the identification of slow operations is easy with\nJavaScript profiling tools (see graphs in\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22835"},"https://gitlab.haskell.org/ghc/ghc/-/issues/22835"),") and we know that ",(0,i.kt)("inlineCode",{parentName:"p"},"Word32"),"\nprimops are the culprit in this case."),(0,i.kt)("p",null,"Sylvain started replacing the uses of JavaScript's ",(0,i.kt)("inlineCode",{parentName:"p"},"BigInt")," in the\nimplementation of these primops with usual JavaScript ",(0,i.kt)("inlineCode",{parentName:"p"},"numbers"),".\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9825"},"!9825"),"."),(0,i.kt)("h3",{id:"javascript-edsl"},"JavaScript EDSL"),(0,i.kt)("p",null,"Jeff: JavaScript eDSL based on\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ku-fpg/sunroof-compiler"},"sunroof")," close to MR, see\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22736"},"#22736")," for background.\nCompiler is complete. Major items left are: the interpreter to translate to\n",(0,i.kt)("inlineCode",{parentName:"p"},"JStat"),", filling in documentation, and testing now that CI has been merged."),(0,i.kt)("h3",{id:"documentation"},"Documentation"),(0,i.kt)("p",null,"Jeff: Wrote the JavaScript backend release notes. Notes pending\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9828"},"approval"),". We cite\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/wikis/javascript-backend"},"JavaScript\nbackend")," wiki\npage in the release notes. So Jeff and Sylvain heavily edited the wiki pages to\nmake them suitable for external customers."),(0,i.kt)("h3",{id:"change-from-js-to-javascript-architecture"},"Change from ",(0,i.kt)("inlineCode",{parentName:"h3"},"js")," to ",(0,i.kt)("inlineCode",{parentName:"h3"},"javascript")," architecture"),(0,i.kt)("p",null,"In ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22740"},"#22740")," it was noticed that\n",(0,i.kt)("inlineCode",{parentName:"p"},"hackage-server")," would prevent the upload of the upcoming ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," package bundled with GHC 9.6.\nThe reason is that ",(0,i.kt)("inlineCode",{parentName:"p"},"hackage-server")," relies on the ",(0,i.kt)("inlineCode",{parentName:"p"},"cabal --check")," feature which filters\nout perfectly valid packages (it happened before, for example with ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/haskell/ghc-api-compat/-/issues/1"},"ghc-api-compat"),")."),(0,i.kt)("p",null,"In our case, the package was rejected because the ",(0,i.kt)("inlineCode",{parentName:"p"},"js")," architecture wasn't recognized\nas a built-in one, but luckily we could fall back to the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"javascript")," built-in\narchitecture defined for GHCJS (if it wasn't a JS backend, we would have had to fix Cabal,\nupdate ",(0,i.kt)("inlineCode",{parentName:"p"},"hackage-server")," dependencies, and redeploy ",(0,i.kt)("inlineCode",{parentName:"p"},"hackage-server"),"...)."),(0,i.kt)("p",null,"Sylvain completed Ben's MR in ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9814"},"!9814"),"."),(0,i.kt)("p",null,"For early users of the JS backend the change means that from now on:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"configure")," command is: ",(0,i.kt)("inlineCode",{parentName:"li"},"emconfigure ./configure --target=javascript-unknown-ghcjs")),(0,i.kt)("li",{parentName:"ul"},"Cabal condition is: ",(0,i.kt)("inlineCode",{parentName:"li"},"arch(javascript)")),(0,i.kt)("li",{parentName:"ul"},"CPP condition is: ",(0,i.kt)("inlineCode",{parentName:"li"},"#if defined(javascript_HOST_ARCH)"))),(0,i.kt)("h2",{id:"compiler-performance"},"Compiler performance"),(0,i.kt)("h3",{id:"more-strict-break"},"More-strict ",(0,i.kt)("inlineCode",{parentName:"h3"},"break")),(0,i.kt)("p",null,"Josh: opened merge request ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9868"},"!9868")," to add a stricter ",(0,i.kt)("inlineCode",{parentName:"p"},"break'")," version to ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," - however, this would require a CLC proposal."),(0,i.kt)("p",null,"Further analysis was done using ticky profiles on a simple test program that benchmarks GHC's startup code.\nThis has found an example where a more-strict break is an improvement in GHC, which will provide motivation\nfor the CLC proposal."),(0,i.kt)("h3",{id:"unboxed-codebuffers"},"Unboxed CodeBuffers"),(0,i.kt)("p",null,"Josh: implemented changes to GHC's text encoding buffers to use unboxed tuples on handle encoders/decoders.\nThe buffers pass around and repeatedly pack/unpack a tuple in an ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," inner loop, which causes a significant\nnumber of unnecessary allocations. By replacing this with an unboxed tuple, and replacing the ",(0,i.kt)("inlineCode",{parentName:"p"},"IO")," with\nmanually passing around a ",(0,i.kt)("inlineCode",{parentName:"p"},"State# RealWorld")," in the same tuple, we're able to reduce allocations by nearly 50%\nin a pathological example (non-allocating loop printing characters). See ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22946"},"#22946")," and ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9948"},"!9948"),"."),(0,i.kt)("h3",{id:"optimization-handbook"},"Optimization Handbook"),(0,i.kt)("p",null,"Jeff: opened IT ticket to move the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/hs-opt-handbook.github.io"},"Optimization\nHandbook")," to Haskell Foundation's repository.\nIT stated they need to check with legal, of course."),(0,i.kt)("p",null,"Jeff: almost finished the ",(0,i.kt)("a",{parentName:"p",href:"https://input-output-hk.github.io/hs-opt-handbook.github.io/src/Optimizations/GHC_opt/lambda_lifting.html"},"lambda\nlifting"),"\nchapter; major remaining items are adding some glossary terms and describing the\ninteraction between lambda lifting and calling conventions."),(0,i.kt)("h3",{id:"constant-folding-for-division-operations"},"Constant folding for division operations"),(0,i.kt)("p",null,"While looking into his old merge requests still opened, Sylvain nerd-snipped\nhimself into fixing constant folding rules for division operations (see\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22152"},"#22152"),")."),(0,i.kt)("p",null,"MR ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/8956"},"!8956")," adds the\nfollowing rewrite rules:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"   case quotRemInt# x y of\n     (# q, _ #) -> body\n  ====>\n   case quotInt# x y of\n     q -> body\n\n\n   case quotRemInt# x y of\n     (# _, r #) -> body\n  ====>\n   case remInt# x y of\n     r -> body\n\n\n  For all primitive numerical types:\n\n    (x `quot` l1) `quot` l2\n     | l1 /= 0\n     | l2 /= 0\n     | l1*l2 doesn't overflow/underflow\n   ====>\n    x `quot` (l1 * l2)\n")),(0,i.kt)("p",null,"It also makes some division primops (Word64/Int64 Quot/Rem, WordQuotRem2Op)\nok-for-speculation when the divisor is known to be non-zero, similarly to other\ndivision primops. Otherwise the last rule wasn't firing in the added test\nbecause we got the following Core (simplified for the presentation):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"case quotWord64# x# 10#Word64 of\n    ds1 -> case quotWord64# ds1 20#Word64 of\n        ds2 -> ...\n")),(0,i.kt)("p",null,"and not:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-haskell"},"case quotWord64# (quotWord64# x# 10#Word64) 20#Word64 of\n    ds2 -> ...\n")),(0,i.kt)("h2",{id:"ghci"},"GHCi"),(0,i.kt)("p",null,"Luite: A test run of GHC 9.6 with the ",(0,i.kt)("inlineCode",{parentName:"p"},"-fbyte-code-and-object-code")," flag\non ",(0,i.kt)("a",{parentName:"p",href:"https://ghc.gitlab.haskell.org/head.hackage/"},"head.hackage")," revealed\n",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22888"},"issue #22888")," with bytecode\nsize limits. Many bytecode instructions have ",(0,i.kt)("inlineCode",{parentName:"p"},"Word16")," operands, which\nis not always enough to run programs generated from optimized core. The solution\nis to enable large operands for all the bytecode instructions that deal with\nstack offsets. See ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/22888"},"#22888"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9957"},"!9957"),"."))}u.isMDXComponent=!0}}]);