"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[6651],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return h}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(a),h=i,k=d["".concat(l,".").concat(h)]||d[h]||c[h]||o;return a?n.createElement(k,r(r({ref:t},m),{},{components:a})):n.createElement(k,r({ref:t},m))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4380:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return m},toc:function(){return c},default:function(){return h}});var n=a(7462),i=a(3366),o=(a(7294),a(3905)),r=["components"],s={slug:"2023-04-14-io-sim-annoucement",title:"IOSim on Hackage!",authors:["coot"],tags:["haskell","io-sim","testing"],custom_edit_url:null},l=void 0,p={permalink:"/2023-04-14-io-sim-annoucement",source:"@site/blog/2023-04-14-io-sim-announcement.md",title:"IOSim on Hackage!",description:"IOSim on Hackage",date:"2023-04-14T00:00:00.000Z",formattedDate:"April 14, 2023",tags:[{label:"haskell",permalink:"/tags/haskell"},{label:"io-sim",permalink:"/tags/io-sim"},{label:"testing",permalink:"/tags/testing"}],readingTime:15.43,truncated:!1,authors:[{name:"Marcin Szamotulski",title:"Network Team Lead",email:"marcin.szamotulski@iohk.io",key:"coot"}],frontMatter:{slug:"2023-04-14-io-sim-annoucement",title:"IOSim on Hackage!",authors:["coot"],tags:["haskell","io-sim","testing"],custom_edit_url:null},nextItem:{title:"IOG GHC Update #7",permalink:"/2023-04-06-ghc-update"}},m={authorsImageUrls:[void 0]},c=[{value:"IOSim on Hackage",id:"iosim-on-hackage",children:[{value:"IO-Classes",id:"io-classes",children:[],level:3},{value:"SI-Timers",id:"si-timers",children:[],level:3},{value:"IOSim",id:"iosim",children:[],level:3},{value:"Strict-STM",id:"strict-stm",children:[],level:3},{value:"Strict-MVar",id:"strict-mvar",children:[],level:3},{value:"IO-Classes-MTL",id:"io-classes-mtl",children:[],level:3}],level:2},{value:"Examples",id:"examples",children:[{value:"STM test suite",id:"stm-test-suite",children:[],level:3},{value:"Simulated Network Interfaces",id:"simulated-network-interfaces",children:[],level:3},{value:"One code base for production &amp; testing",id:"one-code-base-for-production--testing",children:[],level:3}],level:2},{value:"Some IOSim features",id:"some-iosim-features",children:[{value:"Trace",id:"trace",children:[],level:3},{value:"Laziness",id:"laziness",children:[],level:3}],level:2}],d={toc:c};function h(e){var t=e.components,a=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"iosim-on-hackage"},"IOSim on Hackage"),(0,o.kt)("p",null,"The IOG Networking Team is pleased to announce that we published ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim")),",\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes")),", ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),", ",(0,o.kt)("inlineCode",{parentName:"p"},"strict-stm"),"], ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/strict-mvar"},(0,o.kt)("inlineCode",{parentName:"a"},"strict-mvar"))," and\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-mtl"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes-mtl"))," on Hackage.  These are tools without which we could not\nimagine writing a complex distributed system like ",(0,o.kt)("a",{parentName:"p",href:"https://www.github.com/input-output-hk/cardano-node#readme"},"Cardano"),"."),(0,o.kt)("p",null,"These packages support our goal of using the same code to run in production and\nsimulation, what greatly increases the reliability and quality of the final\nsystem.  ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim"))," and its ecosystem is designed to let write a simulation\nenvironment which provides provided things usually provided by an operating\nsystem like networking stack or disk IO and develop as well as implement\n& model complex applications/systems."),(0,o.kt)("p",null,"For developing a robust system one needs a proper testing framework which\nallows one to model the key characteristics of the system.  To achieve this\ngoal we needed to create an abstraction that captures the key aspects of the\nHaskell runtime and operating system environment for distributed systems.  The\nCardano ",(0,o.kt)("a",{parentName:"p",href:"https://www.github.com/input-output-hk/ouroboros-network#readme"},"network stack")," is a highly concurrent system, and\nas a network application, it needs to deal with time: there are all sorts of\ntimeouts that guard resource usage: inactivity timeouts, message timeouts, or\nan application level ",(0,o.kt)("inlineCode",{parentName:"p"},"TCP"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"WAIT_TIMEOUT")," among others.  The tools which we\nprovide permitted us to capture issues related to timing (which abound in\nnetwork programming) which, in production, would be extremely rare (things like\nsimultaneous TCP open or critical race conditions) and ensure that we can test\n(in the simulation) these scenarios.  Recently we caught\na ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/pull/4265"},"bug")," in simultaneous TCP open when one side of the\nconnection crashed - a corner case of a corner case, that's how effective is\nthe combination of quickcheck style property-based testing & simulation!"),(0,o.kt)("h3",{id:"io-classes"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/io-classes"},"IO-Classes")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes"))," allow testing production code under simulation where one can\nmock services usually provided by the operating system: socket API or disk IO\n(both will land on ",(0,o.kt)("inlineCode",{parentName:"p"},"Hackage")," at some point too).  Our design principle was to\nclosely follow the ",(0,o.kt)("inlineCode",{parentName:"p"},"base")," API but also provide extensions that are packaged as\nseparate libraries: ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),", ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/strict-stm"},(0,o.kt)("inlineCode",{parentName:"a"},"strict-stm")),", ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-mtl"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes-mtl")),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"io-classes")," support ",(0,o.kt)("inlineCode",{parentName:"p"},"MVar"),"'s and in the future it will also support\n",(0,o.kt)("inlineCode",{parentName:"p"},"IOVar"),"s.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"IO")," instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadMVar")," is using ",(0,o.kt)("inlineCode",{parentName:"p"},"GHC"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"MVar"),", while\n",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim")," instance is based on a ",(0,o.kt)("inlineCode",{parentName:"p"},"TVar")," specific to ",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim"),".  ",(0,o.kt)("inlineCode",{parentName:"p"},"MVar"),"s, whether\nnative or simulated, provide fairness but don't provide compositionality (like\n",(0,o.kt)("inlineCode",{parentName:"p"},"TVar"),"s do via ",(0,o.kt)("inlineCode",{parentName:"p"},"STM"),").  Here's a complete list of currently supported APIs\n(more to come in the future, if you need more we are happy to accept\ncontributions!).  The list includes APIs present in core packages like: ",(0,o.kt)("inlineCode",{parentName:"p"},"base"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"stm"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"time"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"MVar")," API;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"stm")," API: all monadic operations with support for ",(0,o.kt)("inlineCode",{parentName:"li"},"TVar"),"s, ",(0,o.kt)("inlineCode",{parentName:"li"},"TMVar"),"s,\n",(0,o.kt)("inlineCode",{parentName:"li"},"TQueue"),"s, ",(0,o.kt)("inlineCode",{parentName:"li"},"TBQueue"),"s, ",(0,o.kt)("inlineCode",{parentName:"li"},"TArray"),"s, ",(0,o.kt)("inlineCode",{parentName:"li"},"TSem"),"s, ",(0,o.kt)("inlineCode",{parentName:"li"},"TChan"),"s;"),(0,o.kt)("li",{parentName:"ul"},"fork API: ",(0,o.kt)("inlineCode",{parentName:"li"},"forkIO"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"forkOn"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"forkWithUnmask"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"killThread"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"yield"),";"),(0,o.kt)("li",{parentName:"ul"},"thread API: ",(0,o.kt)("inlineCode",{parentName:"li"},"myThreadId"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"labelThread"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"threadStatus"),";"),(0,o.kt)("li",{parentName:"ul"},"synchronous and asynchronous exceptions API: ",(0,o.kt)("inlineCode",{parentName:"li"},"throw"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"throwTo"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"catch"),",\n",(0,o.kt)("inlineCode",{parentName:"li"},"catchJust"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"try"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"tryJust"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"handle"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"handleJust"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"catches"),";\nand the high-level ",(0,o.kt)("inlineCode",{parentName:"li"},"bracket"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"finally"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"onException")," and\n",(0,o.kt)("inlineCode",{parentName:"li"},"bracketOnException"),";"),(0,o.kt)("li",{parentName:"ul"},"masking API: ",(0,o.kt)("inlineCode",{parentName:"li"},"mask"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"mask_"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"uninterruptibleMask"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"uninterruptibleMask_")),(0,o.kt)("li",{parentName:"ul"},"masking state API: ",(0,o.kt)("inlineCode",{parentName:"li"},"getMaskingState"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"interruptible"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"allowInterrupt")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"evaluate")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/async"},(0,o.kt)("inlineCode",{parentName:"a"},"async"))," API;"),(0,o.kt)("li",{parentName:"ul"},"event trace API: ",(0,o.kt)("inlineCode",{parentName:"li"},"traceEventIO"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"traceEventMarkerIO"),";"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ST")," support: ",(0,o.kt)("inlineCode",{parentName:"li"},"stToIO"),";"),(0,o.kt)("li",{parentName:"ul"},"time API: ",(0,o.kt)("inlineCode",{parentName:"li"},"getCurrentTime"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"getMonotonicTimeNSec"),"; (more in ",(0,o.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),")"),(0,o.kt)("li",{parentName:"ul"},"timeout API: ",(0,o.kt)("inlineCode",{parentName:"li"},"registerDelay"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"timeout")," ; (more in ",(0,o.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),")"),(0,o.kt)("li",{parentName:"ul"},"delays: ",(0,o.kt)("inlineCode",{parentName:"li"},"threadDelay"),"; (more in ",(0,o.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),")"),(0,o.kt)("li",{parentName:"ul"},"although this does not strictly belong to this list, we also support\n",(0,o.kt)("inlineCode",{parentName:"li"},"MonadFix"),", which at times is useful for both ",(0,o.kt)("inlineCode",{parentName:"li"},"IO")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"IOSim"),"!")),(0,o.kt)("p",null,"and non-standard APIs:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"say")," (a ",(0,o.kt)("inlineCode",{parentName:"li"},"print")," like function) "),(0,o.kt)("li",{parentName:"ul"},"labelling ",(0,o.kt)("inlineCode",{parentName:"li"},"TVar"),"s & friends (",(0,o.kt)("inlineCode",{parentName:"li"},"labelTVar"),")"),(0,o.kt)("li",{parentName:"ul"},"tracing committed values to ",(0,o.kt)("inlineCode",{parentName:"li"},"TVar"),"s and ",(0,o.kt)("inlineCode",{parentName:"li"},"TMVar"),"s, inspection of ",(0,o.kt)("inlineCode",{parentName:"li"},"TVar"),"s"),(0,o.kt)("li",{parentName:"ul"},"race exploration of ",(0,o.kt)("em",{parentName:"li"},"IOSimPOR"))),(0,o.kt)("p",null,"We plan to add support for ",(0,o.kt)("inlineCode",{parentName:"p"},"IORef"),"s."),(0,o.kt)("p",null,"There's even more but packaged in separate packages, keep reading!"),(0,o.kt)("h3",{id:"si-timers"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/si-timers"},"SI-Timers")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers"))," (",(0,o.kt)("a",{parentName:"p",href:"https://www.wikiwand.com/en/International_System_of_Units"},"SI"),") package was designed with two principles in mind:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"provide API which is consistent with ",(0,o.kt)("inlineCode",{parentName:"li"},"timers")," package and thus is using SI\nunits (seconds) rather than ",(0,o.kt)("inlineCode",{parentName:"li"},"Int")," represented milliseconds like ",(0,o.kt)("inlineCode",{parentName:"li"},"base")," does;"),(0,o.kt)("li",{parentName:"ul"},"provide a safe API for 32-bit systems.")),(0,o.kt)("p",null,"On a 32-bit system an ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," can represent up to ",(0,o.kt)("inlineCode",{parentName:"p"},"~35")," minutes, which often is\ntoo small for longer delays."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers"))," also comes with a non-standard polyfill for timers API.  The low\nlevel ",(0,o.kt)("inlineCode",{parentName:"p"},"base")," timers API (e.g. ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Event.html#v:registerTimeout"},(0,o.kt)("inlineCode",{parentName:"a"},"registerTimeout"))," & friends) is not available\non all the systems (currently not available on ",(0,o.kt)("inlineCode",{parentName:"p"},"Windows")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"GHCJS"),").\nAlthough ",(0,o.kt)("inlineCode",{parentName:"p"},"GHC")," native timers are performant (when available), our polyfill is\nonly good enough to develop sub-second timeouts.  It's not performant enough on\nall platforms for sub-millisecond timeouts as it uses concurrency (on ",(0,o.kt)("inlineCode",{parentName:"p"},"Windows"),"\nor ",(0,o.kt)("inlineCode",{parentName:"p"},"GHCJS"),") and thus relies on GHC scheduler.  In the future, we are planning\nto release an implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"timeout")," API which is performant across all\nplatforms (which is part of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/tree/master/network-mux"},(0,o.kt)("inlineCode",{parentName:"a"},"network-mux"))," library right now).  There's also\nan interesting longer ",(0,o.kt)("inlineCode",{parentName:"p"},"GHC")," project to provide performant native timeouts based\non ",(0,o.kt)("inlineCode",{parentName:"p"},"io-uring")," (Linux) and ",(0,o.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports"},(0,o.kt)("inlineCode",{parentName:"a"},"io-completion")," ports"),"\n(Windows)."),(0,o.kt)("h3",{id:"iosim"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/io-sim"},"IOSim")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim"))," package provides a pure (free) monad that has instances for type\nclasses defined in ","[",(0,o.kt)("inlineCode",{parentName:"p"},"io-classses"),"]"," and ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers")),". In particular, ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim")),"\nsupports threads (via low-level ",(0,o.kt)("inlineCode",{parentName:"p"},"forkIO")," as well as ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/async"},(0,o.kt)("inlineCode",{parentName:"a"},"async"))," package\ninterface), deadlock detection, asynchronous exceptions, software transaction\nmemory (",(0,o.kt)("inlineCode",{parentName:"p"},"STM"),"), lifting ",(0,o.kt)("inlineCode",{parentName:"p"},"ST")," computations, ",(0,o.kt)("inlineCode",{parentName:"p"},"mfix"),", and various APIs that\nsupport tracing and inspection.  "),(0,o.kt)("p",null,"There are many distinctive features of ",(0,o.kt)("inlineCode",{parentName:"p"},"io-sim"),".  It supports time domains,\nwhich means you can emulate isolated services which only communicate through\na simulation of some IPC interface.  The time is discrete and only advances\nwhen all threads are blocked: either because a thread explicitly called\n",(0,o.kt)("inlineCode",{parentName:"p"},"threadDelay"),", or the action it runs blocked one an ",(0,o.kt)("inlineCode",{parentName:"p"},"STM")," transaction.   If\na thread registered a timeout it will be unblocked at a specific time.  Because\nthe application controls time, this allows testing different interleavings\nusing the usual QuickCheck techniques.  Here we come to another distinctive\nfeature of ",(0,o.kt)("inlineCode",{parentName:"p"},"io-sim"),".  John Hughes built an interpreter, called ",(0,o.kt)("em",{parentName:"p"},"IOSimPOR"),",\nwhich dynamically detects races in a given time slot.  The ",(0,o.kt)("em",{parentName:"p"},"IOSimPOR"),"\ninterpreter is then able to execute different schedules which revert the order\nof evaluation of races and recursively discover & revert new races.  The\nimplementation follows a partial-order reduction algorithm to limit the\nschedule exploration.  ",(0,o.kt)("em",{parentName:"p"},"IOSimPOR")," is still considered an experimental feature,\nif you encounter a bug we'd really like to hear about it."),(0,o.kt)("h3",{id:"strict-stm"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/strict-stm"},"Strict-STM")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/strict-stm"},(0,o.kt)("inlineCode",{parentName:"a"},"strict-stm"))," package provides strict versions of ",(0,o.kt)("inlineCode",{parentName:"p"},"TVar"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"TMVar")," & friends.\nThe ",(0,o.kt)("inlineCode",{parentName:"p"},"StrictTVar")," also provides a way to embed invariants, which allows one to\nhook ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/nothunks"},(0,o.kt)("inlineCode",{parentName:"a"},"nothunks"))," api and verify in a testing environment that one never commit\nthunks.  ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/strict-stm"},(0,o.kt)("inlineCode",{parentName:"a"},"strict-stm"))," and ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/nothunks"},(0,o.kt)("inlineCode",{parentName:"a"},"nothunks"))," were designed after a long development\nperiod of ",(0,o.kt)("a",{parentName:"p",href:"https://www.github.com/input-output-hk/cardano-node#readme"},"Cardano")," when besides correctness and asymptotic behaviour also\nperformance started to be important.  In a relatively short time, it allowed to\nsquash many memory leaks allowing us to release the first version of the current\n",(0,o.kt)("a",{parentName:"p",href:"https://www.github.com/input-output-hk/cardano-node#readme"},"Cardano")," implementation."),(0,o.kt)("h3",{id:"strict-mvar"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/strict-mvar"},"Strict-MVar")),(0,o.kt)("p",null,"The package provides strict version of ",(0,o.kt)("inlineCode",{parentName:"p"},"MVar"),".  Like ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/strict-stm"},(0,o.kt)("inlineCode",{parentName:"a"},"strict-stm"))," it will\nsupport a way to embed invariants."),(0,o.kt)("h3",{id:"io-classes-mtl"},(0,o.kt)("a",{parentName:"h3",href:"https://hackage.haskell.org/package/io-classes-mtl"},"IO-Classes-MTL")),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes"))," contain instances only for ",(0,o.kt)("inlineCode",{parentName:"p"},"ReaderT")," monad which are\nuncontroversial.  Instances for other monad transformers are packaged in\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-mtl"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes-mtl"))," package.  These are experimental, not properly tested, and\nalso not extensively used by us at this stage.  Some of the instances are also\nnovel so please inspect the implementation to get familiar with them before you\nstart relying on them."),(0,o.kt)("p",null,"As a design principle, we tried to be compatible with the ",(0,o.kt)("inlineCode",{parentName:"p"},"exceptions")," package\nespecially when it comes to ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadThrow")," instances of monad transformers."),(0,o.kt)("p",null,"For ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadSTM")," instances we also transform the associated ",(0,o.kt)("inlineCode",{parentName:"p"},"STM")," monad, e.g. for\n",(0,o.kt)("inlineCode",{parentName:"p"},"StateT s IO")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"STM (StateT s IO)")," monad is ",(0,o.kt)("inlineCode",{parentName:"p"},"StateT s (STM IO)"),".  This means\nyou can interleave ",(0,o.kt)("inlineCode",{parentName:"p"},"StateT")," operations with ",(0,o.kt)("inlineCode",{parentName:"p"},"STM"),"."),(0,o.kt)("p",null,"We don't provide ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadAsync")," instances for transformer stacks (except of\n",(0,o.kt)("inlineCode",{parentName:"p"},"ReaderT"),").  One could follow ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/lifted-async"},(0,o.kt)("inlineCode",{parentName:"a"},"lifted-async"))," or be even more general and\nallow monoidal join of the asynchronously computed states.  However, this seems\nto extravagant and might lead to subtle concurrency bugs."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"There are many example usages of the ",(0,o.kt)("inlineCode",{parentName:"p"},"io-sim")," which can be used for\ninspiration.  Here we point to just a few which we developed as part of our\ntesting efforts."),(0,o.kt)("h3",{id:"stm-test-suite"},"STM test suite"),(0,o.kt)("p",null,"In the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim/blob/master/io-sim/test/Test/Control/Monad/STM.hs"},(0,o.kt)("inlineCode",{parentName:"a"},"Test.Control.Monad.STM"))," module we generate valid ",(0,o.kt)("inlineCode",{parentName:"p"},"STM")," terms and evaluate them in\nboth ",(0,o.kt)("inlineCode",{parentName:"p"},"IO")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim"),".  This follows the ",(0,o.kt)("a",{parentName:"p",href:"https://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf"},"Composable\nmemory transactions")," paper."),(0,o.kt)("p",null,"Terms of this mini-language are a GADT:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hs"},"data Term (t :: Type) where\n\n    Return    :: Expr t -> Term t\n    Throw     :: Expr a -> Term t\n    Catch     :: Term t -> Term t -> Term t\n    Retry     :: Term t\n\n    ReadTVar  :: Name (TyVar t) -> Term t\n    WriteTVar :: Name (TyVar t) -> Expr t -> Term TyUnit\n    NewTVar   :: Expr t -> Term (TyVar t)\n\n    -- | This is the ordinary monad bind for STM terms.\n    Bind      :: Term a -> Name a -> Term t -> Term t\n    OrElse    :: Term t -> Term t -> Term t\n\n-- | expressions which can appear in `Terms`\ndata Expr (t :: Type) where\n\n    ExprUnit ::           Expr TyUnit\n    ExprInt  :: Int    -> Expr TyInt\n    ExprName :: Name t -> Expr t\n")),(0,o.kt)("p",null,"Following the rules specified in the ",(0,o.kt)("a",{parentName:"p",href:"https://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf"},"Composable Memory\nTransactions")," paper we have:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hs"},"evalTerm :: Env -> Heap -> Allocs -> Term t -> (NfTerm t, Heap, Allocs)\n\n-- | The heap is a mapping of 'Var's to their current values.\n--\nnewtype Heap = Heap (Map VarId SomeValue)\n  deriving (Show, Semigroup, Monoid)\n\n-- | The STM semantics uses two heaps, the other one is called the allocations.\ntype Allocs = Heap\n\n-- | The normal form for a 'Term' after execution.\n--\ndata NfTerm (t :: Type) where\n\n    NfReturn :: Value t -> NfTerm t\n    NfThrow  :: Value a -> NfTerm t\n    NfRetry  ::            NfTerm t\n")),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim/blob/93858df930c160450e12f34428b61e74813b14ae/io-sim/test/Test/STM.hs#L302"},(0,o.kt)("inlineCode",{parentName:"a"},"evalTerm")),"."),(0,o.kt)("p",null,"Each term can be executed in ",(0,o.kt)("inlineCode",{parentName:"p"},"STM m")," monad:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hs"},"execTerm :: (MonadSTM m, MonadCatch (STM m))\n         => ExecEnv m\n         -> Term t\n         -> STM m (ExecValue m t)\n")),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim/blob/93858df930c160450e12f34428b61e74813b14ae/io-sim/test/Test/STM.hs#L465"},(0,o.kt)("inlineCode",{parentName:"a"},"execTerm")),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"execTerm")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"evalTerm")," all together give three ways of executing a ",(0,o.kt)("inlineCode",{parentName:"p"},"Term"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"via the spec (as implemented by ",(0,o.kt)("inlineCode",{parentName:"li"},"evalTerm"),")"),(0,o.kt)("li",{parentName:"ul"},"in ",(0,o.kt)("inlineCode",{parentName:"li"},"IO")," (using ",(0,o.kt)("inlineCode",{parentName:"li"},"stm")," package)"),(0,o.kt)("li",{parentName:"ul"},"in ",(0,o.kt)("inlineCode",{parentName:"li"},"IOSim")," (using the built-in ",(0,o.kt)("inlineCode",{parentName:"li"},"stm")," support)")),(0,o.kt)("p",null,"The last two are only possible because ",(0,o.kt)("inlineCode",{parentName:"p"},"execTerm")," is written in terms of\n",(0,o.kt)("inlineCode",{parentName:"p"},"MonadSTM m")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadCatch (STM m)")," are available from ",(0,o.kt)("inlineCode",{parentName:"p"},"io-classes"),"."),(0,o.kt)("p",null,"This gave us confidence that the most tricky operator ",(0,o.kt)("inlineCode",{parentName:"p"},"orElse")," is\nimplemented correctly."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim/blob/master/io-sim/test/Test/Control/Monad/STM.hs"},(0,o.kt)("inlineCode",{parentName:"a"},"Test.Control.Monad.STM"))," module also implements an ",(0,o.kt)("inlineCode",{parentName:"p"},"Arbitrary")," instance (with a proper\nshrinker) of ",(0,o.kt)("inlineCode",{parentName:"p"},"Terms"),"s.  The heart of it is the ",(0,o.kt)("inlineCode",{parentName:"p"},"genTerm")," function which\ngenerates arbitrary expressions of a given type."),(0,o.kt)("h3",{id:"simulated-network-interfaces"},"Simulated Network Interfaces"),(0,o.kt)("p",null,"Cardano must run on various platforms and support different communication\nbearers, e.g. it communicates via TCP/IP between nodes, but it also exposes\nan IPC using UNIX sockets.  That would be fine if we'd need to only support\n",(0,o.kt)("inlineCode",{parentName:"p"},"Linux")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"MacOS"),".  However, many end users who are running a full wallet\nare using ",(0,o.kt)("inlineCode",{parentName:"p"},"Windows")," machines, on which UNIX sockets are not well supported.\n",(0,o.kt)("inlineCode",{parentName:"p"},"Windows")," has its own ",(0,o.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/windows/win32/ipc/named-pipes"},"named pipes")," API.  Although similar, their interface is\na bit different than the familiar Berkeley socket interface.  However, it's\npossible to embrace both using the following ",(0,o.kt)("inlineCode",{parentName:"p"},"Snocket")," API:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hs"},"-- | Abstract communication interface that can be used by 'Socket' or a named pipe.\n-- Snockets are polymorphic over monad, which is useful for testing and/or\n-- simulations.\n--\ndata Snocket m fd addr = Snocket {\n    getLocalAddr  :: fd -> m addr\n  , getRemoteAddr :: fd -> m addr\n\n  , addrFamily    :: addr -> AddressFamily addr\n\n  -- | Open a file descriptor  (socket / named pipe).  For named pipes, it is\n  -- using 'CreateNamedPipe' syscall, for Berkeley sockets 'socket' is used.\n  --\n  , open          :: AddressFamily addr -> m fd\n\n    -- | A way to create 'fd' to pass to 'connect'.  For named pipes, it will\n    -- use 'CreateFile' syscall.  For Berkeley sockets it is the same as 'open'.\n    --\n    -- For named pipes, we need full 'addr' rather than just address family as\n    -- it is for sockets.\n    --\n  , openToConnect :: addr -> m fd\n\n    -- | `connect` is only needed for Berkeley sockets, for named pipes this is\n    -- no-op.\n    --\n  , connect       :: fd -> addr -> m ()\n  , bind          :: fd -> addr -> m ()\n  , listen        :: fd -> m ()\n\n  , accept        :: fd -> m (Accept m fd addr)\n\n  , close         :: fd -> m ()\n  }\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Snocket")," is parametrised by the monad in which it runs, file descriptor type,\nand address type.  The difference between Berkeley sockets and named pipes lies\nin the ",(0,o.kt)("inlineCode",{parentName:"p"},"accept")," call (which will not cover in this blog, see ",(0,o.kt)("a",{parentName:"p",href:"https://input-output-hk.github.io/ouroboros-network/ouroboros-network-framework/Ouroboros-Network-Snocket.html#t:Accept"},(0,o.kt)("inlineCode",{parentName:"a"},"Accept")),")."),(0,o.kt)("p",null,"There are four ways to construct a ",(0,o.kt)("inlineCode",{parentName:"p"},"Snocket"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs#L290"},(0,o.kt)("inlineCode",{parentName:"a"},"socketSnocket"))," - which is using the Berkeley ",(0,o.kt)("inlineCode",{parentName:"li"},"socket")," API (and thus\nsupports both ",(0,o.kt)("inlineCode",{parentName:"li"},"AF_INET"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"AF_INET6")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"AF_UNIX")," families);"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs#L378"},(0,o.kt)("inlineCode",{parentName:"a"},"localSnocket"))," - a local socket: using ",(0,o.kt)("inlineCode",{parentName:"li"},"AF_UNIX")," on systems on which\nBerkeley sockets are available or named pipes on Windows;"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Simulation/Network/Snocket.hs#L376"},(0,o.kt)("inlineCode",{parentName:"a"},"withSnocket"))," - an implementation of ",(0,o.kt)("inlineCode",{parentName:"li"},"Snocket")," dedicated for ",(0,o.kt)("inlineCode",{parentName:"li"},"IOSim"),"\nsimulations.")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Snocket")," interface allows us to parametrise the Cardano diffusion\nlayer (",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network/src/Ouroboros/Network/Diffusion/P2P.hs#L531"},(0,o.kt)("inlineCode",{parentName:"a"},"Ouroboros.Network.Diffusion.P2P.runM")),") and either\nrun in ",(0,o.kt)("inlineCode",{parentName:"p"},"IO")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"Snocket"),"s provided by the system calls and at the same time\nbuild ",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim")," simulations which run multiple Cardano diffusion layers.  The\n",(0,o.kt)("inlineCode",{parentName:"p"},"withSnocket")," API allows to embed network errors, simulating network delays, TCP\nsimultaneous open (which is not infrequent in the Cardano ecosystem).  For\nan example we test that when ",(0,o.kt)("inlineCode",{parentName:"p"},"accept")," call errors the application can recover\n(this turned out to be an issue once we discovered a bug in ",(0,o.kt)("inlineCode",{parentName:"p"},"MacOS")," kernel, see\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/pull/3388/commits/a8ba8f5224c22795f3ed9d91827ac104005e8c7d"},"ref"),").  ",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim")," allowed us to simulate the buggy behaviour of\n",(0,o.kt)("inlineCode",{parentName:"p"},"MacOS")," and verify that our solution indeed fixes the problem.  What is\noutstanding for the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network/src/Ouroboros/Network/Diffusion/P2P.hs#L531"},(0,o.kt)("inlineCode",{parentName:"a"},"Ouroboros.Network.Diffusion.P2P.runM")),"\nfunction is that its entirely described by classes from ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes"},(0,o.kt)("inlineCode",{parentName:"a"},"io-classes"))," and\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/si-timers"},(0,o.kt)("inlineCode",{parentName:"a"},"si-timers"))," packages, while it's responsible for:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"maintaining bidirectional connections with remote peers (which turned out to\nbe more complex than we initially anticipated, which involves a handful of\nstates and transitions);"),(0,o.kt)("li",{parentName:"ul"},"running multiplexed protocol applications: this includes making decisions\nlike from which peer to download a block based on real-time data and\nexecuting such a decision via one of the protocols;"),(0,o.kt)("li",{parentName:"ul"},"resolving DNS names;"),(0,o.kt)("li",{parentName:"ul"},"provide safety guarantees (e.g. if one of the protocol errors the connection\nmust be reset);"),(0,o.kt)("li",{parentName:"ul"},"keeping remote nodes honest about their timeliness obligations (i.e. enforcing\nnetwork timeouts).")),(0,o.kt)("p",null,"Since the architecture is inherently concurrent: each connection multiplexes up\nto four concurrent mini-protocols in both directions (which makes at least\n8 threads (even 16 if we count our current implementation of network protocol\npipelining), not counting some other concurrent services.  Being able to\nexecute the whole diffusion layer in a deterministic simulation environment\nwhich supports race discovery helped us to discover and fix deadlocks and rare\nbugs which otherwise would be very difficult to debug in real-system."),(0,o.kt)("h3",{id:"one-code-base-for-production--testing"},"One code base for production & testing"),(0,o.kt)("p",null,"To run the same codebase for production and testing we use one more trick.  We\nuse the ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/contra-tracer"},(0,o.kt)("inlineCode",{parentName:"a"},"contra-tracer"))," library.  The current implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Tracer")," is\nmore complex (so that it's zero cost abstraction if tracing is not used), but\nfor this blog post we can assume that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tracer")," is defined as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Tracer m a = Tracer { withTracer :: a -> m () }\n\ninstance Contravariant (Tracer m) where\n    contramap f (Tracer g) = Tracer (g . f)\n")),(0,o.kt)("p",null,"In testing, we can instantiate the tracer with something like\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceM"},(0,o.kt)("inlineCode",{parentName:"a"},"Control.Monad.IOSim.traceM")),".  With the help of\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim/blob/main/io-sim/src/Control/Monad/IOSim.hs#L174"},(0,o.kt)("inlineCode",{parentName:"a"},"Control.Monad.IOSim.selectTraceEventsDynamic"))," one\ncan recover the trace and build a quickcheck property that must be satisfied.\nIn this way ",(0,o.kt)("inlineCode",{parentName:"p"},"Tracer")," is our eye into the underlying state of the system."),(0,o.kt)("p",null,"In the production environment, a dedicated logging backend is behind the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Tracer")," abstraction."),(0,o.kt)("p",null,"The contravariant nature of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Tracer")," is very helpful.  If you are testing\nyour component you might have access to the logs it's emitting, but in the real\nimplementation the component might be embedded deep inside your stack and it's\nlogs might as well be embedded into some larger data structure or even more\nimportantly with more context.  Contravariant tracer allows you to peal the\nonion as you pass the tracer deeper into the stack, adding the extra\ninformation on the way.  Contravariant tracing allows for avoiding low-level\ncomponents to have access to high-level tracing information, and make it\npossible to decouple and isolate components even if they depend on each other."),(0,o.kt)("h2",{id:"some-iosim-features"},"Some IOSim features"),(0,o.kt)("h3",{id:"trace"},"Trace"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim"))," not only allows one to run simulations but also gives access to\ndetailed traces.  With ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSimTrace"},"Control.Monad.IOSim.runSimTrace")," function\nyou can get a trace that contains timed execution events including fork\nevents, blocking / unblocking STM events, synchronous and asynchronous\nexceptions (including blocking information of ",(0,o.kt)("inlineCode",{parentName:"p"},"throwTo"),"), forking events, delay\n& timers events.  The ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#t:SimTrace"},(0,o.kt)("inlineCode",{parentName:"a"},"SimTrace"))," can be pretty-printed with\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:ppTrace"},"Control.Monad.IOSim.ppTrace"),".  You also have control over the names\nof threads and ",(0,o.kt)("inlineCode",{parentName:"p"},"TVar"),"s.  And as we mentioned you can extract information logged\nby the code in simulation.  From the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimTrace")," you can also extract the result\ncomputed by your simulation with\n","[Control.Monad.IOSim.traceResult][traceResult]",".  These three functions are\nuseful for example to enhance test failure information (e.g. via the well known\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:counterexample"},(0,o.kt)("inlineCode",{parentName:"a"},"counterexample"))," from the ",(0,o.kt)("inlineCode",{parentName:"p"},"QuickCheck")," library)."),(0,o.kt)("p",null,"You can use ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSim"},(0,o.kt)("inlineCode",{parentName:"a"},"runSim"))," or ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSimOrThrow"},(0,o.kt)("inlineCode",{parentName:"a"},"runSimOrThrow"))," if you are not interested in the\ntrace but you just want to get the result.  Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"SimTrace")," is very\nverbose, and thus it might include too much information to analyse simple\nproblems, but it is indispensable when analysing concurrency bugs."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim"))," also allows inspecting values committed to ",(0,o.kt)("inlineCode",{parentName:"p"},"TVar"),"s in an ",(0,o.kt)("inlineCode",{parentName:"p"},"STM"),"\ntransaction.  In the early days, we relied on tracing, but that can be\nrescheduled and thus reorder events.\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSTM.html#t:MonadTraceSTM"},"Control.Monad.Class.MonadSTM.MonadTraceSTM")," provides the API.\n",(0,o.kt)("inlineCode",{parentName:"p"},"IOSim")," attaches the callbacks to its ",(0,o.kt)("inlineCode",{parentName:"p"},"TVar"),"s and executes them whenever an\n",(0,o.kt)("inlineCode",{parentName:"p"},"STM")," transaction is committed.  The callbacks allow one to either log\n",(0,o.kt)("inlineCode",{parentName:"p"},"Strings")," (the same way as the ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSay.html#v:say"},(0,o.kt)("inlineCode",{parentName:"a"},"say"))," from\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSay.html#t:MonadSay"},"Control.Monad.Class.MonadSay")," module does), or arbitrary data as\n",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceM"},(0,o.kt)("inlineCode",{parentName:"a"},"traceM"))," does."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim"},(0,o.kt)("inlineCode",{parentName:"a"},"io-sim")),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"STM")," monad allows to log values with ",(0,o.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceSTM"},(0,o.kt)("inlineCode",{parentName:"a"},"traceSTM")),".  Since this\nfunction is not polymorphic over monad, it is usage is mostly limited to\ndebugging stm transactions."),(0,o.kt)("h3",{id:"laziness"},"Laziness"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"IOSim"),"(in both flavours: ",(0,o.kt)("em",{parentName:"p"},"IOSim")," and ",(0,o.kt)("em",{parentName:"p"},"IOSimPOR"),") is executed in lazy ",(0,o.kt)("inlineCode",{parentName:"p"},"ST"),"\nmonad.  This means that the trace is created lazily.  This allows us to\nprovide a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"MonadFix")," instance, but also allows one to simulate\napplications that never exit and then only analyse a finite portion of\na trace."))}h.isMDXComponent=!0}}]);