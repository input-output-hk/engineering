"use strict";(globalThis.webpackChunkengineering_iog_io=globalThis.webpackChunkengineering_iog_io||[]).push([[6487],{274:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(8168),i=(a(6540),a(5680));const o={slug:"2022-09-28-introduce-q-d",title:"Model-Based Testing with QuickCheck",date:"October 4, 2022",authors:["arnaud"],tags:["testing quickcheck"]},r=void 0,s={permalink:"/2022-09-28-introduce-q-d",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2022-09-28-introduce-q-d.md",source:"@site/blog/2022-09-28-introduce-q-d.md",title:"Model-Based Testing with QuickCheck",description:"quickcheck-dynamic is a library jointly developed by Quviq and IOG, whose purpose is to leverage QuickCheck to test stateful programs against a Model. In other words, it's a Model-Based Testing tool. This article wants to be a gentle introduction to the use of quickcheck-dynamic for Model-Based Testing. It describes the overall approach, how the library works, and how it's being applied within IOG to improve the reach of our testing efforts.",date:"2022-10-04T00:00:00.000Z",formattedDate:"October 4, 2022",tags:[{label:"testing quickcheck",permalink:"/tags/testing-quickcheck"}],readingTime:14.105,hasTruncateMarker:!0,authors:[{name:"Arnaud Bailly",title:"Technical Architect @ IOG",email:"arnaud.bailly@iohk.io",key:"arnaud"}],frontMatter:{slug:"2022-09-28-introduce-q-d",title:"Model-Based Testing with QuickCheck",date:"October 4, 2022",authors:["arnaud"],tags:["testing quickcheck"]},prevItem:{title:"JavaScript backend merged into GHC",permalink:"/2022-12-13-ghc-js-backend-merged"},nextItem:{title:"GHCJS heap representation",permalink:"/2022-09-23-ghcjs-heap-representation"}},l={authorsImageUrls:[void 0]},p=[{value:"Background",id:"background",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Example: Thread Registry",id:"example-thread-registry",level:3},{value:"Lockstep Testing",id:"lockstep-testing",level:3},{value:"Plutus Contracts",id:"plutus-contracts",level:3},{value:"Hydra",id:"hydra",level:3},{value:"Principles",id:"principles",level:2},{value:"Defining a Model",id:"defining-a-model",level:3},{value:"Exercising Implementation",id:"exercising-implementation",level:3},{value:"Expressing Properties with Dynamic Logic",id:"expressing-properties-with-dynamic-logic",level:3},{value:"Checking Properties",id:"checking-properties",level:3},{value:"Conclusion",id:"conclusion",level:2}],c={toc:p},d="wrapper";function h({components:e,...t}){return(0,i.yg)(d,(0,n.A)({},c,t,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/quickcheck-dynamic"},"quickcheck-dynamic")," is a library jointly developed by Quviq and IOG, whose purpose is to leverage ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/QuickCheck"},"QuickCheck")," to test stateful programs against a ",(0,i.yg)("em",{parentName:"p"},"Model"),". In other words, it's a ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Model-based_testing"},(0,i.yg)("em",{parentName:"a"},"Model-Based Testing"))," tool. This article wants to be a gentle introduction to the use of quickcheck-dynamic for Model-Based Testing. It describes the overall approach, how the library works, and how it's being applied within IOG to improve the reach of our testing efforts."),(0,i.yg)("h2",{id:"background"},"Background"),(0,i.yg)("p",null,"Testing stateful or rather effectful code using QuickCheck is not new: In particular, techniques to test ",(0,i.yg)("em",{parentName:"p"},"Monadic")," code with QuickCheck have been introduced in ",(0,i.yg)("a",{parentName:"p",href:"https://dl.acm.org/doi/10.1145/636517.636527"},"Claessen & Hughes, 2002"),". ",(0,i.yg)("inlineCode",{parentName:"p"},"quickcheck-dynamic")," is based on a state-machine approach originally implemented by Quviq in closed-source ",(0,i.yg)("a",{parentName:"p",href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.148.6554&rep=rep1&type=pdf"},"Erlang version of QuickCheck")," and put to use to test various systems as explained in John Hughes' ",(0,i.yg)("a",{parentName:"p",href:"https://publications.lib.chalmers.se/records/fulltext/232550/local_232550.pdf"},"paper"),"."),(0,i.yg)("p",null,"IOG already has had experience with state-machine based testing in the Consensus ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/ouroboros-network/blob/nfrisby/old-benchmark-ledger-ops/ouroboros-consensus-test/README.md#L1"},"Storage layer")," using ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/quickcheck-state-machine"},"quickcheck-state-machine")," library, but this was not widespread practice across the various teams."),(0,i.yg)("p",null,"When IOG started working on the Plutus Smart Contracts language and application framework, Quviq's consultancy was sought after to help test the platform and build tools for future Smart Contract implementors. This effort lead to the development of a custom library for testing smart contracts based on quickcheck-dynamic's state-machine model and dynamic logic language adapted from Erlang QuickCheck."),(0,i.yg)("p",null,"As quickcheck-dynamic matured, it attracted interest from other teams willing to invest into model-based testing and reuse existing effort. This finally lead to publication of the library as an independent package on ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/quickcheck-dynamic"},"Hackage"),", independently of the Plutus framework, in the hope it will be useful to a wider audience."),(0,i.yg)("h2",{id:"use-cases"},"Use Cases"),(0,i.yg)("h3",{id:"example-thread-registry"},"Example: Thread Registry"),(0,i.yg)("p",null,"The library comes with a complete example defining a model and reference implementation for a ",(0,i.yg)("em",{parentName:"p"},"Thread Registry"),". It's inspired by a similar example in Erlang from a couple of papers:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://publications.lib.chalmers.se/records/fulltext/232552/local_232552.pdf"},"How well are your requirements tested?")),(0,i.yg)("li",{parentName:"ul"},"and ",(0,i.yg)("a",{parentName:"li",href:"https://mengwangoxf.github.io/Papers/Erlang18.pdf"},"Understanding Formal Specifications through Good Examples"))),(0,i.yg)("p",null,"The tests here use IOG's concurrent execution simulator library ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/io-sim"},"io-sim")," to speed-up testing."),(0,i.yg)("h3",{id:"lockstep-testing"},"Lockstep Testing"),(0,i.yg)("p",null,"Edsko de Vries wrote a ",(0,i.yg)("a",{parentName:"p",href:"https://well-typed.com/blog/2022/09/lockstep-with-quickcheck-dynamic/"},"nice blog post")," to compare ",(0,i.yg)("inlineCode",{parentName:"p"},"quickcheck-dynamic")," with ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/quickcheck-state-machine"},"quickcheck-state-machine"),", another library to write model-based tests on top of QuickCheck. This blog post introduces ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/well-typed/quickcheck-lockstep"},"quickcheck-lockstep")," which provides ",(0,i.yg)("em",{parentName:"p"},"lockstep-style")," testing on top of quickcheck-dynamic."),(0,i.yg)("p",null,"Lockstep-style testing is a special case of Model-Based Testing whereby what's tested at each execution step of a test sequence is the equivalence up to some observability function, of the return values expected by the ",(0,i.yg)("em",{parentName:"p"},"Model")," and the one provided by the ",(0,i.yg)("em",{parentName:"p"},"Implementation"),". In other words, if we consider each step in the state-machine as a transition that, given some input and a starting state, produces some output and possibly a new state, then lockstep-style testing checks equivalence of the ",(0,i.yg)("em",{parentName:"p"},"output traces")," from the model and the implementation."),(0,i.yg)("p",null,"The quickcheck-lockstep library provides generic implementations for most of the methods of the ",(0,i.yg)("inlineCode",{parentName:"p"},"StateModel")," typeclass and dedicated type-classes to relate the Model and the Implementation."),(0,i.yg)("h3",{id:"plutus-contracts"},"Plutus Contracts"),(0,i.yg)("p",null,"Within IOG, the quickcheck-dynamic testing approach was initially applied to provide a testing framework for Smart Contracts developers within the Plutus Application Backend. The Plutus documentation contains a ",(0,i.yg)("a",{parentName:"p",href:"https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-models.html"},"detailed tutorial")," on how to model smart contracts and tests them using underlying ",(0,i.yg)("em",{parentName:"p"},"Emulator"),"."),(0,i.yg)("p",null,"While the ",(0,i.yg)("em",{parentName:"p"},"Contract Model")," is a specialised library dedicated to Smart contracts modeling and testing, the underlying principles are similar:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Define a ",(0,i.yg)("inlineCode",{parentName:"li"},"ContractModel")," with some state and actions representing the system behaviour,"),(0,i.yg)("li",{parentName:"ul"},"Define a ",(0,i.yg)("inlineCode",{parentName:"li"},"perform"),"  function that describes how the model's actions translate to real world calls to a Contract's ",(0,i.yg)("em",{parentName:"li"},"endpoints"),","),(0,i.yg)("li",{parentName:"ul"},"then test the contracts implementation using properties written in the ",(0,i.yg)("em",{parentName:"li"},"Dynamic Logic")," language provided by the framework.")),(0,i.yg)("p",null,"On top of quickcheck-dynamic, the ",(0,i.yg)("em",{parentName:"p"},"Contract Model")," provides machinery to simplify definition of a model in the case of Plutus smart contracts and running tests against a set of _Wallets. More importantly, it predefines critical properties that all Smart Contracts should validate, like the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/plutus-apps/blob/main/plutus-contract/src/Plutus/Contract/Test/ContractModel/Internal.hs#L1719"},"No Locked Funds")," or the more subtle ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/plutus-apps/blob/main/plutus-contract/src/Plutus/Contract/Test/ContractModel/DoubleSatisfaction.hs"},"Double Satisfaction")," property. Smart contracts are somewhat infamous for being subject to subtle coding errors leading into loopholes which attackers can abuse to steal currencies from innocent users, because of the intrisic complexity of programming in a highly distributed and asynchronous model."),(0,i.yg)("p",null,"The Model-Based Testing approach supported by quickcheck-dynamic gives developers the tools to explore the state space in a much more systematic way."),(0,i.yg)("h3",{id:"hydra"},"Hydra"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://hydra.family"},"Hydra")," is a so-called ",(0,i.yg)("em",{parentName:"p"},"Layer 2")," solution for Cardano that aims at increasing the throughput and latency of Cardano transactions by moving most of the traffic out of the main chain (",(0,i.yg)("em",{parentName:"p"},"Layer 1"),") and into smaller networks. The ",(0,i.yg)("em",{parentName:"p"},"Hydra Head")," protocol is described in great details in a ",(0,i.yg)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/299.pdf"},"research paper"),"."),(0,i.yg)("p",null,"At its core, Hydra is a state machine whose transitions are Layer 1 transactions, as depicted in the following picture:"),(0,i.yg)("p",null,(0,i.yg)("img",{parentName:"p",src:"https://hydra.family/head-protocol/assets/images/hydra-head-lifecycle-b8449385e9041a214bf8c6e52830de3c.svg",alt:"Hydra State Machine"})),(0,i.yg)("p",null,"While the overall state machine appears relatively simple on the surface, the actual protocol is actually quite complex, involving cryptographic signatures and ",(0,i.yg)("em",{parentName:"p"},"Plutus Smart Contracts")," to ensure the safety of the protocol. This safety is formally expressed in the paper as ",(0,i.yg)("em",{parentName:"p"},"properties")," that are proven against an ",(0,i.yg)("em",{parentName:"p"},"Adversary Environment")," whose capabilities are well-defined."),(0,i.yg)("p",null,"In order to guarantee the implementation provides those safety properties, the Hydra team has developed a diversified palette of testing techniques, including the use of quickcheck-dynamic. While the careful Test-Driven Development approach taken gives reasonable confidence most use cases and issues are covered, hopes are high that such a model is able to explore more corner cases and reveal subtle issues in the protocol implementation."),(0,i.yg)("p",null,"What was sought after is to be able to define and test Hydra Head security properties against the real implementation. As a first example the team tackled to get a feel of how quickcheck-dynamic could used, here one of the properties from the original paper is stated:"),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},"\u2022 Conflict-Free Liveness (Head):"),(0,i.yg)("p",{parentName:"blockquote"},"In presence of a network adversary, a conflict-free execution satisfies the following condition:\nFor any transaction tx input via (new,tx), tx \u2208 T i\u2208","[n]"," Ci eventually holds.")),(0,i.yg)("p",null,"This property and similar ones are encoded as a ",(0,i.yg)("em",{parentName:"p"},"Dynamic Logic")," expressions, and a suitable Model of a Hydra network is defined as an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"StateModel")," from which test sequences representing User actions are generated."),(0,i.yg)("p",null,'Hydra is a distributed system where nodes are interconnected through a network layer, and each node needs to be connected to a cardano-node in order to preserve the security of the protocol. While testing an actual "cluster" of hydra and cardano nodes is definitely possible, and certainly desirable at some point in order to strengthen confidence in the whole system, it would also be very slow: Spinning up processes, establishing network connections, producing blocks on a chain, all take seconds if not minutes which makes any signficant exploration of the model state space practically infeasible.'),(0,i.yg)("p",null,"Generated test traces are run within the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/hydra-poc/blob/master/hydra-node/test/Hydra/ModelSpec.hs#L220"},"IOSim")," monad which allows testing 100s of traces within seconds."),(0,i.yg)("p",null,"Of course, this means we won't be using real TCP/IP networking stack nor connection to a real Cardano node and chain to create a Hydra network, but this is actually not a liability but an asset. By ",(0,i.yg)("a",{parentName:"p",href:"https://abailly.github.io/posts/mocking-good-idea.html"},"mocking")," the interfaces Hydra nodes use to communicate with other nodes and Cardano network, we are able to control the behaviour of the communication layer and ",(0,i.yg)("em",{parentName:"p"},"inject faults")," representing some ",(0,i.yg)("em",{parentName:"p"},"Adversary"),": Reordering or dropping messages, tampering the data, delaying requests..."),(0,i.yg)("h2",{id:"principles"},"Principles"),(0,i.yg)("p",null,"We'll use the latter example to illustrate quickcheck-dynamic's principles and give the reader an intuition on the four steps that need to be defined in order to use it: Defining a test ",(0,i.yg)("em",{parentName:"p"},"Model"),", stating how the model relates to the ",(0,i.yg)("em",{parentName:"p"},"Implementation"),", expressing ",(0,i.yg)("em",{parentName:"p"},"Properties")," and, last but not least, checking properties."),(0,i.yg)("h3",{id:"defining-a-model"},"Defining a Model"),(0,i.yg)("p",null,"In quickcheck-dynamic, a ",(0,i.yg)("em",{parentName:"p"},"Model")," is some type, a representation of the expected state of the system-under-test, for which there exists an instance of the ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/quickcheck-dynamic/blob/abailly-iohk/blog-post/quickcheck-dynamic/src/Test/QuickCheck/StateModel.hs#L56"},"StateModel class")," which sets the building blocks needed to generate and validate test sequences."),(0,i.yg)("p",null,"In the case of Hydra, the Model is a ",(0,i.yg)("inlineCode",{parentName:"p"},"IdealWorld")," data type that control the Head parties and maintains a ",(0,i.yg)("inlineCode",{parentName:"p"},"GlobalState")," which reflects the expected Head state:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"data IdealWorld = IdealWorld\n  { hydraParties :: [(SigningKey HydraKey, CardanoSigningKey)]\n  , hydraState :: GlobalState\n  }\n")),(0,i.yg)("p",null,"We won't bother the reader with details of the ",(0,i.yg)("inlineCode",{parentName:"p"},"GlobalState")," which basically encode the states as depicted in the state-machine picture hereabove in the form of an Algebraic Data-Type."),(0,i.yg)("p",null,'As the old saying from Alfred Korzybski goes, "The map is not the territory", hence to be useful a ',(0,i.yg)("em",{parentName:"p"},"Model")," should abstract away irrelevant details for the purpose of testing. Furthermore, it's perfectly fine to use different models to test different aspects of the same implementation."),(0,i.yg)("p",null,"While the real Hydra layer two ledger does support a myriad of possible Cardano transactions, our model at hand is simpler and only uses ",(0,i.yg)("em",{parentName:"p"},"Two Party Payment")," transactions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"data Payment = Payment\n  { from :: CardanoSigningKey\n  , to :: CardanoSigningKey\n  , value :: Value\n  }\n")),(0,i.yg)("p",null,"The first important part of the ",(0,i.yg)("inlineCode",{parentName:"p"},"StateModel")," instance to define is the type of ",(0,i.yg)("inlineCode",{parentName:"p"},"Action")," that are meaningful for the given ",(0,i.yg)("em",{parentName:"p"},"Model")," and that can also be executed against the concrete implementation. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Action")," associated data-type is a GADT which allows the model to represent the type of ",(0,i.yg)("em",{parentName:"p"},"observable output")," that can be produced by the implementation and which can be part of the model's validation logic."),(0,i.yg)("p",null,"The Hydra model needs to represent both on-chain and off-chain actions as the properties required from Hydra relates the two. The ",(0,i.yg)("inlineCode",{parentName:"p"},"Action")," data-type represent user-facing commands and observations that can be made on the state of the system (please note at the time of writing this, the model is incomplete):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"  data Action IdealWorld a where\n    Seed :: {seedKeys :: [(SigningKey HydraKey, CardanoSigningKey)]} -> Action IdealWorld ()\n    Init :: Party -> ContestationPeriod -> Action IdealWorld ()\n    Commit :: Party -> UTxOType Payment -> Action IdealWorld ActualCommitted\n    Abort :: Party -> Action IdealWorld ()\n    NewTx :: Party -> Payment -> Action IdealWorld ()\n    Wait :: DiffTime -> Action IdealWorld ()\n    ObserveConfirmedTx :: Payment -> Action IdealWorld ()\n")),(0,i.yg)("p",null,"Then one needs to define:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"An ",(0,i.yg)("inlineCode",{parentName:"li"},"initialState"),","),(0,i.yg)("li",{parentName:"ul"},"How to generate ",(0,i.yg)("inlineCode",{parentName:"li"},"arbitraryAction"),"s which will be used to produce sequences (or traces) of ",(0,i.yg)("inlineCode",{parentName:"li"},"Action"),"s to execute, depending on the current state,"),(0,i.yg)("li",{parentName:"ul"},"A ",(0,i.yg)("inlineCode",{parentName:"li"},"precondition")," function ensuring some ",(0,i.yg)("inlineCode",{parentName:"li"},"Action")," is valid in some state. This function may seem redundant with the generator but is actually important when ",(0,i.yg)("em",{parentName:"li"},"shrinking")," a failing test sequences: The execution engine will ensure the reduced sequence is still valid with respect to the model,"),(0,i.yg)("li",{parentName:"ul"},"A ",(0,i.yg)("inlineCode",{parentName:"li"},"nextState")," (transition) function that evolves the model state according to the ",(0,i.yg)("inlineCode",{parentName:"li"},"Action"),"s,"),(0,i.yg)("li",{parentName:"ul"},"Auxiliary function ",(0,i.yg)("inlineCode",{parentName:"li"},"actionName")," to providea  human-readable representation of actions.")),(0,i.yg)("p",null,"The reader is invited to check the ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/quickcheck-dynamic-1.1.0/docs/Test-QuickCheck-StateModel.html"},"Haddock")," documentation of the library for further details."),(0,i.yg)("h3",{id:"exercising-implementation"},"Exercising Implementation"),(0,i.yg)("p",null,"A ",(0,i.yg)("em",{parentName:"p"},"Model")," alone is somewhat useless if we don't provide a way to relate it to the actual implementation of the system-under-test. ",(0,i.yg)("inlineCode",{parentName:"p"},"quickcheck-dynamic")," provides the ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.haskell.org/package/quickcheck-dynamic-1.1.0/docs/Test-QuickCheck-StateModel.html#t:RunModel"},(0,i.yg)("inlineCode",{parentName:"a"},"RunModel"))," typeclass for this purpose. The most important function to define is ",(0,i.yg)("inlineCode",{parentName:"p"},"perform")," which defines how ",(0,i.yg)("inlineCode",{parentName:"p"},"StateModel"),"'s ",(0,i.yg)("inlineCode",{parentName:"p"},"Action")," should be executed against the implementation within some monadic context ",(0,i.yg)("inlineCode",{parentName:"p"},"m"),". Having the actual execution ",(0,i.yg)("inlineCode",{parentName:"p"},"Monad m")," be a parameter of the ",(0,i.yg)("inlineCode",{parentName:"p"},"RunModel")," gives more flexibility to the implementor which is not tied to ",(0,i.yg)("inlineCode",{parentName:"p"},"IO")," for example."),(0,i.yg)("p",null,"In the case of Hydra, the ",(0,i.yg)("inlineCode",{parentName:"p"},"perform")," function is defined as:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"  perform ::\n    IdealWorld ->\n    Action IdealWorld a ->\n    LookUp (StateT (Nodes m) m ->\n    StateT (Nodes m) m a\n  perform st command _ = do\n    case command of\n      Seed{seedKeys} ->\n        seedWorld seedKeys\n      Commit party utxo ->\n        performCommit (snd <$> hydraParties st) party utxo\n...\n")),(0,i.yg)("p",null,"The actual monad used is a classical ",(0,i.yg)("inlineCode",{parentName:"p"},"State")," monad whose state maps a ",(0,i.yg)("inlineCode",{parentName:"p"},"Party")," to the corresponding client connection to the Hydra node:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"data Nodes m = Nodes\n  { nodes :: Map.Map Party (TestHydraNode Tx m)\n  , logger :: Tracer m (HydraNodeLog Tx)\n  }\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"m")," parameter is here kept somewhat unconstrained in order to make it possible to run properties within the ",(0,i.yg)("inlineCode",{parentName:"p"},"IOSim")," monad for faster tests execution. Also note the presence of the ",(0,i.yg)("inlineCode",{parentName:"p"},"logger")," field which is used to capture logging output from all the nodes: Should an error happen or a postcondition fail, we can dump the log of each node which is invaluable to troubleshoot such failures. In general, testing systems in a black-box way emphasises the importance of good logging to provide as much context as possible should issues arise, and using quickcheck-dynamic makes no exception."),(0,i.yg)("h3",{id:"expressing-properties-with-dynamic-logic"},"Expressing Properties with Dynamic Logic"),(0,i.yg)("p",null,"Once we have a ",(0,i.yg)("inlineCode",{parentName:"p"},"StateModel")," we can express interesting ",(0,i.yg)("em",{parentName:"p"},"properties")," to check against our ",(0,i.yg)("inlineCode",{parentName:"p"},"RunModel"),". ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/input-output-hk/quickcheck-dynamic/blob/abailly-iohk/link-to-blog-post/quickcheck-dynamic/src/Test/QuickCheck/DynamicLogic.hs"},"Dynamic Logic")," allows one to express properties through monadic expressions relating actions, states and logic predicates."),(0,i.yg)("p",null,"Dynamic Logic is a form of ",(0,i.yg)("em",{parentName:"p"},"modal logic"),", similar to ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Temporal_logic"},"temporal logic"),", but whose modalities are the ",(0,i.yg)("em",{parentName:"p"},"actions")," (or programs) themselves. One can intertwine ",(0,i.yg)("em",{parentName:"p"},"programs")," and logic predicates to specify the behaviour of the former when executing some statements and actually ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Dynamic_logic_(modal_logic)"},"Dynamic Logic")," evolved from ",(0,i.yg)("em",{parentName:"p"},"Hoare's Triples"),"."),(0,i.yg)("p",null,"Here is the dynamic logic reformulation of the previously stated Hydra property which has been kept as close as possible to the original English statement:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"conflictFreeLiveness :: DL IdealWorld ()\nconflictFreeLiveness = do\n  anyActions_\n  getModelStateDL >>= \\case\n    st@IdealWorld{hydraState = Open{}} -> do\n      (party, payment) <- forAllQ (nonConflictingTx st)\n      action $ Model.NewTx party payment\n      eventually (ObserveConfirmedTx payment)\n    _ -> pass\n where\n  nonConflictingTx st = withGenQ (genPayment st) (const [])\n  eventually a = action (Wait 10) >> action a\n")),(0,i.yg)("p",null,'Note that in order to define this property we have introduced two "pseudo-actions" in the ',(0,i.yg)("em",{parentName:"p"},"Model"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"Wait")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ObserveConfirmedTx"),": Those ",(0,i.yg)("inlineCode",{parentName:"p"},"Action"),"s have no effect on the model itself, the former being used to introduce some delay in the context of distributed and asynchronous execution, and the latter serving the purpose of ",(0,i.yg)("em",{parentName:"p"},"observing")," the current state of the SUT. An alternative formulation would have been to make ",(0,i.yg)("inlineCode",{parentName:"p"},"ObserveConfirmedTx")," return the set of confirmed transactions and then express the condition as a logic predicate within the ",(0,i.yg)("inlineCode",{parentName:"p"},"conflictFreeLiveness")," property's body."),(0,i.yg)("h3",{id:"checking-properties"},"Checking Properties"),(0,i.yg)("p",null,"The last step in putting quickcheck-dynamic at work is to be able to connect the ",(0,i.yg)("em",{parentName:"p"},"StateModel"),", the ",(0,i.yg)("em",{parentName:"p"},"RunModel"),", and the ",(0,i.yg)("em",{parentName:"p"},"DynamicLogic")," expression and turn those into a QuickCheck ",(0,i.yg)("inlineCode",{parentName:"p"},"Property")," which can then be checked using the standard testing framework."),(0,i.yg)("p",null,"quickcheck-dynamic provides 2 functions for that purpose. The ",(0,i.yg)("inlineCode",{parentName:"p"},"forAllDL_")," function (actually more a family of functions) will leverage ",(0,i.yg)("inlineCode",{parentName:"p"},"DL")," formulae to generate sequences of ",(0,i.yg)("inlineCode",{parentName:"p"},"Action"),"s:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"prop_checkConflictFreeLiveness :: Property\nprop_checkConflictFreeLiveness =\n  forAllDL_ conflictFreeLiveness prop_HydraModel\n")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"runActions")," function will execute the generated trace against the ",(0,i.yg)("inlineCode",{parentName:"p"},"RunModel"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-haskell"},"prop_HydraModel :: Actions IdealWorld -> Property\nprop_HydraModel actions = property $\n  runIOSimProp $ do\n    _ <- runActions runIt actions\n    assert True\n")),(0,i.yg)("p",null,"In this particular instance from Hydra, we need some additional machinery (the ",(0,i.yg)("inlineCode",{parentName:"p"},"runIOSimProp")," function) to handle the execution of some monadic ",(0,i.yg)("inlineCode",{parentName:"p"},"PropertyM")," into ",(0,i.yg)("inlineCode",{parentName:"p"},"IOSim")," monad, turning it into a ",(0,i.yg)("inlineCode",{parentName:"p"},"Property"),"."),(0,i.yg)("p",null,"When run and successful, this ",(0,i.yg)("inlineCode",{parentName:"p"},"Property")," generates the following output:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"  check conflict-free liveness\n    +++ OK, passed 100 tests.\n\n    Actions (1334 in total):\n    49.93% NewTx\n    25.86% Commit\n     7.50% Seed\n     7.42% Init\n     4.80% Abort\n     2.25% ObserveConfirmedTx\n     2.25% Wait\n\n    Transitions (1334 in total):\n    54.42% Open -> Open\n    23.61% Initial -> Initial\n     7.50% Start -> Idle\n     7.42% Idle -> Initial\n     4.80% Initial -> Final\n     2.25% Initial -> Open\n")),(0,i.yg)("p",null,"By default, ",(0,i.yg)("inlineCode",{parentName:"p"},"runActions")," decorate the QuickCheck output ",(0,i.yg)("em",{parentName:"p"},"tabulating")," the executed ",(0,i.yg)("inlineCode",{parentName:"p"},"Action"),". And thanks to the ",(0,i.yg)("inlineCode",{parentName:"p"},"monitoring")," helper provided by the ",(0,i.yg)("inlineCode",{parentName:"p"},"RunModel"),", this example also tabulates the executed ",(0,i.yg)("em",{parentName:"p"},"transitions")," between each of the possible values for ",(0,i.yg)("inlineCode",{parentName:"p"},"GlobalState"),'. These pieces of information are important to assess the "quality" of the model: We want to make sure its generators and the properties execution covers all interesting parts of the Model, hence exercise all relevant parts of the implementation. Please note that, as we mentioned before, the Hydra model is still a work in progress hence the reason why there\'s no ',(0,i.yg)("inlineCode",{parentName:"p"},"Open -> Final")," transition!"),(0,i.yg)("h2",{id:"conclusion"},"Conclusion"),(0,i.yg)("p",null,"This articled introduced ",(0,i.yg)("a",{parentName:"p",href:"https://hackage.org/packages/quickcheck-dynamic"},"quickcheck-dynamic"),", a novel Model-Based Testing library initially developed by Quviq for testing Plutus Smart Contracts and which has recently been open-sourced by IOG. I have tried to convey to the user a sense of the ",(0,i.yg)("em",{parentName:"p"},"Whys"),", ",(0,i.yg)("em",{parentName:"p"},"Whats")," and ",(0,i.yg)("em",{parentName:"p"},"Hows")," questions this library answers through various examples and a high-level walkthrough of the steps needed to use this library for testing an implementation."),(0,i.yg)("p",null,(0,i.yg)("em",{parentName:"p"},"Model-Based Testing")," is a powerful tool that simultaneously addresses both aspects of ",(0,i.yg)("a",{parentName:"p",href:"http://www.exampler.com/old-blog/2003/09/05.1.html#agile-testing-project-4"},"Customer-facing tests")," as Brian Marick puts it in his famous ",(0,i.yg)("em",{parentName:"p"},"Agile Testing Quadrant")," popularised by Lisa Crispin and Janet Gregory through their ",(0,i.yg)("a",{parentName:"p",href:"https://agiletester.ca/wp-content/uploads/sites/26/2015/07/Agile-tips-final.pdf"},"Agile Testing")," books: ",(0,i.yg)("em",{parentName:"p"},"Supporting the team")," by providing a reference model to build against, and ",(0,i.yg)("em",{parentName:"p"},"Critiquing the product")," through the unique state-space exploration QuickCheck provides, possibly uncovering corner cases and blind spots in either the specification or the implementation."),(0,i.yg)("p",null,"The library is still evolving towards better developer experience and flexibility but it's already in a state that makes it possible to test something as significant as a Hydra network. And while it may appear somewhat involved when compared to more traditional forms of writing ",(0,i.yg)("em",{parentName:"p"},"Functional tests"),", I hope I have demonstrated quickcheck-dynamic lowers the barrier to entry associated with most MBT tools."))}h.isMDXComponent=!0},5680:(e,t,a)=>{a.d(t,{xA:()=>c,yg:()=>u});var n=a(6540);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach(function(t){i(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef(function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(a),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||o;return a?n.createElement(u,r(r({ref:t},c),{},{components:a})):n.createElement(u,r({ref:t},c))});function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);