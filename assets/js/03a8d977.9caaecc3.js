"use strict";(self.webpackChunkengineering_iog_io=self.webpackChunkengineering_iog_io||[]).push([[1151],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=p(t),u=r,m=h["".concat(s,".").concat(u)]||h[u]||c[u]||o;return t?a.createElement(m,i(i({ref:n},d),{},{components:t})):a.createElement(m,i({ref:n},d))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4554:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return d},toc:function(){return c},default:function(){return u}});var a=t(7462),r=t(3366),o=(t(7294),t(3905)),i=["components"],l={slug:"2023-10-25-internship",title:"Internship in GHC at IOG",authors:["bartek"],tags:["ghc","internship"]},s="Internship in GHC at IOG",p={permalink:"/2023-10-25-internship",editUrl:"https://github.com/input-output-hk/engineering/tree/master/blog/2023-10-25-internship.md",source:"@site/blog/2023-10-25-internship.md",title:"Internship in GHC at IOG",description:"My name is Bart\u0142omiej Cie\u015blar, and I have done a 5-month long",date:"2023-10-25T00:00:00.000Z",formattedDate:"October 25, 2023",tags:[{label:"ghc",permalink:"/tags/ghc"},{label:"internship",permalink:"/tags/internship"}],readingTime:8.855,truncated:!1,authors:[{name:"Bart\u0142omiej Cie\u015blar",title:"Haskell DevX Intern @ IOG",email:"bartlomiej.cieslar@iohk.io",key:"bartek"}],frontMatter:{slug:"2023-10-25-internship",title:"Internship in GHC at IOG",authors:["bartek"],tags:["ghc","internship"]},nextItem:{title:"IOG GHC Update #18",permalink:"/2023-10-05-ghc-update"}},d={authorsImageUrls:[void 0]},c=[{value:"Deprecating Exports",id:"deprecating-exports",children:[],level:2},{value:"Deprecating Instances",id:"deprecating-instances",children:[],level:2},{value:"Incomplete Record Selectors",id:"incomplete-record-selectors",children:[],level:2},{value:"Other minor contributions",id:"other-minor-contributions",children:[{value:"Broken deprecations for record fields",id:"broken-deprecations-for-record-fields",children:[],level:3},{value:"Custom deprecations in record wild card syntax",id:"custom-deprecations-in-record-wild-card-syntax",children:[],level:3}],level:2}],h={toc:c};function u(e){var n=e.components,t=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"My name is Bart\u0142omiej Cie\u015blar, and I have done a 5-month long\ninternship at IOG. Throughout the internship my work was focused on improving\nthe Glasgow Haskell Compiler. In this post I share a bit about the work that I\ndid and the new features that are available in GHC 9.8 and GHC 9.10 as a result."),(0,o.kt)("h2",{id:"deprecating-exports"},"Deprecating Exports"),(0,o.kt)("p",null,"Originally in GHC, the only way to deprecate usages of certain things was to\ndeprecate their definitions, as in the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'foo :: Int -> Int\nfoo x = x * x\n\n{-# DEPRECATED foo "Do not use" #-}\n')),(0,o.kt)("p",null,"However, consider the following (real) issue: there are several functions in\nthe module ",(0,o.kt)("inlineCode",{parentName:"p"},"Data.List")," (",(0,o.kt)("inlineCode",{parentName:"p"},"lines"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"words"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"unlines")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"unwords"),") that have\nbeen moved to ",(0,o.kt)("inlineCode",{parentName:"p"},"Data.String"),"; however, their exports cannot be removed from\n",(0,o.kt)("inlineCode",{parentName:"p"},"base"),", since in doing so it would immediately break any code using those\nfunctions through ",(0,o.kt)("inlineCode",{parentName:"p"},"Data.List")," without any heads-up. This is where the new\ndeprecated warnings come in."),(0,o.kt)("p",null,"Under the new syntax (available from GHC 9.8), it is possible to write deprecation and warning annotations next to the export definitions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'module Data.List where\n       ( {-# DEPRECATED "Moved to Data.String" #-} lines\n       , {-# WARNING "Will be removed in the next release!" #-} SomeType(..) )\nimport Data.String (lines)\nimport Types (SomeType(..))\n')),(0,o.kt)("p",null,"There are two corner cases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"an identifier imported from several modules leading to inconsistent annotations in the importing module"),(0,o.kt)("li",{parentName:"ul"},"an identifier exported more than once with inconsistent annotations in the exporting module")),(0,o.kt)("p",null,"The first case is illustrated with the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'module Good where\nfoo :: Int\nfoo = 10\n----------------------\nmodule Wrong\n  ( {-# DEPRECATED "Moved to Good" #-} foo\n  )\nwhere\nimport Good\n----------------------\nmodule Test where\n\nimport Wrong (foo) -- warning here since explicitly mentioned in Wrong\'s import list\nimport Good\n\nbar = foo       -- no warning here since imported without deprecation from Good\nbaz = Wrong.foo -- warning here since the import is qualified with Wrong\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"foo")," is imported from both ",(0,o.kt)("inlineCode",{parentName:"p"},"Good")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Wrong")," modules but it is deprecated only in ",(0,o.kt)("inlineCode",{parentName:"p"},"Wrong"),"'s export list.\nWarnings are emitted every time the identifier is explicitly used from ",(0,o.kt)("inlineCode",{parentName:"p"},"Wrong"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"in ",(0,o.kt)("inlineCode",{parentName:"li"},"Wrong"),"'s import list"),(0,o.kt)("li",{parentName:"ul"},"when an occurrence is qualified with ",(0,o.kt)("inlineCode",{parentName:"li"},"Wrong"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'> ghc-9.8 Test.hs\n\nTest.hs:3:15: warning: [GHC-68441] [-Wdeprecations]\n    In the use of \u2018foo\u2019 (imported from Wrong):\n    Deprecated: "Moved to Good"\n  |\n3 | import Wrong (foo)\n  |               ^^^\n\nTest.hs:7:7: warning: [GHC-68441] [-Wdeprecations]\n    In the use of \u2018foo\u2019 (imported from Wrong):\n    Deprecated: "Moved to Good"\n  |\n7 | baz = Wrong.foo\n  | \n')),(0,o.kt)("p",null,"The second case is illustrated with the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'module Both\n  ( {-# DEPRECATED "Moved to Good" #-} foo\n  , foo\n  )\nwhere\nimport Good (foo)\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"foo")," identifier is exported twice with inconsistent annotions in module ",(0,o.kt)("inlineCode",{parentName:"p"},"Both"),": both with and without a deprecation annotation.\nA module importing ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," from ",(0,o.kt)("inlineCode",{parentName:"p"},"Both")," won't raise a deprecation warning (there is a non-deprecated export after all).\nTo help avoiding this situation, a new compiler flag ",(0,o.kt)("inlineCode",{parentName:"p"},"-Wincomplete-export-warnings")," can be enabled (it is included in ",(0,o.kt)("inlineCode",{parentName:"p"},"-Wall"),")\nto make the compiler warn about such inconsistent annotations in the defining module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'> ghc-9.8 Both.hs -Wall\n\nBoth.hs:2:5: warning: [GHC-94721] [-Wincomplete-export-warnings]\n    \u2018foo\u2019 will not have its export warned about\n    missing export warning at Both.hs:3:5-7\n  |\n2 |   ( {-# DEPRECATED "Moved to R" #-} foo\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nBoth.hs:3:5: warning: [GHC-47854] [-Wduplicate-exports]\n    \u2018foo\u2019 is exported by \u2018foo\u2019 and \u2018{-# DEPRECATED "Moved to R" #-}\n                                    foo\u2019\n  |\n3 |   , foo\n  |     ^^^\n')),(0,o.kt)("p",null,"References:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0134-deprecating-exports-proposal.rst"},"GHC proposal #134")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/4879"},"GHC issue #4879")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/10283"},"GHC merge request !10283"))),(0,o.kt)("p",null,"Note: The WARNING pragma behaves exactly like the DEPRECATED pragma.\nIn previous examples and in the rest of this post we always use the\nDEPRECATED pragma but the WARNING pragma could have been used too."),(0,o.kt)("h2",{id:"deprecating-instances"},"Deprecating Instances"),(0,o.kt)("p",null,"Similar to exports, there was previously no way to deprecate single instances\nof type classes. For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"NFData")," class is responsible for implementing\ndeep strictness on types and there is an instance of it for functions\nwhich does not make much sense and is pretty inefficient:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"instance (Enumerate a, NFData b) => NFData (a -> b)\n")),(0,o.kt)("p",null,"However, it cannot be removed since this would suddenly break all code using this instance,\nnot giving the library users time to update their code."),(0,o.kt)("p",null,"From GHC 9.10, there will be a way to do add deprecation pragmas to instances:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'instance {-# DEPRECATED "Do not use" #-} (Enumerate a, NFData b) => NFData (a -> b)\n')),(0,o.kt)("p",null,"which will emit a warning every time a type class constraint is solved to this\ninstance. It is also possible to add warnings to derived instances, although\nthey have to be derived with standalone ",(0,o.kt)("inlineCode",{parentName:"p"},"deriving")," declarations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'deriving instance {-# DEPRECATED "Will be removed soon" #-} Show T\n')),(0,o.kt)("p",null,"References:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0575-deprecated-instances.rst"},"GHC proposal #575")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/17485"},"GHC issue #17485")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/10902"},"GHC merge request !10902"))),(0,o.kt)("h2",{id:"incomplete-record-selectors"},"Incomplete Record Selectors"),(0,o.kt)("p",null,"In haskell, one can name the fields of a data type constructor, in which case\nthat constructor is called a record:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"data T = T1 { fieldX :: Int } | T2 Bool | T3 { fieldX :: Int, fieldY :: Char }\n")),(0,o.kt)("p",null,"In order to access the fields of a record, one can pattern match on it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"foo1 :: T -> Int\nfoo1 (T1 {fieldX = val}) = val\nfoo1 _                   = 0\n")),(0,o.kt)("p",null,"or use a record selector function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"foo2 :: T -> Int\nfoo2 t = fieldX t + 2\n")),(0,o.kt)("p",null,"The issue is that a record selector is not defined for the constructors\nwhich do not have that field. Such record selectors are called incomplete.\nIn our example, ",(0,o.kt)("inlineCode",{parentName:"p"},"fieldX")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"fieldY")," are incomplete record selectors.\nAs a consequence, calling ",(0,o.kt)("inlineCode",{parentName:"p"},"foo2")," on a value constructed with constructor ",(0,o.kt)("inlineCode",{parentName:"p"},"T2"),"\nwould fail at runtime with an exception becaues ",(0,o.kt)("inlineCode",{parentName:"p"},"T2")," doesn't have a ",(0,o.kt)("inlineCode",{parentName:"p"},"fieldX")," field. "),(0,o.kt)("p",null,"There is already a warning ",(0,o.kt)("inlineCode",{parentName:"p"},"-Wpartial-fields")," that warns about such record fields at the ",(0,o.kt)("strong",{parentName:"p"},"definition site"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"> ghc T.hs -Wpartial-fields\n[1 of 1] Compiling T                ( T.hs, T.o )\n\nT.hs:3:15: warning: [GHC-82712] [-Wpartial-fields]\n    Use of partial record field selector: \u2018fieldX\u2019\n  |\n3 | data T = T1 { fieldX :: Int } | T2 Bool | T3 { fieldX :: Int, fieldY :: Char }\n  |               ^^^^^^\n\nT.hs:3:63: warning: [GHC-82712] [-Wpartial-fields]\n    Use of partial record field selector: \u2018fieldY\u2019\n  |\n3 | data T = T1 { fieldX :: Int } | T2 Bool | T3 { fieldX :: Int, fieldY :: Char }\n  |                                                               ^^^^^^\n")),(0,o.kt)("p",null,"Note: the message ",(0,o.kt)("inlineCode",{parentName:"p"},"Use of partial record field selector: ...")," should better be reworded as ",(0,o.kt)("inlineCode",{parentName:"p"},"Definition of partial record field selector: ..."),"."),(0,o.kt)("p",null,"However:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"it is only a warning because incomplete record selectors are sometimes desirable."),(0,o.kt)("li",{parentName:"ol"},"it is only visible when compiling a module defining partial record field selectors, not when a partial record field selector field is used in some client module.")),(0,o.kt)("p",null,"Therefore, I've implemented a new ",(0,o.kt)("inlineCode",{parentName:"p"},"-Wincomplete-record-selectors")," warning (available from GHC 9.10)\nthat warns about ",(0,o.kt)("strong",{parentName:"p"},"occurrences")," of incomplete record selectors that ",(0,o.kt)("strong",{parentName:"p"},"can't be proved not to fail"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"foo3 :: T -> Int\nfoo3 (T1 {fieldX = x}) = x\nfoo3 t                 = fieldX t -- warning emitted here\n\nfoo4 :: T -> Int\nfoo4 (T2 _) = 0\nfoo4 t      = fieldX t -- warning not emitted here, since T2 is handled by the previous equation\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"> ghc-9.10 Test.hs -Wincomplete-record-selectors\nTest.hs:7:26: warning: [GHC-17335] [-Wincomplete-record-selectors]\n    The application of the record field \u2018fieldX\u2019 may fail for the following constructors: T2\n  |\n7 | foo3 t                 = fieldX t -- warning emitted here\n  |  \n")),(0,o.kt)("p",null,"This also works with GADTs for which we need to take types into account to know which constructors\nare allowed to occur. In the following example, it doesn't make sense to warn in ",(0,o.kt)("inlineCode",{parentName:"p"},"bar2")," about handling\nthe case where ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," is constructed with ",(0,o.kt)("inlineCode",{parentName:"p"},"G2")," because ",(0,o.kt)("inlineCode",{parentName:"p"},"g"),"'s type prevents it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"data G a where\n    G1 :: {fieldZ :: Int, fieldC1 :: Char} -> G a\n    G2 :: {fieldC2 :: Char} -> G Int\n\nbar1 :: G a -> Int\nbar1 g = fieldZ g -- warning emitted here\n\nbar2 :: G Char -> Int\nbar2 g = fieldZ g -- warning not emitted here, since G2 cannot occur\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"> ghc-9.10 Test.hs -Wincomplete-record-selectors\n\nTest.hs:8:10: warning: [GHC-17335] [-Wincomplete-record-selectors]\n    The application of the record field \u2018fieldZ\u2019 may fail for the following constructors: G2\n  |\n8 | bar1 g = fieldZ g -- warning emitted here\n  |  \n")),(0,o.kt)("p",null,"References:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0516-incomplete-record-selectors.rst"},"GHC proposal #516")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/18650"},"GHC issue #18650")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/10736"},"GHC merge request !10736"))),(0,o.kt)("h2",{id:"other-minor-contributions"},"Other minor contributions"),(0,o.kt)("p",null,"For the purpose of this part, let us assume that module ",(0,o.kt)("inlineCode",{parentName:"p"},"Mod")," has the following definition:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'module Mod where\ndata X = X {x :: Int, y :: Char}\n{-# DEPRECATED x "Will be removed soon" #-}\n')),(0,o.kt)("h3",{id:"broken-deprecations-for-record-fields"},"Broken deprecations for record fields"),(0,o.kt)("p",null,"Since GHC 9.4, deprecation warnings attached to record fields were not emitted when record fields\nwere accessed via record selectors, the usage of ",(0,o.kt)("inlineCode",{parentName:"p"},"HasField"),", or with the overloaded record dot syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},'module Mod2 where\nimport Mod\nimport GHC.Records\nfoo :: X -> Int\nfoo = x -- no warning emitted here (record selector)\n\nbar1 :: HasField "x" t Int => t -> Int\nbar1 t = getField @"x" t\n\nbar2 :: X -> Int\nbar2 = bar1 -- no warning emitted here (HasField constraint)\n\nbaz :: X -> Int\nbaz t = t.x -- no warning emitted here (record dot syntax)\n')),(0,o.kt)("p",null,"I can happily say that with the help of Sam Derbyshire and Simon Peyton-Jones\nthe bug was fixed and this feature will work again fully in GHC 9.8."),(0,o.kt)("p",null,"References:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/23279"},"GHC issue #23279")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/10991"},"GHC merge request !10991"))),(0,o.kt)("h3",{id:"custom-deprecations-in-record-wild-card-syntax"},"Custom deprecations in record wild card syntax"),(0,o.kt)("p",null,"In GHC, one can pattern match on all fields of a record using the record wild\ncard syntax, which will assign the value of the all remaining record fields to\nthe variables with the same name:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"import Mod\nfoo :: X -> Char\nfoo (X {..}) = y\n")),(0,o.kt)("p",null,"however, when using this syntax, custom deprecations of record fields won't be\nemitted even if those fields are deprecated:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"bar :: X -> Int\nbar (X {..}) = x -- no warning\n")),(0,o.kt)("p",null,"this was because if there were a lot of fields deprecated in the pattern match,\nthe warnings would have been noisy. However, since GHC 9.10 it will be changed\nso that the custom warnings for record fields will be emitted only if the\nvariables to which their values are assinged to are used in the body of the\nfunction."),(0,o.kt)("p",null,"References:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/issues/23382"},"GHC issue #23382")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://gitlab.haskell.org/ghc/ghc/-/merge_requests/11043"},"GHC merge request !11043"))))}u.isMDXComponent=!0}}]);