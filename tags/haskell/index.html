<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="IOG Engineering RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="IOG Engineering Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="IOG Engineering JSON Feed"><title data-react-helmet="true">One post tagged with &quot;haskell&quot; | IOG Engineering</title><meta data-react-helmet="true" property="og:title" content="One post tagged with &quot;haskell&quot; | IOG Engineering"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://engineering.iog.io/tags/haskell"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_tags_posts"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://engineering.iog.io/tags/haskell"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/tags/haskell" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/tags/haskell" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.10ad4647.css">
<link rel="preload" href="/assets/js/runtime~main.622cf124.js" as="script">
<link rel="preload" href="/assets/js/main.c479010e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Recent</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/tags">Tags</a><a class="navbar__item navbar__link" href="/archive">Archive</a></div><div class="navbar__items navbar__items--right"><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-tags-post-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-05-18-ghc-update">IOG GHC Update #10</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-05-04-ghc-update">IOG GHC Update #9</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-04-21-stacks-in-the-js-backend">Stacks in the JavaScript Backend</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-04-20-ghc-update">IOG GHC Update #8</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-04-14-io-sim-annoucement">IOSim on Hackage!</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>One post tagged with &quot;haskell&quot;</h1><a href="/tags">View All Tags</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/2023-04-14-io-sim-annoucement">IOSim on Hackage!</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2023-04-14T00:00:00.000Z" itemprop="datePublished">April 14, 2023</time> Â· <!-- -->16 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a itemprop="url"><span itemprop="name">Marcin Szamotulski</span></a></div><small class="avatar__subtitle" itemprop="description">Network Team Lead</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_mojV" id="iosim-on-hackage">IOSim on Hackage<a class="hash-link" href="#iosim-on-hackage" title="Direct link to heading">â€‹</a></h2><p>The IOG Networking Team is pleased to announce that we published <a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a>,
<a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a>, <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>, <a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer"><code>strict-stm</code></a>, <a href="https://hackage.haskell.org/package/strict-mvar" target="_blank" rel="noopener noreferrer"><code>strict-mvar</code></a> and
<a href="https://hackage.haskell.org/package/io-classes-mtl" target="_blank" rel="noopener noreferrer"><code>io-classes-mtl</code></a> on Hackage.  These are tools without which we could not
imagine writing a complex distributed system like <a href="https://www.github.com/input-output-hk/cardano-node#readme" target="_blank" rel="noopener noreferrer">Cardano</a>.</p><p>These packages support our goal of using the same code to run in production and
simulation, what greatly increases the reliability and quality of the final
system.  <a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a> and its ecosystem is designed to let write a simulation
environment which provides provided things usually provided by an operating
system like networking stack or disk IO and develop as well as implement
&amp; model complex applications/systems.</p><p>For developing a robust system one needs a proper testing framework which
allows one to model the key characteristics of the system.  To achieve this
goal we needed to create an abstraction that captures the key aspects of the
Haskell runtime and operating system environment for distributed systems.  The
Cardano <a href="https://www.github.com/input-output-hk/ouroboros-network#readme" target="_blank" rel="noopener noreferrer">network stack</a> is a highly concurrent system, and
as a network application, it needs to deal with time: there are all sorts of
timeouts that guard resource usage: inactivity timeouts, message timeouts, or
an application level <code>TCP</code>&#x27;s <code>WAIT_TIMEOUT</code> among others.  The tools which we
provide permitted us to capture issues related to timing (which abound in
network programming) which, in production, would be extremely rare (things like
simultaneous TCP open or critical race conditions) and ensure that we can test
(in the simulation) these scenarios.  Recently we caught
a <a href="https://github.com/input-output-hk/ouroboros-network/pull/4265" target="_blank" rel="noopener noreferrer">bug</a> in simultaneous TCP open when one side of the
connection crashed - a corner case of a corner case, that&#x27;s how effective is
the combination of quickcheck style property-based testing &amp; simulation!</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="io-classes"><a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer">IO-Classes</a><a class="hash-link" href="#io-classes" title="Direct link to heading">â€‹</a></h3><p><a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> allow testing production code under simulation where one can
mock services usually provided by the operating system: socket API or disk IO
(both will land on <code>Hackage</code> at some point too).  Our design principle was to
closely follow the <code>base</code> API but also provide extensions that are packaged as
separate libraries: <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>, <a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer"><code>strict-stm</code></a>, <a href="https://hackage.haskell.org/package/io-classes-mtl" target="_blank" rel="noopener noreferrer"><code>io-classes-mtl</code></a>.</p><p><code>io-classes</code> support <code>MVar</code>&#x27;s and in the future it will also support
<code>IOVar</code>s.  The <code>IO</code> instance of <code>MonadMVar</code> is using <code>GHC</code>&#x27;s <code>MVar</code>, while
<code>IOSim</code> instance is based on a <code>TVar</code> specific to <code>IOSim</code>.  <code>MVar</code>s, whether
native or simulated, provide fairness but don&#x27;t provide compositionality (like
<code>TVar</code>s do via <code>STM</code>).  Here&#x27;s a complete list of currently supported APIs
(more to come in the future, if you need more we are happy to accept
contributions!).  The list includes APIs present in core packages like: <code>base</code>,
<code>stm</code>, <code>async</code> or <code>time</code>:</p><ul><li><code>MVar</code> API;</li><li><code>stm</code> API: all monadic operations with support for <code>TVar</code>s, <code>TMVar</code>s,
<code>TQueue</code>s, <code>TBQueue</code>s, <code>TArray</code>s, <code>TSem</code>s, <code>TChan</code>s;</li><li>fork API: <code>forkIO</code>, <code>forkOn</code>, <code>forkWithUnmask</code>, <code>killThread</code>, <code>yield</code>;</li><li>thread API: <code>myThreadId</code>, <code>labelThread</code>, <code>threadStatus</code>;</li><li>synchronous and asynchronous exceptions API: <code>throw</code>, <code>throwTo</code>, <code>catch</code>,
<code>catchJust</code>, <code>try</code>, <code>tryJust</code>, <code>handle</code>, <code>handleJust</code>, <code>catches</code>;
and the high-level <code>bracket</code>, <code>finally</code>, <code>onException</code> and
<code>bracketOnException</code>;</li><li>masking API: <code>mask</code>, <code>mask_</code>, <code>uninterruptibleMask</code>, <code>uninterruptibleMask_</code></li><li>masking state API: <code>getMaskingState</code>, <code>interruptible</code>, <code>allowInterrupt</code></li><li><code>evaluate</code></li><li><a href="https://hackage.haskell.org/package/async" target="_blank" rel="noopener noreferrer"><code>async</code></a> API;</li><li>event trace API: <code>traceEventIO</code>, <code>traceEventMarkerIO</code>;</li><li><code>ST</code> support: <code>stToIO</code>;</li><li>time API: <code>getCurrentTime</code>, <code>getMonotonicTimeNSec</code>; (more in <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>)</li><li>timeout API: <code>registerDelay</code>, <code>timeout</code> ; (more in <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>)</li><li>delays: <code>threadDelay</code>; (more in <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>)</li><li>although this does not strictly belong to this list, we also support
<code>MonadFix</code>, which at times is useful for both <code>IO</code> and <code>IOSim</code>!</li></ul><p>and non-standard APIs:</p><ul><li><code>say</code> (a <code>print</code> like function) </li><li>labelling <code>TVar</code>s &amp; friends (<code>labelTVar</code>)</li><li>tracing committed values to <code>TVar</code>s and <code>TMVar</code>s, inspection of <code>TVar</code>s</li><li>race exploration of <em>IOSimPOR</em></li></ul><p>We plan to add support for <code>IORef</code>s.</p><p>There&#x27;s even more but packaged in separate packages, keep reading!</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="si-timers"><a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer">SI-Timers</a><a class="hash-link" href="#si-timers" title="Direct link to heading">â€‹</a></h3><p>The <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a> (<a href="https://www.wikiwand.com/en/International_System_of_Units" target="_blank" rel="noopener noreferrer">SI</a>) package was designed with two principles in mind:</p><ul><li>provide API which is consistent with <code>timers</code> package and thus is using SI
units (seconds) rather than <code>Int</code> represented milliseconds like <code>base</code> does;</li><li>provide a safe API for 32-bit systems.</li></ul><p>On a 32-bit system an <code>Int</code> can represent up to <code>~35</code> minutes, which often is
too small for longer delays.</p><p><a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a> also comes with a non-standard polyfill for timers API.  The low
level <code>base</code> timers API (e.g. <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/GHC-Event.html#v:registerTimeout" target="_blank" rel="noopener noreferrer"><code>registerTimeout</code></a> &amp; friends) is not available
on all the systems (currently not available on <code>Windows</code> or <code>GHCJS</code>).
Although <code>GHC</code> native timers are performant (when available), our polyfill is
only good enough to develop sub-second timeouts.  It&#x27;s not performant enough on
all platforms for sub-millisecond timeouts as it uses concurrency (on <code>Windows</code>
or <code>GHCJS</code>) and thus relies on GHC scheduler.  In the future, we are planning
to release an implementation of <code>timeout</code> API which is performant across all
platforms (which is part of <a href="https://github.com/input-output-hk/ouroboros-network/tree/master/network-mux" target="_blank" rel="noopener noreferrer"><code>network-mux</code></a> library right now).  There&#x27;s also
an interesting longer <code>GHC</code> project to provide performant native timeouts based
on <code>io-uring</code> (Linux) and <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports" target="_blank" rel="noopener noreferrer"><code>io-completion</code> ports</a>
(Windows).</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="iosim"><a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer">IOSim</a><a class="hash-link" href="#iosim" title="Direct link to heading">â€‹</a></h3><p><a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a> package provides a pure (free) monad that has instances for type
classes defined in <a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> and <a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a>. In particular, <a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a>
supports threads (via low-level <code>forkIO</code> as well as <a href="https://hackage.haskell.org/package/async" target="_blank" rel="noopener noreferrer"><code>async</code></a> package
interface), deadlock detection, asynchronous exceptions, software transaction
memory (<code>STM</code>), lifting <code>ST</code> computations, <code>mfix</code>, and various APIs that
support tracing and inspection.  </p><p>There are many distinctive features of <code>io-sim</code>.  It supports time domains,
which means you can emulate isolated services which only communicate through
a simulation of some IPC interface.  The time is discrete and only advances
when all threads are blocked: either because a thread explicitly called
<code>threadDelay</code>, or the action it runs blocked one an <code>STM</code> transaction.   If
a thread registered a timeout it will be unblocked at a specific time.  Because
the application controls time, this allows testing different interleavings
using the usual QuickCheck techniques.  Here we come to another distinctive
feature of <code>io-sim</code>.  John Hughes built an interpreter, called <em>IOSimPOR</em>,
which dynamically detects races in a given time slot.  The <em>IOSimPOR</em>
interpreter is then able to execute different schedules which revert the order
of evaluation of races and recursively discover &amp; revert new races.  The
implementation follows a partial-order reduction algorithm to limit the
schedule exploration.  <em>IOSimPOR</em> is still considered an experimental feature,
if you encounter a bug we&#x27;d really like to hear about it.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="strict-stm"><a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer">Strict-STM</a><a class="hash-link" href="#strict-stm" title="Direct link to heading">â€‹</a></h3><p>The <a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer"><code>strict-stm</code></a> package provides strict versions of <code>TVar</code>, <code>TMVar</code> &amp; friends.
The <code>StrictTVar</code> also provides a way to embed invariants, which allows one to
hook <a href="https://hackage.haskell.org/package/nothunks" target="_blank" rel="noopener noreferrer"><code>nothunks</code></a> api and verify in a testing environment that one never commit
thunks.  <a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer"><code>strict-stm</code></a> and <a href="https://hackage.haskell.org/package/nothunks" target="_blank" rel="noopener noreferrer"><code>nothunks</code></a> were designed after a long development
period of <a href="https://www.github.com/input-output-hk/cardano-node#readme" target="_blank" rel="noopener noreferrer">Cardano</a> when besides correctness and asymptotic behaviour also
performance started to be important.  In a relatively short time, it allowed to
squash many memory leaks allowing us to release the first version of the current
<a href="https://www.github.com/input-output-hk/cardano-node#readme" target="_blank" rel="noopener noreferrer">Cardano</a> implementation.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="strict-mvar"><a href="https://hackage.haskell.org/package/strict-mvar" target="_blank" rel="noopener noreferrer">Strict-MVar</a><a class="hash-link" href="#strict-mvar" title="Direct link to heading">â€‹</a></h3><p>The package provides strict version of <code>MVar</code>.  Like <a href="https://hackage.haskell.org/package/strict-stm" target="_blank" rel="noopener noreferrer"><code>strict-stm</code></a> it will
support a way to embed invariants.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="io-classes-mtl"><a href="https://hackage.haskell.org/package/io-classes-mtl" target="_blank" rel="noopener noreferrer">IO-Classes-MTL</a><a class="hash-link" href="#io-classes-mtl" title="Direct link to heading">â€‹</a></h3><p>The <a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> contain instances only for <code>ReaderT</code> monad which are
uncontroversial.  Instances for other monad transformers are packaged in
<a href="https://hackage.haskell.org/package/io-classes-mtl" target="_blank" rel="noopener noreferrer"><code>io-classes-mtl</code></a> package.  These are experimental, not properly tested, and
also not extensively used by us at this stage.  Some of the instances are also
novel so please inspect the implementation to get familiar with them before you
start relying on them.</p><p>As a design principle, we tried to be compatible with the <code>exceptions</code> package
especially when it comes to <code>MonadThrow</code> instances of monad transformers.</p><p>For <code>MonadSTM</code> instances we also transform the associated <code>STM</code> monad, e.g. for
<code>StateT s IO</code> the <code>STM (StateT s IO)</code> monad is <code>StateT s (STM IO)</code>.  This means
you can interleave <code>StateT</code> operations with <code>STM</code>.</p><p>We don&#x27;t provide <code>MonadAsync</code> instances for transformer stacks (except of
<code>ReaderT</code>).  One could follow <a href="https://hackage.haskell.org/package/lifted-async" target="_blank" rel="noopener noreferrer"><code>lifted-async</code></a> or be even more general and
allow monoidal join of the asynchronously computed states.  However, this seems
to extravagant and might lead to subtle concurrency bugs.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="examples">Examples<a class="hash-link" href="#examples" title="Direct link to heading">â€‹</a></h2><p>There are many example usages of the <code>io-sim</code> which can be used for
inspiration.  Here we point to just a few which we developed as part of our
testing efforts.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="stm-test-suite">STM test suite<a class="hash-link" href="#stm-test-suite" title="Direct link to heading">â€‹</a></h3><p>In the <a href="https://github.com/input-output-hk/io-sim/blob/master/io-sim/test/Test/Control/Monad/STM.hs" target="_blank" rel="noopener noreferrer"><code>Test.Control.Monad.STM</code></a> module we generate valid <code>STM</code> terms and evaluate them in
both <code>IO</code> and <code>IOSim</code>.  This follows the <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf" target="_blank" rel="noopener noreferrer">Composable
memory transactions</a> paper.</p><p>Terms of this mini-language are a GADT:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">data Term (t :: Type) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Return    :: Expr t -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Throw     :: Expr a -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Catch     :: Term t -&gt; Term t -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Retry     :: Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ReadTVar  :: Name (TyVar t) -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WriteTVar :: Name (TyVar t) -&gt; Expr t -&gt; Term TyUnit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NewTVar   :: Expr t -&gt; Term (TyVar t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- | This is the ordinary monad bind for STM terms.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Bind      :: Term a -&gt; Name a -&gt; Term t -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    OrElse    :: Term t -&gt; Term t -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- | expressions which can appear in `Terms`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data Expr (t :: Type) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExprUnit ::           Expr TyUnit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExprInt  :: Int    -&gt; Expr TyInt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExprName :: Name t -&gt; Expr t</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Following the rules specified in the <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf" target="_blank" rel="noopener noreferrer">Composable Memory
Transactions</a> paper we have:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">evalTerm :: Env -&gt; Heap -&gt; Allocs -&gt; Term t -&gt; (NfTerm t, Heap, Allocs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- | The heap is a mapping of &#x27;Var&#x27;s to their current values.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">newtype Heap = Heap (Map VarId SomeValue)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  deriving (Show, Semigroup, Monoid)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- | The STM semantics uses two heaps, the other one is called the allocations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Allocs = Heap</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- | The normal form for a &#x27;Term&#x27; after execution.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data NfTerm (t :: Type) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NfReturn :: Value t -&gt; NfTerm t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NfThrow  :: Value a -&gt; NfTerm t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NfRetry  ::            NfTerm t</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>See <a href="https://github.com/input-output-hk/io-sim/blob/93858df930c160450e12f34428b61e74813b14ae/io-sim/test/Test/STM.hs#L302" target="_blank" rel="noopener noreferrer"><code>evalTerm</code></a>.</p><p>Each term can be executed in <code>STM m</code> monad:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">execTerm :: (MonadSTM m, MonadCatch (STM m))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         =&gt; ExecEnv m</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         -&gt; Term t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         -&gt; STM m (ExecValue m t)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>See <a href="https://github.com/input-output-hk/io-sim/blob/93858df930c160450e12f34428b61e74813b14ae/io-sim/test/Test/STM.hs#L465" target="_blank" rel="noopener noreferrer"><code>execTerm</code></a>.</p><p><code>execTerm</code> and <code>evalTerm</code> all together give three ways of executing a <code>Term</code>:</p><ul><li>via the spec (as implemented by <code>evalTerm</code>)</li><li>in <code>IO</code> (using <code>stm</code> package)</li><li>in <code>IOSim</code> (using the built-in <code>stm</code> support)</li></ul><p>The last two are only possible because <code>execTerm</code> is written in terms of
<code>MonadSTM m</code> and <code>MonadCatch (STM m)</code> are available from <code>io-classes</code>.</p><p>This gave us confidence that the most tricky operator <code>orElse</code> is
implemented correctly.</p><p>The <a href="https://github.com/input-output-hk/io-sim/blob/master/io-sim/test/Test/Control/Monad/STM.hs" target="_blank" rel="noopener noreferrer"><code>Test.Control.Monad.STM</code></a> module also implements an <code>Arbitrary</code> instance (with a proper
shrinker) of <code>Terms</code>s.  The heart of it is the <code>genTerm</code> function which
generates arbitrary expressions of a given type.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="simulated-network-interfaces">Simulated Network Interfaces<a class="hash-link" href="#simulated-network-interfaces" title="Direct link to heading">â€‹</a></h3><p>Cardano must run on various platforms and support different communication
bearers, e.g. it communicates via TCP/IP between nodes, but it also exposes
an IPC using UNIX sockets.  That would be fine if we&#x27;d need to only support
<code>Linux</code> and <code>MacOS</code>.  However, many end users who are running a full wallet
are using <code>Windows</code> machines, on which UNIX sockets are not well supported.
<code>Windows</code> has its own <a href="https://learn.microsoft.com/en-us/windows/win32/ipc/named-pipes" target="_blank" rel="noopener noreferrer">named pipes</a> API.  Although similar, their interface is
a bit different than the familiar Berkeley socket interface.  However, it&#x27;s
possible to embrace both using the following <code>Snocket</code> API:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">-- | Abstract communication interface that can be used by &#x27;Socket&#x27; or a named pipe.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- Snockets are polymorphic over monad, which is useful for testing and/or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- simulations.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data Snocket m fd addr = Snocket {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    getLocalAddr  :: fd -&gt; m addr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , getRemoteAddr :: fd -&gt; m addr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , addrFamily    :: addr -&gt; AddressFamily addr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -- | Open a file descriptor  (socket / named pipe).  For named pipes, it is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -- using &#x27;CreateNamedPipe&#x27; syscall, for Berkeley sockets &#x27;socket&#x27; is used.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  --</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , open          :: AddressFamily addr -&gt; m fd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- | A way to create &#x27;fd&#x27; to pass to &#x27;connect&#x27;.  For named pipes, it will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- use &#x27;CreateFile&#x27; syscall.  For Berkeley sockets it is the same as &#x27;open&#x27;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- For named pipes, we need full &#x27;addr&#x27; rather than just address family as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- it is for sockets.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , openToConnect :: addr -&gt; m fd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- | `connect` is only needed for Berkeley sockets, for named pipes this is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- no-op.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    --</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , connect       :: fd -&gt; addr -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , bind          :: fd -&gt; addr -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , listen        :: fd -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , accept        :: fd -&gt; m (Accept m fd addr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  , close         :: fd -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>Snocket</code> is parametrised by the monad in which it runs, file descriptor type,
and address type.  The difference between Berkeley sockets and named pipes lies
in the <code>accept</code> call (which will not cover in this blog, see <a href="https://input-output-hk.github.io/ouroboros-network/ouroboros-network-framework/Ouroboros-Network-Snocket.html#t:Accept" target="_blank" rel="noopener noreferrer"><code>Accept</code></a>).</p><p>There are four ways to construct a <code>Snocket</code>:</p><ul><li><a href="https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs#L290" target="_blank" rel="noopener noreferrer"><code>socketSnocket</code></a> - which is using the Berkeley <code>socket</code> API (and thus
supports both <code>AF_INET</code>, <code>AF_INET6</code> and <code>AF_UNIX</code> families);</li><li><a href="https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs#L378" target="_blank" rel="noopener noreferrer"><code>localSnocket</code></a> - a local socket: using <code>AF_UNIX</code> on systems on which
Berkeley sockets are available or named pipes on Windows;</li><li><a href="https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network-framework/src/Simulation/Network/Snocket.hs#L376" target="_blank" rel="noopener noreferrer"><code>withSnocket</code></a> - an implementation of <code>Snocket</code> dedicated for <code>IOSim</code>
simulations.</li></ul><p><code>Snocket</code> interface allows us to parametrise the Cardano diffusion
layer (<a href="https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network/src/Ouroboros/Network/Diffusion/P2P.hs#L531" target="_blank" rel="noopener noreferrer"><code>Ouroboros.Network.Diffusion.P2P.runM</code></a>) and either
run in <code>IO</code> with <code>Snocket</code>s provided by the system calls and at the same time
build <code>IOSim</code> simulations which run multiple Cardano diffusion layers.  The
<code>withSnocket</code> API allows to embed network errors, simulating network delays, TCP
simultaneous open (which is not infrequent in the Cardano ecosystem).  For
an example we test that when <code>accept</code> call errors the application can recover
(this turned out to be an issue once we discovered a bug in <code>MacOS</code> kernel, see
<a href="https://github.com/input-output-hk/ouroboros-network/pull/3388/commits/a8ba8f5224c22795f3ed9d91827ac104005e8c7d" target="_blank" rel="noopener noreferrer">ref</a>).  <code>IOSim</code> allowed us to simulate the buggy behaviour of
<code>MacOS</code> and verify that our solution indeed fixes the problem.  What is
outstanding for the <a href="https://github.com/input-output-hk/ouroboros-network/blob/db633ec71eff9b2b7797ad0cce0c130771b8cf0c/ouroboros-network/src/Ouroboros/Network/Diffusion/P2P.hs#L531" target="_blank" rel="noopener noreferrer"><code>Ouroboros.Network.Diffusion.P2P.runM</code></a>
function is that its entirely described by classes from <a href="https://hackage.haskell.org/package/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> and
<a href="https://hackage.haskell.org/package/si-timers" target="_blank" rel="noopener noreferrer"><code>si-timers</code></a> packages, while it&#x27;s responsible for:</p><ul><li>maintaining bidirectional connections with remote peers (which turned out to
be more complex than we initially anticipated, which involves a handful of
states and transitions);</li><li>running multiplexed protocol applications: this includes making decisions
like from which peer to download a block based on real-time data and
executing such a decision via one of the protocols;</li><li>resolving DNS names;</li><li>provide safety guarantees (e.g. if one of the protocol errors the connection
must be reset);</li><li>keeping remote nodes honest about their timeliness obligations (i.e. enforcing
network timeouts).</li></ul><p>Since the architecture is inherently concurrent: each connection multiplexes up
to four concurrent mini-protocols in both directions (which makes at least
8 threads (even 16 if we count our current implementation of network protocol
pipelining), not counting some other concurrent services.  Being able to
execute the whole diffusion layer in a deterministic simulation environment
which supports race discovery helped us to discover and fix deadlocks and rare
bugs which otherwise would be very difficult to debug in real-system.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="one-code-base-for-production--testing">One code base for production &amp; testing<a class="hash-link" href="#one-code-base-for-production--testing" title="Direct link to heading">â€‹</a></h3><p>To run the same codebase for production and testing we use one more trick.  We
use the <a href="https://hackage.haskell.org/package/contra-tracer" target="_blank" rel="noopener noreferrer"><code>contra-tracer</code></a> library.  The current implementation of <code>Tracer</code> is
more complex (so that it&#x27;s zero cost abstraction if tracing is not used), but
for this blog post we can assume that the <code>Tracer</code> is defined as:</p><div class="codeBlockContainer_I0IT language-haskell theme-code-block"><div class="codeBlockContent_wNvx haskell"><pre tabindex="0" class="prism-code language-haskell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">newtype Tracer m a = Tracer { withTracer :: a -&gt; m () }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">instance Contravariant (Tracer m) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    contramap f (Tracer g) = Tracer (g . f)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In testing, we can instantiate the tracer with something like
<a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceM" target="_blank" rel="noopener noreferrer"><code>Control.Monad.IOSim.traceM</code></a>.  With the help of
<a href="https://github.com/input-output-hk/io-sim/blob/main/io-sim/src/Control/Monad/IOSim.hs#L174" target="_blank" rel="noopener noreferrer"><code>Control.Monad.IOSim.selectTraceEventsDynamic</code></a> one
can recover the trace and build a quickcheck property that must be satisfied.
In this way <code>Tracer</code> is our eye into the underlying state of the system.</p><p>In the production environment, a dedicated logging backend is behind the
<code>Tracer</code> abstraction.</p><p>The contravariant nature of the <code>Tracer</code> is very helpful.  If you are testing
your component you might have access to the logs it&#x27;s emitting, but in the real
implementation the component might be embedded deep inside your stack and it&#x27;s
logs might as well be embedded into some larger data structure or even more
importantly with more context.  Contravariant tracer allows you to peal the
onion as you pass the tracer deeper into the stack, adding the extra
information on the way.  Contravariant tracing allows for avoiding low-level
components to have access to high-level tracing information, and make it
possible to decouple and isolate components even if they depend on each other.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="some-iosim-features">Some IOSim features<a class="hash-link" href="#some-iosim-features" title="Direct link to heading">â€‹</a></h2><h3 class="anchor anchorWithStickyNavbar_mojV" id="trace">Trace<a class="hash-link" href="#trace" title="Direct link to heading">â€‹</a></h3><p><a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a> not only allows one to run simulations but also gives access to
detailed traces.  With <a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSimTrace" target="_blank" rel="noopener noreferrer">Control.Monad.IOSim.runSimTrace</a> function
you can get a trace that contains timed execution events including fork
events, blocking / unblocking STM events, synchronous and asynchronous
exceptions (including blocking information of <code>throwTo</code>), forking events, delay
&amp; timers events.  The <a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#t:SimTrace" target="_blank" rel="noopener noreferrer"><code>SimTrace</code></a> can be pretty-printed with
<a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:ppTrace" target="_blank" rel="noopener noreferrer">Control.Monad.IOSim.ppTrace</a>.  You also have control over the names
of threads and <code>TVar</code>s.  And as we mentioned you can extract information logged
by the code in simulation.  From the <code>SimTrace</code> you can also extract the result
computed by your simulation with
<a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceResult" target="_blank" rel="noopener noreferrer">Control.Monad.IOSim.traceResult</a>.  These three functions are
useful for example to enhance test failure information (e.g. via the well known
<a href="https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/Test-QuickCheck.html#v:counterexample" target="_blank" rel="noopener noreferrer"><code>counterexample</code></a> from the <code>QuickCheck</code> library).</p><p>You can use <a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSim" target="_blank" rel="noopener noreferrer"><code>runSim</code></a> or <a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:runSimOrThrow" target="_blank" rel="noopener noreferrer"><code>runSimOrThrow</code></a> if you are not interested in the
trace but you just want to get the result.  Note that the <code>SimTrace</code> is very
verbose, and thus it might include too much information to analyse simple
problems, but it is indispensable when analysing concurrency bugs.</p><p><a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a> also allows inspecting values committed to <code>TVar</code>s in an <code>STM</code>
transaction.  In the early days, we relied on tracing, but that can be
rescheduled and thus reorder events.
<a href="https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSTM.html#t:MonadTraceSTM" target="_blank" rel="noopener noreferrer">Control.Monad.Class.MonadSTM.MonadTraceSTM</a> provides the API.
<code>IOSim</code> attaches the callbacks to its <code>TVar</code>s and executes them whenever an
<code>STM</code> transaction is committed.  The callbacks allow one to either log
<code>Strings</code> (the same way as the <a href="https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSay.html#v:say" target="_blank" rel="noopener noreferrer"><code>say</code></a> from
<a href="https://hackage.haskell.org/package/io-classes-1.0.0.0/docs/Control-Monad-Class-MonadSay.html#t:MonadSay" target="_blank" rel="noopener noreferrer">Control.Monad.Class.MonadSay</a> module does), or arbitrary data as
<a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceM" target="_blank" rel="noopener noreferrer"><code>traceM</code></a> does.</p><p><a href="https://hackage.haskell.org/package/io-sim" target="_blank" rel="noopener noreferrer"><code>io-sim</code></a>&#x27;s <code>STM</code> monad allows to log values with <a href="https://hackage.haskell.org/package/io-sim-1.0.0.0/docs/Control-Monad-IOSim.html#v:traceSTM" target="_blank" rel="noopener noreferrer"><code>traceSTM</code></a>.  Since this
function is not polymorphic over monad, it is usage is mostly limited to
debugging stm transactions.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="laziness">Laziness<a class="hash-link" href="#laziness" title="Direct link to heading">â€‹</a></h3><p><code>IOSim</code>(in both flavours: <em>IOSim</em> and <em>IOSimPOR</em>) is executed in lazy <code>ST</code>
monad.  This means that the trace is created lazily.  This allows us to
provide a simple <code>MonadFix</code> instance, but also allows one to simulate
applications that never exit and then only analyse a finite portion of
a trace.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="acknowledgement">Acknowledgement<a class="hash-link" href="#acknowledgement" title="Direct link to heading">â€‹</a></h2><p><code>io-sim</code> was developed by <a href="https://www.well-typed.com/" target="_blank" rel="noopener noreferrer">Well-Typed</a> and <a href="https://iohk.io" target="_blank" rel="noopener noreferrer">IOG</a>.  We would like to specially
thank Duncan Coutts for his ideas, help, guidance and contributions.
<code>IOSimPOR</code> was developed by John Hughes from <a href="http://www.quviq.com" target="_blank" rel="noopener noreferrer">QuviQ</a>.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/haskell">haskell</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/io-sim">io-sim</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/testing">testing</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about IOSim on Hackage!" href="/2023-04-14-io-sim-annoucement"><b>Read More</b></a></div></footer></article></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/iog_eng" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://iohk.io/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">IOG Blog</a></li><li class="footer__item"><a href="https://github.com/input-output-hk/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2023 IOG Engineering, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.622cf124.js"></script>
<script src="/assets/js/main.c479010e.js"></script>
</body>
</html>