<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="IOG Engineering RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="IOG Engineering Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="IOG Engineering JSON Feed"><title data-react-helmet="true">2 posts tagged with &quot;ffi&quot; | IOG Engineering</title><meta data-react-helmet="true" property="og:title" content="2 posts tagged with &quot;ffi&quot; | IOG Engineering"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://engineering.iog.io/tags/ffi"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_tags_posts"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://engineering.iog.io/tags/ffi"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/tags/ffi" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/tags/ffi" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.10ad4647.css">
<link rel="preload" href="/assets/js/runtime~main.72145f55.js" as="script">
<link rel="preload" href="/assets/js/main.7404fde3.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Recent</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/tags">Tags</a><a class="navbar__item navbar__link" href="/archive">Archive</a></div><div class="navbar__items navbar__items--right"><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">üåú</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">üåû</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-tags-post-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-01-12-ghc-update">GHC DevX Update 2023-01-12</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-12-13-ghc-js-backend-merged">JavaScript backend merged into GHC</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-09-28-introduce-q-d">Model-Based Testing with QuickCheck</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-09-23-ghcjs-heap-representation">GHCJS heap representation</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-08-18-js-backend-ffi">GHCJS FFI system in the JS Backend</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><header class="margin-bottom--xl"><h1>2 posts tagged with &quot;ffi&quot;</h1><a href="/tags">View All Tags</a></header><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/2022-08-18-js-backend-ffi">GHCJS FFI system in the JS Backend</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-08-18T00:00:00.000Z" itemprop="datePublished">August 18, 2022</time> ¬∑ <!-- -->8 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://iog.io/en/" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Jeffrey M. Young</span></a></div><small class="avatar__subtitle" itemprop="description">Haskell DevX Engineer @ IOG</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><ol><li><a href="#orgcf7b9df">The Design Space</a></li><li><a href="#orgdca8008">GHCJS<!-- -->‚Äô<!-- -->s FFI</a></li><li><a href="#org461ca2a">Lightweight safety checks</a></li><li><a href="#orge4568be">Returning multiple values</a></li><li><a href="#org87ce79c">Changes in the FFI System for the JS Backend</a></li></ol><p>Users of GHCJS enjoyed a rich
<a href="https://github.com/ghcjs/ghcjs/blob/master/doc/foreign-function-interface.md" target="_blank" rel="noopener noreferrer">FFI</a>
system for foreign JavaScript imports. However, this has changed during our
adaptation of GHCJS to GHC 9.x. This short post goes over the GHCJS FFI system,
the motivation for these changes and what the changes are. First, we must
consider the design space of an FFI system.</p><a id="orgcf7b9df"></a><h1>The Design Space</h1><p>FFI code is typically employed in high performance scenarios. Additionally,
users of the FFI <em>do not</em> want to deal with the object language the compiler is
compiling to. Instead, users want a simple way to call functions from the object
language and use them in their own code as normal Haskell functions. However,
users of the FFI system <em>do</em> tend to be power users, and so as a design principle
we want to expose the tools they need to achieve their performance needs,
whatever those needs may be. We can summarize these constraints as follows:</p><ol><li>The FFI must abstract the JavaScript backend<!-- -->‚Äô<!-- -->s infidelities away as much as
possible. That is, users of the FFI <em>should</em> need to worry about the <code>Int64#</code>
representation, but should also be able to simply follow standard patterns we
have written in <code>base</code>.</li><li>The FFI must provide tools to achieve high performance code, even if those
tools require up front knowledge of the runtime system to use. However, these
tools should not be in the path of least resistance to use the FFI system.</li><li>The FFI must provide a lightweight specification that user<!-- -->‚Äô<!-- -->s program against
for the JS backend to optimize the imported function and for good error
messages for users.</li></ol><p>GHCJS<!-- -->‚Äô<!-- -->s FFI sets a high (qualitative) benchmark on these three constraints.
Let<!-- -->‚Äô<!-- -->s inspect them each in detail, in no particular order.</p><a id="orgdca8008"></a><h1>GHCJS<!-- -->‚Äô<!-- -->s FFI</h1><p>In GHCJS, a user could take advantage of JavaScript functions in their Haskell
code using the GHCJS<!-- -->‚Äô<!-- -->s FFI. However, the syntax was unique to GHCJS with place
holder variables like one might see in perl, nix, or bash. For example, here is
a foreign import from the <code>base</code> library for <code>st_size</code>:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">-- base/System/Posix/Internal.hs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- the JS FFI version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foreign import javascript unsafe &quot;$r1 = h$base_st_size($1_1,$1_2); $r2 = h$ret1;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   st_size :: Ptr CStat -&gt; IO Int64</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The syntax is different from what we know and love in the normal Haskell world
but the grammar is straightforward. We declare a <code>foreign import</code> from <code>javascript</code>,
state that the import is <code>unsafe</code> or <code>interruptible</code> and then provide a string,
<code>h$base_fstat(...)</code> for the code generator to use when compiling. Compare this
with the C version:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">-- base/System/Posix/Internal.hs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- the C FFI version</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foreign import ccall unsafe &quot;HsBase.h __hscore_st_size&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   st_size :: Ptr CStat -&gt; IO Int64</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>And we see that they are similar. The only difference is the strange <code>$n</code>
symbols in the referrent string. Contrast this with the C version, which simply
declares a name.</p><p>These symbols are <em>place holder</em> variables with special meaning in GHCJS. There
are two intractable reasons for the placeholder patterns. First, we require
these patterns to work around the limitations of JavaScript as a backend (1).
For example, consider the case where we need to return an <code>Int64#</code> from an
imported foreign function. In C and Haskell this is not a problem because both
can represent <code>Int64#</code> natively, however JavaScript only has native support for
32-bit values. Thus, to be able to return an <code>Int64#</code> we need to have a method to
return two 32-bit numbers. Similarly, in order to apply a function to an <code>Int64#</code>
that function must take at least two arguments, one for the high bits and one
for the low. Second, the referrent string is untyped and can contain arbritrary
JavaScript code. So placeholder patterns provide a simply and lightweight way
for safety checks and eliminate classes of untyped, hard to understand errors.
For example, consider an arity mismatch error between a function definition and
call site. When this happens JavaScript happily continues processing with the
return value from the function application defined as <code>NaN</code> (of course). Such
arity conflicts can easily occur, especially when dealing with 64-bit values
which require function arity assumptions.</p><a id="org461ca2a"></a><h1>Lightweight safety checks</h1><p>Lightweight safety checks (3) are done by GHCJS by parsing the names of the
place holder variables; each of which follows a specific naming convention. This
convention is:</p><ul><li>Argument types:<ul><li><code>$n</code>: Used for unary arguments, i.e., arguments which require only a single register.</li><li><code>$n_n</code>: Used for binary arguments, i.e., arguments which require two registers.</li><li><code>$c</code>: A continuation argument, only valid for <code>interruptible</code> foreign functions.</li></ul></li><li>Return types:<ul><li><code>$r</code>: a unary return</li><li><code>$r1</code>, <code>$r2</code>: a binary return</li><li><code>$r1</code>, <code>$r2</code>, <code>$r3_1</code>, <code>$r3_2</code>: unboxed tuple return</li></ul></li><li>Top level patterns:<ul><li><code>&quot;&amp;value&quot;</code>: simply emitted as <code>value</code> by the code generator</li><li><code>&quot;someFunction&quot;</code>: emitted as <code>ret = someFunction(...)</code>, i.e., map the FFI to
the result of the function call.</li><li><code>&quot;$r = $1.f($2)&quot;</code>: emitted as <code>r1 = a1.f(a2)</code>, i.e., a combination of a
function call and a property access.</li></ul></li></ul><p>With this standard GHCJS then parses the FFI referrent string to ensure that it
conforms to this standard. If not then GHCJS can at least respond to the user
with an ill-formatted FFI message <em>and</em> say precisely where the issue is. For
example, it could respond that only half of an <code>Int64#</code> is returned based on the
referrent string and the function type.</p><a id="orge4568be"></a><h1>Returning multiple values</h1><p>But what of performant code? GHCJS achieves performant FFI by not trying to
abstract away from the runtime system. Instead, an advantage of GHCJS<!-- -->‚Äô<!-- -->s FFI <em>is</em>
that we can specify exactly which registers the foreign function should dump its
results or even arbitrary global variables. This places more burden on the user
of the FFI in specific scenarios, but crucially allows the FFI system to get out
of the way of the user. The FFI system also exploits this capability to return
multiple values from a single function call, which is a common need when
compiling to JavaScript. For example, in the above code <code>st_size</code> is declared to
return an <code>IO Int64</code>, the JavaScript handler <code>h$base_st_size</code> returns the <code>Int64</code>
using two registers <code>$r1</code> and <code>$r2</code>, but does so through the use of a special
purpose global variable called <code>h$ret1</code>:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">function h$base_st_size(stat, stat_off) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    h$ret1 = (stat.i3[(stat_off&gt;&gt;2)+2]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (stat.i3[(stat_off&gt;&gt;2)+1]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The function inputs a pointer and an offset. Pointers in GHCJS are simply
pointers to ByteArrays so the function indexes into the ByteArray and retrieves
and stores the lower 32-bits in <code>h$ret1</code>, then returns the higher 32-bits
directly. These results are picked up by the FFI code, which performs assignment
to set <code>$r1</code> to the result of the function call (the higher 32-bits), and set <code>$r2</code>
to the value of <code>h$ret1</code> (the lower 32-bits). Crucially, the runtime system needs
to do nothing. The registers are already handled ready to be consumed by
whatever the caller of the foreign function will do.</p><p>One might consider using a simpler design, which trades register juggling for a
more straightforward representation such as a ByteArray which stores the <code>Int64#</code>.
However, such a design would trade speed for implementation simplicity. If we
passed ByteArrays then each foreign function would spend time wrapping and
unwrapping the array to get the payload; clearly an undesirable outcome for high
performance code.</p><a id="org87ce79c"></a><h1>Changes in the FFI System for the JS Backend</h1><p>So we see that GHCJS<!-- -->‚Äô<!-- -->s FFI system actually performs quite well in the design
space. Power users are well supported and can leverage enough unsafety to bind
global variables like <code>h$ret1</code> and specific registers such as <code>$r1</code>. The system
provides some lightweight checking through parsing. The nuances of the
JavaScript platform are generally abstracted over and the FFI system is tuned
for performance critical scenarios. So why change it?</p><p>The short answer is to hit deadlines. By skipping the FFI parsing the JS Backend
team was able to produce a working (can output <!-- -->‚Äú<!-- -->Hello World!<!-- -->‚Äù<!-- -->, and compile GHC<!-- -->‚Äô<!-- -->s
boot libraries), integrated, JS backend in GHC faster than had we finished the
FFI system.</p><p>For the time being, we have opted to replaced each foreign function call with a
JavaScript fat arrow, for example:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">foreign import javascript unsafe &quot;(($1_1,$1_2) =&gt; { return h$base_st_size($1_1,$1_2); })&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   st_size :: Ptr CStat -&gt; IO Int64</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p> Of course, this situation is untenable, as argued above, FFI code is assumed to
be used in performance critical code, and thus any extra overhead, such as a
function closure and consequent indirection, must be avoided. But fear not! In
the near future we<!-- -->‚Äô<!-- -->ll be overhauling the FFI system and returning it to its
former glory.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/ghc">ghc</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/javascript">javascript</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/ffi">ffi</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/explanation">explanation</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/knowledge-engineering">knowledge_engineering</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about GHCJS FFI system in the JS Backend" href="/2022-08-18-js-backend-ffi"><b>Read More</b></a></div></footer></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/2022-07-18-lightweight-threads-on-JavaScript">Lightweight Haskell Threads on JavaScript</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-07-18T00:00:00.000Z" itemprop="datePublished">July 18, 2022</time> ¬∑ <!-- -->4 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a itemprop="url"><span itemprop="name">Luite Stegeman</span></a></div><small class="avatar__subtitle" itemprop="description">Haskell DevX Engineer @ IOG</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">‚Äã</a></h2><p>I recently gave a short presentation on the topic of threads in GHCJS to the GHC team at IOG. This blog post is a summary of the content.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="javascript-and-threads">JavaScript and Threads<a class="hash-link" href="#javascript-and-threads" title="Direct link to heading">‚Äã</a></h2><p>JavaScript is fundamentally single threaded. There are ways to share specific data between tasks but it&#x27;s not possible to run multiple threads that have access to a shared memory space of JavaScript data.</p><p>The single JavaScript thread is often responsible for multiple tasks. For example a node.js server handles multiple simultaneous connections and a web application may be dealing with user input while downloading new data in the background.</p><p>This means that any single task should take care to never block execution of the other task. JavaScript&#x27;s canonical answer is to use asynchronous programming. A function reading a file returns immediately without waiting for the file data to be loaded in memory. When the data is ready, a user-supplied callback is called to continue processing the data.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="haskell-threads">Haskell Threads<a class="hash-link" href="#haskell-threads" title="Direct link to heading">‚Äã</a></h2><p>Concurrent Haskell supports lightweight threads through <code>forkIO</code>. These threads are scheduled on top of one more more operating system thread. A blocking foreign call blocks an OS thread but other lightweight threads can still run on other OS threads if available.</p><p>There is no built-in support for foreign calls with a callback in the style of JavaScript. Functions imported with <code>foreign import ccall interruptible</code> can be interrupted by sending an asynchronous exception to the corresponding lightweight thread.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="lightweight-threads-in-javascript">Lightweight Threads in JavaScript<a class="hash-link" href="#lightweight-threads-in-javascript" title="Direct link to heading">‚Äã</a></h2><p>GHCJS implements lightweight threads on top of the single JavaScript thread. The scheduler switches between threads and handles synchronization through <code>MVar</code> and <code>STM</code> as expected from other Haskell platforms.</p><p>Foreign calls that don&#x27;t block can be handled in the usual way. We extend the foreign function interface with a new type <code>foreign import javascript interruptible</code> that conveniently supports the callback mechanism used by JavaScript frameworks. The foreign call is supplied with an additional argument <code>$c</code> representing a callback to be called with the result when ready. From the Haskell side the corresponding lightweight thread is blocked until <code>$c</code> is called. This type of foreign call can be interrupted with an asynchronous exception to the lightweight Haskell thread.</p><p>By default, Haskell threads in the JS environment run asynchronously. A call to <code>h$run</code> returns immediately and starts the thread in the background. This works for tasks that does not require immediate actions. For situations that require more immediate action, such as dealing with event handler propagation, there is <code>h$runSync</code>. This starts a synchronous thread that is not interleaved with other task. If possible, the thread runs to completion before the call to <code>h$runSync</code> returns. If the thread blocks for any reason, such as waiting for an <code>MVar</code> or a <code>foreign import javascript interruptible</code> call, synchronous execution cannot complete. The blocking task is then either interrupted with an exception or the thread is &quot;demoted&quot; to a regular asynchronous thread.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="black-holes">Black Holes<a class="hash-link" href="#black-holes" title="Direct link to heading">‚Äã</a></h2><p>When a Haskell value is evaluated, its heap object is overwritten by a black hole. This black hole marks the value as being evaluated and prevents other threads from doing the same. &quot;black holing&quot; can be done either immediately or &quot;lazily&quot;, when the garbage collector is run. GHCJS implements immediate blackholing.</p><p>Black holes give rise to an interesting problem in the presence of synchronous and asynchronous threads. Typically if we use <code>h$runSync</code>, we want to have some guarantee that at least part of the task will run succesfully without blocking. For the most past it&#x27;s fairly clear which parts of our task depends on potentially blocking IO or thread synchronization. But black holes throw a spanner in the works: Suddenly any &quot;pure&quot; data structure can be a source of blocking if it is under evaluation by another thread.</p><p>To regain some predictability and usability of synchronous threads, the <code>h$runSync</code> scheduler can run other Haskell threads in order to &quot;clear&quot; a black hole. The process ends all black holes have been cleared or when any of the black holes is impossible to clear because of a blocking situation.</p><p>This all happens transparantly to the caller of <code>h$runSync</code>, if the black holes could be cleared it appears as if they were never there.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">‚Äã</a></h2><p>We have lightweight Haskell threads in the single-threaded JavaScript environment and extend the foreign function interface to easily support foreign calls that depend on an asynchronous callback. This way, only the Haskell lightweight thread blocks.</p><p>By default, Haskell threads are asynchronous and run in the background: The scheduler interleaves the tasks and synchronization between threads. For situations that require immediate results or actions there are synchronous threads. Synchronous threads cannot block and are not interleaved with other tasks except when a black hole is encountered.</p></div><footer class="row docusaurus-mt-lg"><div class="col col--9"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/ghc">ghc</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/javascript">javascript</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/concurrency">concurrency</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/ffi">ffi</a></li></ul></div><div class="col text--right col--3"><a aria-label="Read more about Lightweight Haskell Threads on JavaScript" href="/2022-07-18-lightweight-threads-on-JavaScript"><b>Read More</b></a></div></footer></article></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/iog_eng" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://iohk.io/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">IOG Blog</a></li><li class="footer__item"><a href="https://github.com/input-output-hk/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2023 IOG Engineering, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.72145f55.js"></script>
<script src="/assets/js/main.7404fde3.js"></script>
</body>
</html>