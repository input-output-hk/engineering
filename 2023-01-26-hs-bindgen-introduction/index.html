<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<title data-react-helmet="true">One step forward, an easier interoperability between Rust and Haskell | IOG Engineering</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://engineering.iog.io/2023-01-26-hs-bindgen-introduction"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><meta data-react-helmet="true" property="og:title" content="One step forward, an easier interoperability between Rust and Haskell | IOG Engineering"><meta data-react-helmet="true" name="description" content="TL;DR: This blog post intends to sum up the why and how of cargo-cabal and hs-bindgen. If you‚Äôre looking for usage walkthroughs and code examples, check out project READMEs on GitHub!"><meta data-react-helmet="true" property="og:description" content="TL;DR: This blog post intends to sum up the why and how of cargo-cabal and hs-bindgen. If you‚Äôre looking for usage walkthroughs and code examples, check out project READMEs on GitHub!"><meta data-react-helmet="true" property="og:type" content="article"><meta data-react-helmet="true" property="article:published_time" content="2023-01-26T00:00:00.000Z"><meta data-react-helmet="true" property="article:tag" content="cabal,rust,bindgen"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://engineering.iog.io/2023-01-26-hs-bindgen-introduction"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/2023-01-26-hs-bindgen-introduction" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/2023-01-26-hs-bindgen-introduction" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.10ad4647.css">
<link rel="preload" href="/assets/js/runtime~main.b773a5bf.js" as="script">
<link rel="preload" href="/assets/js/main.1356801f.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/iohk-logo.png" alt="IOG" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/iohk-logo-inverted.png" alt="IOG" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Recent</a><a class="navbar__item navbar__link" href="/tags">Tags</a><a class="navbar__item navbar__link" href="/archive">Archive</a></div><div class="navbar__items navbar__items--right"><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">üåú</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">üåû</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-08-15-ghc-update">IOG GHC Update #33</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-07-24-ghc-update">IOG GHC Update #32</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-07-08-ghc-update">IOG GHC Update #31</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-06-17-ghc-update">IOG GHC Update #30</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-05-23-ghc-update">IOG GHC Update #29</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-05-02-ghc-update">IOG GHC Update #28</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-04-11-ghc-update">IOG GHC Update #27</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-03-21-ghc-update">IOG GHC Update #26</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-02-29-ghc-update">IOG GHC Update #25</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-02-08-ghc-update">IOG GHC Update #24</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-01-18-ghc-update">IOG GHC Update #23</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2024-01-04-ghc-update">IOG GHC Update #22</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-12-07-ghc-update">IOG GHC Update #21</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-11-16-ghc-update">IOG GHC Update #20</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-10-26-ghc-update">IOG GHC Update #19</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-10-25-internship">Internship in GHC at IOG</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-10-05-ghc-update">IOG GHC Update #18</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-09-14-ghc-update">IOG GHC Update #17</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-08-24-ghc-update">IOG GHC Update #16</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-08-03-ghc-update">IOG GHC Update #15</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">One step forward, an easier interoperability between Rust and Haskell</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2023-01-26T00:00:00.000Z" itemprop="datePublished">January 26, 2023</time> ¬∑ <!-- -->11 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a itemprop="url"><span itemprop="name">Yvan Sraka</span></a></div><small class="avatar__subtitle" itemprop="description">Rust DevX Engineer @ IOG</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p><strong>TL;DR:</strong> This blog post intends to sum up the why and how of <a href="https://github.com/yvan-sraka/cargo-cabal" target="_blank" rel="noopener noreferrer"><code>cargo-cabal</code></a> and <a href="https://github.com/yvan-sraka/hs-bindgen" target="_blank" rel="noopener noreferrer"><code>hs-bindgen</code></a>. If you‚Äôre looking for usage walkthroughs and code examples, check out project READMEs on GitHub!</p><blockquote><p><strong>N.B.</strong> quoted paragraphs in this article give straightforward motivation regarding some systems programming basic concepts. Feel free to skip them if you know you‚Äôre likely to be already comfortable with them ;)</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="Direct link to heading">‚Äã</a></h2><p>At IOG we maintain large <a href="https://www.haskell.org" target="_blank" rel="noopener noreferrer">Haskell</a> codebases and we would like to interface them with some libraries written in <a href="https://www.rust-lang.org" target="_blank" rel="noopener noreferrer">Rust</a>.</p><p>Rust is a system programming language known for its strong static typing guarantees, which make it similar to Haskell (even if a bit less expressive). However, unlike Haskell, Rust does not have a GC (Garbage Collector) and uses a compile-time memory management strategy. This mechanism is encoded through its type system with the concepts of <em>‚Äúownership‚Äù</em> and <em>‚Äúlifetime‚Äù</em> of values, which can complicate the writing of programs but unlock smaller runtime costs footprint. Rust is becoming increasingly popular in the systems programming and embedded systems domains, and it is also used in areas such as cryptography, where performance and correctness are critical.</p><p>One typical use case concerns cryptographic primitives which must be very performant. The first use case that I√±igo Querejeta Azurmendi (Cardano Lead Cryptography Engineer) brought me consisted in replacing a cryptographic library used by <a href="https://github.com/input-output-hk/cardano-base" target="_blank" rel="noopener noreferrer"><code>cardano-base</code></a>. Namely, replacing <a href="https://github.com/input-output-hk/cardano-crypto/blob/develop/cbits/cryptonite_sha512.h" target="_blank" rel="noopener noreferrer"><code>cryptonite</code></a>, a library written in Haskell and C, with <a href="https://crates.io/crates/sha3" target="_blank" rel="noopener noreferrer"><code>sha3</code></a>, a Rust library (or &quot;crate&quot;).</p><blockquote><p><strong>Why FFI (Foreign Function Interface)?</strong></p><p>Solving the <a href="https://docs.rust-embedded.org/book/interoperability/" target="_blank" rel="noopener noreferrer">interoperability</a> problem means:</p><ol><li>designing a protocol that allows two codes written with different languages and using different runtime systems to communicate ;</li><li>designing tools and methods to build, to bundle, and to distribute such polyglot code bases (what developers fear most).</li></ol><p>As our main criterion is performance, we want a solution with a minimal overhead. In particular, we want to avoid the use of any solution that relies on syscalls (like I/Os) and on costly data (de)serialization.</p><p>It leads us to exclude solutions such as IPC (Inter-Process Communication), e.g., using <a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener noreferrer">Google Protobuf</a> over a <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener noreferrer">Unix Domain Socket</a>.</p><p>FFI looks like the right choice: no syscall, a foreign function call just behaves as a jump in memory and there is no extra data (de)serialization involved. The price to pay for this performance is that using the FFI requires special care to low-level calling conventions and memory management of the two involved systems. But we will come back to this topic later!</p><p><strong>To go further:</strong> you can learn more about how to use FFI in Rust by reading the <a href="https://doc.rust-lang.org/nomicon/ffi.html" target="_blank" rel="noopener noreferrer"><em>The Rustonomicon</em></a> (Unsafe Rust guide) dedicated section, or the dedicated <a href="http://jakegoulding.com/rust-ffi-omnibus/" target="_blank" rel="noopener noreferrer"><em>Rust FFI Omnibus</em></a> tutorial. The ANSSI (French government security agency) also writes about it in <a href="https://anssi-fr.github.io/rust-guide/07_ffi.html" target="_blank" rel="noopener noreferrer"><em>Secure Rust Guidelines</em></a> guide, and <em>Rust Embedded</em> book has an <a href="https://docs.rust-embedded.org/book/interoperability/rust-with-c.html" target="_blank" rel="noopener noreferrer">Interoperability with C</a> chapter. On the Haskell side, you way want to take a look at <a href="https://wiki.haskell.org/GHC/Using_the_FFI" target="_blank" rel="noopener noreferrer">GHC wiki</a> or read the dedicated <a href="https://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html" target="_blank" rel="noopener noreferrer"><em>Real-World Haskell</em></a> chapter!</p></blockquote><p>FFI is a feature that&#x27;s already offered by both <code>rustc</code> (Rust compiler) and <code>ghc</code> (Haskell compiler). It allows calling a Rust function from Haskell code (and vice versa). Both programming languages define an <code>extern</code> keyword that allows users to declare a function symbol that will only be resolved at <a href="https://doc.rust-lang.org/reference/linkage.html" target="_blank" rel="noopener noreferrer">linking</a> step. N.B. mangling of the function should also be disabled, in Rust it requires decorating functions with <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute" target="_blank" rel="noopener noreferrer"><code>#[no_mangle]</code></a> attribute.</p><p>So, what&#x27;s lacking in Haskell ecosystem? Let&#x27;s take a look at what kind of integration other languages offer with Rust:</p><ul><li>From <strong>C</strong> to Rust <a href="https://github.com/rust-lang/rust-bindgen" target="_blank" rel="noopener noreferrer"><code>rust-bindgen</code></a> ;</li><li>From Rust to <strong>C</strong> <a href="https://github.com/eqrion/cbindgen" target="_blank" rel="noopener noreferrer"><code>c-bindgen</code></a> and Rust to <strong>ECMAScript</strong>, <a href="https://github.com/rustwasm/wasm-bindgen" target="_blank" rel="noopener noreferrer"><code>wasm-bindgen</code></a> ;</li><li>Both from and to Rust with <strong>C++</strong> <a href="https://github.com/dtolnay/cxx" target="_blank" rel="noopener noreferrer"><code>cxx</code></a> and <strong>Python</strong> <a href="https://github.com/PyO3/pyo3" target="_blank" rel="noopener noreferrer"><code>PyO3</code></a>.</li></ul><p>This list isn&#x27;t exhaustive but give you a hint, all these projects are about generating bindings (bindgen)!</p><blockquote><p><strong>Why bindgen (bindings code generation)?</strong></p><p>Let&#x27;s sum it up by: <em>&quot;A good FFI is an FFI that you don&#x27;t write ‚Ä¶&quot;</em></p><p>FFI are like a blind spot in your type system. Writing them manually is both frankly painful and really dangerous, as your compiler will not warn you about non-matching interfaces.</p><p>Binding generation comes to the rescue by considerably reducing the room for human errors. As a bonus, it also makes maintainers&#x27; life easier thanks to a smaller and more readable code base.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="example">Example<a class="hash-link" href="#example" title="Direct link to heading">‚Äã</a></h2><p>Let&#x27;s start with a minimal example: automatically generating bindings allowing Haskell codes to call a given Rust function. It is simply done by annotating the Rust function as follows:</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">use hs_bindgen::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[hs_bindgen(greetings :: CString -&gt; IO ())]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn greetings(name: &amp;str) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Hello, {name}!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>‚Ä¶ it will be expanded to (you can try yourself with <a href="https://github.com/dtolnay/cargo-expand" target="_blank" rel="noopener noreferrer"><code>cargo expand</code></a>):</p><div class="codeBlockContainer_I0IT language-rust theme-code-block"><div class="codeBlockContent_wNvx rust"><pre tabindex="0" class="prism-code language-rust codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">use hs_bindgen::*;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fn greetings(name: &amp;str) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    println!(&quot;Hello, {name}!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#[no_mangle] // Mangling makes symbol names more difficult to predict.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             // We disable it to ensure that the resulting symbol is really `__c_greetings`.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern &quot;C&quot; fn __c_greetings(__0: *const core::ffi::c_char) -&gt; () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // `traits` module is `hs-bindgen::hs-bindgen-traits`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // n.b. do not forget to import it, e.g., with `use hs-bindgen::*`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    traits::ReprC::from(greetings(traits::ReprRust::from(__0),))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>‚Ä¶ and will also generate the following Haskell code:</p><div class="codeBlockContainer_I0IT language-haskell theme-code-block"><div class="codeBlockContent_wNvx haskell"><pre tabindex="0" class="prism-code language-haskell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">-- This file was generated by `hs-bindgen` crate and contains C FFI bindings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- wrappers for every Rust function annotated with `#[hs_bindgen]`</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{-# LANGUAGE ForeignFunctionInterface #-}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- Why not rather using `{-# LANGUAGE CApiFFI #-}` language extension?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- * Because it&#x27;s GHC specific and not part of the Haskell standard:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--   https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/ffi.html ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- * Because the capabilities it gave (by rather works on top of symbols of a C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--   header file) can&#x27;t work in our case. Maybe we want a future with an</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--   {-# LANGUAGE RustApiFFI #-} language extension that would enable us to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--   work on top of a `.rs` source file (or a `.rlib`, but this is unlikely as</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--   this format has purposely no public specification).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{-# OPTIONS_GHC -Wno-unused-imports #-}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module Greetings (greetings) where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Data.Int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Data.Word</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Foreign.C.String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Foreign.C.Types</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import Foreign.Ptr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">foreign import ccall unsafe &quot;__c_greetings&quot; greetings :: CString -&gt; IO (())</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In Rust, <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#using-extern-functions-to-call-external-code" target="_blank" rel="noopener noreferrer"><code>extern</code></a> is an alias to <code>extern &quot;C&quot;</code> that stands for ‚Äúuse the C call convention‚Äù rather than <code>extern &quot;Rust&quot;</code> that use the Rust one, which is the default implicitly used.</p><blockquote><p><strong>Why C ABI (Application Binary Interface)?</strong></p><p>First, GHC currently doesn&#x27;t know anything about Rust calling convention, while it does about C&#x27;s one: C&#x27;s calling convention is the <a href="https://en.wikipedia.org/wiki/Mediterranean_Lingua_Franca" target="_blank" rel="noopener noreferrer"><em>lingua franca</em></a> of <code>rustc</code>/<code>ghc</code>.</p><p>Additionally, the Rust <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi" target="_blank" rel="noopener noreferrer">ABI</a> (call-convention and types <a href="https://cheats.rs/#memory-layout" target="_blank" rel="noopener noreferrer">memory layout</a>) isn‚Äôt stable. That means that it‚Äôs specified internally but could be broken by any <code>rustc</code> minor release, building a software on top of it is by definition a ‚Äúhack‚Äù ‚Ä¶ If we think it‚Äôs worth it, we would have to perform our bindgen against a given <code>rustc</code> version (and that would be really laborious to maintain). So, do not fear the C ABI because, at least, it is stable!</p><p><strong>To go further:</strong> I invite you to read <em><a href="https://viruta.org/rust-stable-abi.html" target="_blank" rel="noopener noreferrer">‚ÄúRust does not have a stable ABI‚Äù</a></em> by Federico Mena Quintero: a blog post discussing how much the absence of Rust stable ABI isn&#x27;t a big deal in the context of GTK development. Highlighting that <em><a href="https://faultlore.com/blah/swift-abi/" target="_blank" rel="noopener noreferrer">‚ÄúHow Swift Achieved Dynamic Linking Where Rust Couldn&#x27;t‚Äù</a></em> by Aria Beingessner isn&#x27;t so far from <a href="https://gi.readthedocs.io/en/latest/" target="_blank" rel="noopener noreferrer"><code>GObject</code> Introspection</a> strategy!</p></blockquote><h2 class="anchor anchorWithStickyNavbar_mojV" id="implementation">Implementation<a class="hash-link" href="#implementation" title="Direct link to heading">‚Äã</a></h2><p>The previous code example highlighted that we rely on two constructs: an attribute procedural macro <a href="https://github.com/yvan-sraka/hs-bindgen" target="_blank" rel="noopener noreferrer"><code>#[hs_bindgen]</code></a>, and (internally) <code>ReprRust</code> and <code>ReprC</code> traits.</p><blockquote><p><strong>Why use a Rust macro?</strong></p><p>Binding code generation could have been achieved using an external tool, e.g., <code>cbindgen</code> parses Rust code (before macro expansion) and deduces C function signatures.</p><p>But instead we decided to define a custom macro (like <code>cxx</code>, <code>wasm-bindgen</code>, and <code>PyO3</code> do), and so we require the user to depend on a custom crate.</p><p>The reason is that we want generated bindings to always match the source code used for their generation. By using a macro we enforce binding generation during the build process and bindings can&#x27;t get out-of-sync.</p><p><strong>To go further:</strong> <code>cbindgen</code> has a major limitation in that it does not understand Rust&#x27;s module system or namespacing. As mentioned in its <a href="https://github.com/eqrion/cbindgen/blob/master/docs.md#writing-your-c-api" target="_blank" rel="noopener noreferrer">documentation</a>, this means that if <code>cbindgen</code> sees that it needs the definition for <code>MyType</code> and there exists two things in your project with the type name <code>MyType</code>, it won&#x27;t know what to do. Rather, using the framework implemented here for <code>hs-bindgen</code> would allow us to provide a better <code>c-bindgen</code> implementation.</p></blockquote><p><code>ReprRust</code> and <code>ReprC</code> traits respectively ensure that the arguments and return value of exposed function respect a set of given safety rules. As a recall, Rust&#x27;s traits are similar to Haskell&#x27;s typeclasses: it‚Äôs a way to define a contract for a type, specifying a set of methods that the type must implement. This allows for generic programming, where a function or data structure can operate on any type that implements the given set of traits.</p><p>Wrapping user types by these traits have several benefits:</p><ul><li><p>Unsupported types are nicely reported as <em>‚Äúthe trait <code>ReprRust&lt;T&gt;</code> is not implemented for <code>U</code>‚Äù</em> error (that suggest other types that the trait implement to the user);</p></li><li><p>The user can extensively always implement these traits for arbitrary types ;</p></li><li><p>Provided traits implementation for <code>std</code> types take care of memory management ;</p></li><li><p>Traits improve a lot of ergonomics by implicitly and safely casting a given type to an FFI-safe one.</p></li></ul><blockquote><p><strong>What&#x27;s an FFI-safe type?</strong></p><p><code>rustc</code> will complain if a function prefixed by <code>extern</code> keyword use as arguments types that are not FFI-safe. FFI-safe types guarantee that a type has a <a href="https://doc.rust-lang.org/reference/type-layout.html" target="_blank" rel="noopener noreferrer">specified layout</a> (memory representation) by e.g. having a <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc" target="_blank" rel="noopener noreferrer"><code>#[repr(C)]</code></a> compiler attribute, for the given C call convention.</p></blockquote><p><strong>To go further:</strong> the memory management strategy is freeing the value is the role of the receiver (which has ‚Äúownership‚Äù of it). This means that values returned by Rust functions aren&#x27;t <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" target="_blank" rel="noopener noreferrer"><code>dropped</code></a> by Rust but rather should be <a href="https://hackage.haskell.org/package/base/docs/Foreign-Marshal-Alloc.html" target="_blank" rel="noopener noreferrer"><code>freed</code></a> on the Haskell side!</p><p><strong>EDIT:*</strong> Thanks to community feedbacks from Merijn Verstraaten, I just released <code>hs-bindgen</code> v0.8.0 that now generates <code>safe</code> Haskell foreign imports by default! You can still generate <code>unsafe</code> bindings simply by prefixing a function name like <code>#[hs_bindgen(unsafe NAME :: TYPE)]</code> in Rust attribute macro. I invite you to read <em><a href="https://frasertweedale.github.io/blog-fp/posts/2022-09-23-ffi-safety-and-gc.html" target="_blank" rel="noopener noreferrer">‚ÄúFFI safety and GC‚Äù</a></em> by Fraser Tweedale or GHC&#x27;s users guide to understand the differences between Haskell <code>unsafe</code>/<code>safe</code> keywords.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="devx">DevX<a class="hash-link" href="#devx" title="Direct link to heading">‚Äã</a></h2><p><a href="https://github.com/yvan-sraka/cargo-cabal" target="_blank" rel="noopener noreferrer"><code>cargo-cabal</code></a> is a CLI tool that helps you, in one simple command, turn a Rust crate into a Haskell Cabal library!</p><p>I was heavily inspired by the developer experience that offers <a href="https://rustwasm.github.io/docs/wasm-pack/" target="_blank" rel="noopener noreferrer"><code>wasm-pack</code></a> or <a href="https://github.com/PyO3/maturin" target="_blank" rel="noopener noreferrer"><code>maturin</code></a>: launched in any Rust project folder. These tools help the user interactively tweak their <code>Cargo.toml</code> package file and generate the build files needed by Node.js <code>npm</code> or Python <code>setuptools</code>.</p><p>What <code>cargo-cabal</code> actually does is:</p><ul><li><p>Ask the user to add <code>crate-type = [&quot;staticlib&quot;]</code> (or <code>&quot;cdylib&quot;</code>, dynamic libraries require an extra <a href="https://github.com/yvan-sraka/cargo-cabal/blob/main/src/build.rs" target="_blank" rel="noopener noreferrer"><code>build.rs</code></a> file that is generated by <code>cargo-cabal</code>) to their <code>Cargo.toml</code> file;</p></li><li><p>Generate a custom <code>X.cabal</code> linking <code>rustc</code> output as <code>extra-librairies</code>, and either a (<a href="https://github.com/nix-community/naersk" target="_blank" rel="noopener noreferrer"><code>naersk</code></a> and <a href="https://github.com/input-output-hk/haskell.nix" target="_blank" rel="noopener noreferrer"><code>haskell.nix</code></a> based) <code>flake.nix</code> or a <a href="https://github.com/yvan-sraka/cargo-cabal/blob/main/src/Setup.lhs" target="_blank" rel="noopener noreferrer"><code>Setup.lhs</code></a> Cabal build script (to work around this <a href="https://github.com/haskell/cabal/issues/2641" target="_blank" rel="noopener noreferrer">issue</a>).</p></li></ul><p><strong>To go further:</strong> <code>stack</code> isn&#x27;t supported yet, but we could easily imagine a <code>cargo-stack</code> binary that just wraps a <code>cargo-cabal --stack</code> CLI option!</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="whats-next">What&#x27;s next?<a class="hash-link" href="#whats-next" title="Direct link to heading">‚Äã</a></h2><p><a href="https://github.com/yvan-sraka/cargo-cabal" target="_blank" rel="noopener noreferrer"><code>cargo-cabal</code></a> and <a href="https://github.com/yvan-sraka/hs-bindgen" target="_blank" rel="noopener noreferrer"><code>hs-bindgen</code></a> combined are less than 1000 LoC, they also support Rust <code>#[no_std]</code> code, and I would be glad to keep them as <a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener noreferrer">KISS</a> and modular as possible. But there is still room for improvements, e.g., by adding trait implementations for more Rust <code>std</code> types, or possibly supporting <code>async</code> functions with <a href="https://github.com/oxalica/async-ffi" target="_blank" rel="noopener noreferrer"><code>async-ffi</code></a>?!</p><p>Furthermore, It‚Äôs also nice to give a sneak peek on what others do for comparison: <strong>OCaml</strong> <a href="https://docs.rs/ocaml" target="_blank" rel="noopener noreferrer">allows extensions to be written directly in Rust with no C stubs</a>, this work was supported from the <a href="http://ocaml-sf.org/" target="_blank" rel="noopener noreferrer">OCaml Software Foundation</a> and you can find <a href="http://github.com/zshipko/ocaml-rust-starter" target="_blank" rel="noopener noreferrer">a basic example project here</a>. It offers <a href="https://github.com/simplestaking/ocaml-interop" target="_blank" rel="noopener noreferrer">safe OCaml/Rust interoperability</a>, meaning utilities to convert ADTs (Algebraic Data Types) and functions using them.</p><p>It would be delightful to get as far as having custom preludes in Haskell binding code, that offers Rust type layout in Haskell. For example, Rust <a href="https://doc.rust-lang.org/book/ch04-03-slices.html" target="_blank" rel="noopener noreferrer">slices</a> are not an existing concept in C but could be easily represented as an FFI-safe struct.</p><p>Finally, it‚Äôs worth mentioning that there are also proposals to improve the interface between Haskell programs requiring Rust libraries, including this Cabal <a href="https://github.com/haskell/cabal/issues/7906" target="_blank" rel="noopener noreferrer">RFC</a>. As a reminder, the implementation proposed here does not provide support for Haskell dependencies in Rust project yet, but there is a previous <a href="https://github.com/mgattozzi/curryrs" target="_blank" rel="noopener noreferrer">unmaintained attempt</a> by Michael Gattozzi to bring Haskell runtime support to Rust binaries. We should also keep a close look on the Rust RFC that offers to introduce a <code>#[repr(interop)]</code> attribute: <a href="https://github.com/rust-lang/rust/pull/105586" target="_blank" rel="noopener noreferrer">Experimental feature gate proposal <code>interoperable_abi</code></a>.</p><p>I would like to thank <a href="https://github.com/doyougnu" target="_blank" rel="noopener noreferrer">@doyougnu</a>, <a href="https://github.com/hsyl20" target="_blank" rel="noopener noreferrer">@hsyl20</a>, <a href="https://github.com/govanify" target="_blank" rel="noopener noreferrer">@govanify</a>, and <a href="https://github.com/iquerejeta" target="_blank" rel="noopener noreferrer">@iquerejeta</a> for their reviews and for their helpful suggestions.</p><p>Thanks for reading, feel free to experiment with this proof of concept and to provide feedback on GitHub!</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/cabal">cabal</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/rust">rust</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/bindgen">bindgen</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/input-output-hk/engineering/tree/master/blog/2023-01-26-hs-bindgen-introduction.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/2023-01-26-ghc-update"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">GHC DevX Update 2023-01-26</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/2023-01-24-javascript-browser-tutorial"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Using GHC&#x27;s JavaScript Backend in the Browser</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#context" class="table-of-contents__link toc-highlight">Context</a></li><li><a href="#example" class="table-of-contents__link toc-highlight">Example</a></li><li><a href="#implementation" class="table-of-contents__link toc-highlight">Implementation</a></li><li><a href="#devx" class="table-of-contents__link toc-highlight">DevX</a></li><li><a href="#whats-next" class="table-of-contents__link toc-highlight">What&#39;s next?</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/iog_eng" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://iohk.io/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">IOG Blog</a></li><li class="footer__item"><a href="https://github.com/input-output-hk/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ¬© 2024 IOG Engineering, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.b773a5bf.js"></script>
<script src="/assets/js/main.1356801f.js"></script>
</body>
</html>