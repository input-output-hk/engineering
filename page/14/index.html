<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="IOG Engineering RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="IOG Engineering Atom Feed">
<link rel="alternate" type="application/json" href="/feed.json" title="IOG Engineering JSON Feed"><title data-react-helmet="true">Blog | IOG Engineering</title><meta data-react-helmet="true" property="og:title" content="Blog | IOG Engineering"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="description" content="Blog"><meta data-react-helmet="true" property="og:description" content="Blog"><meta data-react-helmet="true" property="og:url" content="https://engineering.iog.io/page/14"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_posts_list"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://engineering.iog.io/page/14"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/page/14" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://engineering.iog.io/page/14" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.10ad4647.css">
<link rel="preload" href="/assets/js/runtime~main.71b3dbef.js" as="script">
<link rel="preload" href="/assets/js/main.602e5b06.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/iohk-logo.jpg" alt="IOG" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Recent</a><a class="navbar__item navbar__link" href="/tags">Tags</a><a class="navbar__item navbar__link" href="/archive">Archive</a></div><div class="navbar__items navbar__items--right"><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-01-24-javascript-browser-tutorial">Using GHC&#x27;s JavaScript Backend in the Browser</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2023-01-12-ghc-update">GHC DevX Update 2023-01-12</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-12-13-ghc-js-backend-merged">JavaScript backend merged into GHC</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-09-28-introduce-q-d">Model-Based Testing with QuickCheck</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/2022-09-23-ghcjs-heap-representation">GHCJS heap representation</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_rzP5" itemprop="headline"><a itemprop="url" href="/2022-05-17-javascript-template-haskell-external-interpreter">JavaScript, Template Haskell and the External Interpreter</a></h2><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2022-05-17T00:00:00.000Z" itemprop="datePublished">May 17, 2022</time> Â· <!-- -->7 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a itemprop="url"><span itemprop="name">Luite Stegeman</span></a></div><small class="avatar__subtitle" itemprop="description">Haskell DevX Engineer @ IOG</small></div></div></div></div></header><div class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_mojV" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">â€‹</a></h2><p>At IOG DevX we have been working on integrating various bits of GHCJS into GHC, with the goal of having a fully working JavaScript backend for the 9.6 release. For some parts this has mostly consisted of an update of the code to use the newer GHC API and dependencies. Other bits, like the Template Haskell runner, need more work.</p><p>This post gives an overview of the existing approaches for running Template Haskell in GHC based cross compilers and our plan for the JavaScript backend. Hopefully we can revisit this topic once all the work has been done, and see what exactly we ended up with.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-ghcjs-template-haskell-runner">The GHCJS Template Haskell Runner<a class="hash-link" href="#the-ghcjs-template-haskell-runner" title="Direct link to heading">â€‹</a></h2><p>When I first worked on Template Haskell (TH) support for GHCJS, there was no mechanism to combine Template Haskell with cross compilation in GHC.</p><p>Normally, Template Haskell is run by loading library code directly into the GHC process and using the bytecode interpreter for the current module. Template Haskell can directly access GHC data structures through the <code>Q</code> monad. Clearly this would not be possible for GHCJS: We only have JavaScript code available for the libraries and the organization of the JavaScript data structures is very different from what GHC uses internally.</p><p>So I had to look for an alternative. Running Template Haskell consists of two parts:</p><ol><li>loading/executing the TH code</li><li>handling compiler queries from the TH code, for example looking up names or types</li></ol><p>Running the TH code can be done by first compiling the Haskell to JavaScript and then using the JavaScript <code>eval</code> feature.</p><p>Template Haskell code can query the compiler using the <code>Quasi</code> typeclass. I noticed that none of the methods required passing around functions or complicated data structures, so it would be possible to serialize each request and response and send it to another process.</p><p>So I went ahead and implemented this approach with a script <code>thrunner.js</code> to load and start the code in a node.js server, a message type with serialization, and a new instance of the <code>Quasi</code> typeclass to handle the communication with the compiler via the messages. This is still what&#x27;s in use by GHCJS to this day. Every time GHCJS encounters Template Haskell, it starts a <code>thrunner</code> process and the compiler communicates with it over a pipe.</p><p>After starting <code>thrunner.js</code> GHCJS sends the Haskell parts of the Template Haskell runnner to the script. This includes the runtime system and the implementation of the <code>Quasi</code> typeclass and communication protocol. After that, the TH session starts. A typical TH session looks as follows:</p><table><thead><tr><th align="left">Compiler</th><th align="left">thrunner</th></tr></thead><tbody><tr><td align="left"><code>RunTH THExp &lt;js code&gt; &lt;source location&gt;</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>LookupName (Just &lt;name-string&gt;)</code></td></tr><tr><td align="left"><code>LookupName&#x27; (Just &lt;name&gt;)</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>Reify &lt;name&gt;</code></td></tr><tr><td align="left"><code>Reify&#x27; &lt;name-info&gt;</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>RunTH&#x27; &lt;result&gt;</code></td></tr><tr><td align="left"><code>RunTH THDec &lt;js code&gt; &lt;source location&gt;</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>AddTopDecls &lt;declarations&gt;</code></td></tr><tr><td align="left"><code>AddTopDecls&#x27;</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>RunTH&#x27; &lt;result&gt;</code></td></tr><tr><td align="left"><code>FinishTH True</code></td><td align="left"></td></tr><tr><td align="left"></td><td align="left"><code>FinishTH&#x27; &lt;memory-consumption&gt;</code></td></tr></tbody></table><p>Each message is followed up by a corresponding reply. For example, a <code>LookupName&#x27;</code> response follows a <code>LookupName</code> request and a <code>RunTH</code> message will eventually generate a <code>RunTH&#x27;</code> result. The first <code>RunTH</code> message contains the compiled JavaScript for the Template Haskell code, along with its dependencies. Each subsequent <code>RunTH</code> only includes dependencies that have not already been sent.</p><p>The <code>thrunner</code> process stays alive during the compilation of at least an entire module, allowing for persistent state (<code>putQ</code>/<code>getQ</code>).</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-ghc-external-interpreter">The GHC External Interpreter<a class="hash-link" href="#the-ghc-external-interpreter" title="Direct link to heading">â€‹</a></h2><p>If we build a Haskell program with (cost centre) profiling, the layout of our data structures changes to include bookkeeping of cost centre information. This means that we need a special profiling runtime system to run this code.</p><p>What can we do if we want to run our profiled build in GHCi or Template Haskell? We cannot load compiled profiling libraries into GHC directly; its runtime system expects non-profiled code. We could use a profiled version of the compiler itself, but this would make all compilation very slow. Or we could somehow separate the profiled code of our own program from the non-profiled code in the compiler.</p><p>This was Simon Marlow&#x27;s motivation for adapting the GHCJS <code>thrunner</code> approach, integrating in GHC and extending it it to support GHCi and bytecode. This functionality can be activated with the <code>-fexternal-interpreter</code> flag and has been available since GHC version 8.0.1. When the external interpreter is activated, GHC starts a separate process, <code>iserv</code> (customizable with the <code>-pgmi</code> flag) which has the role analogous to the <code>thrunner</code> script for GHCJS.</p><p>Over time, the <code>iserv</code> code has evolved with GHC and has been extended to include more operations. By now, there are quite a few differences in features:</p><table><thead><tr><th align="left">Feature</th><th align="center">thrunner</th><th align="center">iserv</th></tr></thead><tbody><tr><td align="left">Template Haskell support</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="left">GHCi</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="left">Debugger</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="left">Bytecode</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="left">Object code</td><td align="center">through pipe</td><td align="center">from file</td></tr><tr><td align="left">Object code linking</td><td align="center">compiler</td><td align="center">iserv process</td></tr></tbody></table><p><code>thrunner</code> is not quite as complete as <code>iserv</code>: It lacks GHCi and the debugger, and there is no bytecode support. But these features are not essential for basic Template Haskell.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="proxies-and-bytecodes">Proxies and Bytecodes<a class="hash-link" href="#proxies-and-bytecodes" title="Direct link to heading">â€‹</a></h2><p>We have now seen two systems for running Template Haskell code outside the compiler process: The original GHCJS <code>thrunner</code> and the extended GHC <code>iserv</code>.</p><p>Clearly it isn&#x27;t ideal to have multiple &quot;external interpreter&quot; systems in GHC, therefore we plan to switch from <code>thrunner</code> to <code>iserv</code> for the upcoming JavaScript GHC backend. We don&#x27;t need the debugger or GHCi support yet, but we do need to adapt to other changes in the infrastructure. So what does this mean in practice?</p><p>The biggest change is that we have to rework the linker: <code>thrunner</code> does not contain any linking logic by itself: GHCJS compiles everything to JavaScript and sends compiled code to the <code>thrunner</code> process, ready to be executed. In contrast, <code>iserv</code> has a loader for object and archive files. When dependencies need to be loaded into the interpreter, GHC just gives it the file name.</p><p>Another change is using the updated message types. In the <code>thrunner</code> session example above we could see that each message is paired with a response. For example a <code>RunTH&#x27;</code> response always follows a <code>RunTH</code> message, with possibly other messages in between. <code>iserv</code> has an interesting approach for the <code>Message</code> datatype: Instead of having pairs of data constructors for each message and its response, <code>iserv</code> has a GADT <code>Message a</code>, where the <code>a</code> type parameter indicates the expected response payload for each data constructor.</p><p>During development of the <code>thrunner</code> program it turned out to be very useful to save and replay Template Haskell sessions for debugging purposes. We&#x27;d like to do this again, but now saving the message in a readable/writable format. Since we&#x27;re dealing with JavaScript, JSON appears to be the obvious choice.</p><p>Our plan is to have an <code>iserv</code> implementation that consists of a JavaScript part that runs in node.js and a proxy process to handle communication with GHC. The proxy process converts the messages between GHC&#x27;s own (<code>binary</code> based) serialization format and JSON. The proxy process is relatively simple, but it does reveal one downside of the new GADT based message types: A proxy is stateful. We must always know which message we have sent to convert the response back from JSON to <code>binary</code>.</p><p>It&#x27;s not yet known whether we will implement a full bytecode interpreter. We expect it to become clear during implementation whether we can get away without one early on.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="conclusion">Conclusion<a class="hash-link" href="#conclusion" title="Direct link to heading">â€‹</a></h2><p>We have seen how Template Haskell and GHCi code can be run outside the GHC process for profiling or cross compiling, with both the <code>thrunner</code> approach in GHCJS and the newer <code>iserv</code> in GHC.</p><p>We at IOG DevX are working on switching to the <code>iserv</code> infrastructure for the upcoming GHC JavaScript backend, which involves a substantial rewrite, mainly because of differences in linking. This is a work in progress, and we intend to revisit this topic in another blog post once the final design has been implemented.</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/ghc-ghcjs-javascript-tooling-profiling">ghc ghcjs javascript tooling profiling</a></li></ul></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/page/13"><div class="pagination-nav__label">Newer Entries</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/page/15"><div class="pagination-nav__label">Older Entries</div></a></div></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/iog_eng" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a href="https://iohk.io/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">IOG Blog</a></li><li class="footer__item"><a href="https://github.com/input-output-hk/" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright Â© 2023 IOG Engineering, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.71b3dbef.js"></script>
<script src="/assets/js/main.602e5b06.js"></script>
</body>
</html>