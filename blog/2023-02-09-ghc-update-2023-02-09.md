---
slug: 2023-02-09-ghc-update
title: GHC DevX Update 2023-02-09
authors: [sylvain,doyougnu,luite,josh]
tags: [ghc]
---

This is the third biweekly update of the IOG GHC DevX team.
You can read the previous one [here](https://engineering.iog.io/2023-01-26-ghc-update).

## JavaScript backend

### Template Haskell

Luite: fixed one-shot

Sylvain: cleanup the MR, added documentation

https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9779


### JavaScript backend CI

Jeff: JavaScript backend CI was [finally
merged](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9552)! Now that we
have CI we are unblocked on several fronts, such as, implementing [faster
arithmetic](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9825) and fixing
some [async
exceptions](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9879). In
general, we can now have confidence that our work is progressing the JavaScript
backend to a better state.

### FileStat

Josh: rebased with CI. Merged?

https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9755
https://gitlab.haskell.org/ghc/ghc/-/issues/22573

### JavaScript RTS refactor

Josh: same

https://gitlab.haskell.org/ghc/ghc/-/issues/22822
https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9794

### Warnings

Luite:

We accidently removed the check for the "javascript" calling convention on
foreign imports, allowing this convention to be wrongly used on native platform.
Fixed in:
https://gitlab.haskell.org/ghc/ghc/-/issues/22774
https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9880

### Fix for asynchronous exceptions

Luite:

https://gitlab.haskell.org/ghc/ghc/-/issues/22836
https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9879

### Integer performance

Evaluating the following expression is very slow in general but especially with
the JS backend:

```haskell
1 `shiftL` (1 `shiftL` 20) :: Integer
```

We've had to mark a test computing this as broken on CI because it triggers a
timeout error. Luckily the identification of slow operations is easy with
JavaScript profiling tools (see graphs in
https://gitlab.haskell.org/ghc/ghc/-/issues/22835) and we know that `Word32`
primops are the culprit in this case.

Sylvain started replacing the uses of JavaScript's `BigInt` in the
implementation of these primops with usual JavaScript `numbers`.
See https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9825

### JavaScript EDSL

Jeff:

### Blog posts

Luite:

Sylvain: one about TH new implementation?

### Documentation

Jeff: release notes mention

Sylvain et al.: users guide chapter


## Compiler performance

### More-strict `break`

Josh: ticket opened. MR to add to base would require a CLC proposal.

https://gitlab.haskell.org/ghc/ghc/-/issues/22865
https://gitlab.haskell.org/ghc/ghc/-/merge_requests/9868

Motivation: use case in GHC. Ticky profiles

### Constant folding for division operations

While looking into his old merge requests still opened, Sylvain nerd-snipped
himself into fixing constant folding rules for division operations (see
[#22152](https://gitlab.haskell.org/ghc/ghc/-/issues/22152)).

MR [!8956](https://gitlab.haskell.org/ghc/ghc/-/merge_requests/8956) adds the
following rewrite rules:

```
   case quotRemInt# x y of
     (# q, _ #) -> body
  ====>
   case quotInt# x y of
     q -> body


   case quotRemInt# x y of
     (# _, r #) -> body
  ====>
   case remInt# x y of
     r -> body


  For all primitive numerical types:

    (x `quot` l1) `quot` l2
     | l1 /= 0
     | l2 /= 0
     | l1*l2 doesn't overflow/underflow
   ====>
    x `quot` (l1 * l2)
```

It also makes some division primops (Word64/Int64 Quot/Rem, WordQuotRem2Op)
ok-for-speculation when the divisor is known to be non-zero, similarly to other
division primops. Otherwise the last rule wasn't firing in the added test
because we got the following Core (simplified for the presentation):

```haskell
case quotWord64# x# 10#Word64 of
    ds1 -> case quotWord64# ds1 20#Word64 of
        ds2 -> ...
```

and not:

```haskell
case quotWord64# (quotWord64# x# 10#Word64) 20#Word64 of
    ds2 -> ...
```
