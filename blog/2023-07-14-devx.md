---
slug: 2023-07-14-devx
title: The IOG Developer`s Experience Shell
authors: [yvan]
tags: [devx, haskell.nix, hix, iogx, nix]
---

# The IOG Developer's Experience Shell

The IOG's Developer Experience Shell, or `DevX` for short, is an opinionated development environment tailored for Haskell.
Built on top of Nix expressions, it provides a reproducible and seamless, full-featured developer shell with tools such as `cabal-install`, `ghc`, `hls`, and `hlint`.

The DevX shell's approach is a "one shell that fits all" solution for IOG's project needs.
This article aims to give you a technical deep dive on how to use it in your own Haskell project and how we managed such a substantial closure in a convenient way.

`DevX` is built upon `haskell.nix`, a framework for building Haskell packages with Nix.
In short, `haskell.nix` turns your Cabal or Stack project and its dependencies into a Nix expression.
We will explain how to use `haskell.nix` on its own using `hix`.

We will conclude by introducing `iogx`, a Flake Template for Haskell Projects that we use at IOG.

## Getting started

The `devx` GitHub repository provides a comprehensive [README](https://github.com/input-output-hk/devx#readme) that documents the different outputs that `flake.nix` provides.
But, as this article assumes you might have not so much knowledge of how to deal with Nix, we will quickly discuss three ergonomic ways of using this tool with no Nix knowledge required.

### Direnv

`direnv` is an quite handy tool that allows you to load/unload the development environment automatically based on your current directory.
It's an excellent way to avoid polluting your `.profile` or shell rc files.

You can learn how to install `direnv` [here](https://direnv.net).
You may then need to hook up direnv in your shell; you can consult the dedicated [`direnv` and `devx`](./docs/direnv.md) guide for detailed instructions on integration.

You will also need to have Nix installed to using DevX shell.
Then just add an `.envrc` file with the following content in the root of your project:
```
# https://github.com/nix-community/nix-direnv A fast, persistent use_nix/use_flake implementation for direnv:
if ! has nix_direnv_version || ! nix_direnv_version 2.3.0; then
  source_url "https://raw.githubusercontent.com/nix-community/nix-direnv/2.3.0/direnvrc" "sha256-Dmd+j63L84wuzgyjITIfSxSD57Tx7v51DMxVZOsiUD8="
fi
# https://github.com/input-output-hk/devx Slightly opinionated shared GitHub Action for Cardano-Haskell projects
use flake "github:input-output-hk/devx#ghc8107"
```
`DevX` supports a variety of compiler versions, typically the latest for each series from 8.10 to 9.6. Along with the core GHC version, [it also offers various flavours, denoted as suffixes to the compiler names](https://github.com/input-output-hk/devx#compilers-and-flavours).

The `nix-direnv` prefix is not necessary, but it's a good way to prevent Nix from garbage collecting your shell while the directory exists!

### GitHub Action

We also provide a `DevX` GitHub Action, leveraging a unique technique of pre-evaluating the closure of the development environment, compressing it, and uploading it to `ghcr.io`.
This approach drastically reduces the instantiation time of the developer shell, and will talk about it a bit more in details later in this article.

Here's how you might utilize the DevX GitHub Action in your workflow:
``` 
- name: Build
  uses: input-output-hk/actions/devx@latest
  with:
    platform: 'x86_64-linux'
    target-platform: '-windows'
    compiler-nix-name: 'ghc8107'
    minimal: false
    iog: true
- name: Build
  shell: devx {0}
  run: |
    cabal update
    cabal build
```

### VSCode DevContainer and GitHub CodeSpace

Finally, we also offer support for VSCode DevContainers and GitHub CodeSpaces.
To make the DevX developer shell available in a VSCode DevContainer or GitHub CodeSpace, simply add a file named `.devcontainer/devcontainer.json` with the following content:
```
{
   "image":"ghcr.io/input-output-hk/devx-devcontainer:ghc8107",
   "customizations":{
      "vscode":{
         "extensions":[
            "haskell.haskell"
         ],
         "settings":{
            "haskell.manageHLS":"PATH"
         }
      }
   }
}
```
You can follow the [Microsoft tutorial](https://code.visualstudio.com/docs/devcontainers/tutorial) to set-up your VSCode local DevContainer or you can give it a try by [opening a GitHub Codespace](https://codespaces.new/input-output-hk/cardano-base?quickstart=1) on [`cardano-base`](https://github.com/input-output-hk/cardano-base) repository!

## Benchmarking

To showcase the efficiency and speed that our download closure hack brings compared to a call to `nix develop`, we'll present a short benchmarking comparison.

What isn't measured is the time for evaluating the closure, compressing it, and uploading it to `ghcr.io`, as it's done by our CI and represents the caching part of the process.
We measure the speed of downloading, decompressing, and performing a `nix import` on the closure against the speed of `nix develop`, so we essentially save the time of the evaluation of the Nix expression:

**TODO: add the benchmarks ...**

## Hix

Hix is a command-line tool designed to facilitate the addition of `haskell.nix` support to existing Haskell projects.
You need Nix installed and configured with `experimental-features = [ "nix-command" "flakes" ];` (details can be found at the [NixOS Wiki](https://nixos.wiki/wiki/Flakes)).

### Initializing Hix and Using Nix

The `hix init` command adds a `flake.nix` and `nix/hix.nix` file to the project root.

Once this is done, you can utilize regular Nix tools.
For instance, to run `cabal build` on the `hello` package from Hackage, you would execute the following:
```shell
cabal unpack hello
cd hello-1.0.0.2
nix run "github:input-output-hk/haskell.nix#hix" -- init
nix develop
cabal build
```

You can view the contents of the flake using `nix flake show`.
To build a component with Nix, use `nix build .#hello:exe:hello`, and to build and run a component, `nix run .#hello:exe:hello` would be the command of choice.

### Installing Hix

Hix can be installed with the following command:

```shell
nix-env -iA hix -f https://github.com/input-output-hk/haskell.nix/tarball/master
```

To update Hix to the latest version, simply run `hix update`.

### Using Hix Commands

Commands like `hix develop`, `hix flake`, `hix build`, and `hix run` work similarly to their Nix counterparts.
However, instead of utilizing the `flake.nix`, a boilerplate Haskell.nix `flake.nix` file is added to `.hix-flake/flake.nix`.
This approach can be beneficial if the project already includes a `flake.nix` or if there's no intention to maintain one.

Once this step is done, you can execute commands without the need for `hix init`:

```shell
hix develop
hix flake show
hix build .#hello:exe:hello
hix run .#hello:exe:hello
```

### Using `hix-shell` and `hix-build`

The `hix-shell` and `hix-build` commands emulate the behaviour of `nix-build` and `hix-shell` if a boilerplate `default.nix` and `shell.nix` were present.
These commands are executed as follows:
```shell
hix-shell --run 'cabal build all'
hix-build -A hsPkgs.hello.components.exes.hello
```

Hix streamlines the use of Haskell.nix, offering an easier way to integrate it into your existing Haskell projects.

## IOGX: A Flake Template for Haskell Projects at IOG

IOGX is a flake template that offers a development experience for Haskell projects at IOG. Its vision is to provide a JSON-like, declarative interface to Nix, enabling developers unfamiliar with the Nix language to maintain and enhance the Nix sources independently with minimal effort.

### Getting Started with IOGX

Kick-start your project with IOGX by running the following command:
```
nix flake init --template github:input-output-hk/iogx
```
This command generates a `flake.nix` and a `nix` folder containing various file templates.
These files form the *filesystem-based* API of IOGX.

The next steps involve populating the templates in the `nix` folder, leaving `flake.nix` mostly untouched.
Based on the contents of the `nix` folder, IOGX populates your flake outputs.

### IOGX Features

IOGX comes packed with numerous features that enhance the Haskell development process:

- **GHC Build Matrices**: IOGX enables defining a set of GHC versions, for each of which it generates `devShells`, `packages`, `apps`, `checks`, and `hydraJobs`. These outputs also include profiled builds and Windows cross-compiled builds.

- **Extensible Development Shells**: Every `devShell` comes with a complete Haskell toolchain that can be easily extended with new packages, custom scripts, environment variables, and hooks.

- **Automatic Hydra Jobset**: By default, your `hydraJobs` will include every Haskell component in your project. Test suites will run in CI automatically.

- **Easy Code Formatting**: IOGX employs [`pre-commit-hooks`](https://github.com/cachix/pre-commit-hooks.nix) for source tree formatting. These hooks are easily configurable and run automatically in CI unless explicitly disabled.

- **Read The Docs Support**: If your project requires a [Read The Docs](https://readthedocs.org) site, IOGX will include the necessary tools and scripts and add the relevant derivations to CI.

To delve deeper into IOGX and its API, refer to the comprehensive [API Reference](https://github.com/input-output-hk/iogx#3-api-reference). IOGX aims to facilitate a pleasant and efficient development process for Haskell projects at IOG, minimizing the need for extensive Nix language knowledge.

## Final Thoughts

**TODO ...**
