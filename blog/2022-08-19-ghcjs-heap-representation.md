---
slug: 2022-08-19-ghcjs-heap-representation
title: GHCJS heap representation
date: August 19, 2022
authors: [ sylvain ]
tags: [ ghc, javascript ]
---

## Introduction

I recently gave a short presentation about heap objects representation in GHCJS and hence in the upcoming JS backend for GHC. This post is a summary of the content.

## Heap objects

GHC implements Haskell code evaluation by using graph reduction. As such Haskell
programs compiled by GHC use the heap mainly to store nodes of the graph to be
reduced.

Heap objects include:
- CON: boxed values (saturated constructor applications) with field values as payload
- FUN: functions with their free variables as payload
- THUNK: suspensions with their free variables as payload
- PAP: partial application to a FUN. FUN closure and already applied arguments
  as payload.
- IND: indirection to another heap object
- BLACKHOLE: used to overwrite a THUNK when it is being evaluated

GHC also stores other objects in the heap that are not related to graph
reduction: TSO, BCO, arrays, MutVar#, MVar#, TVar#, stacks and stack frames.

## Info tables

Many heap objects share the same properties: e.g. all `Int` CON objects have the
same object type, the same payload layout, the same entry code, etc.

Heap objects are split in two parts:
- info table: statically known properties (at compilation time) that can be
  shared by several heap objects
- heap object itself: dynamically allocated in the heap

Heap objects always have the same layout in the native code generated by GHC.
They are composed of:
- a pointer to an info table
- some words of payload

Heap traversal can be done by following the info table pointer of every heap
object to query the layout of the heap object payload.

Info tables contain a pointer to a function called "entry code" that can be
specific to each info table. With tables-next-to-code optimisation enabled, the
info table pointer is actually a pointer to this entry code and the info table
itself is stored in the words preceeding the entry code.

## Heap objects in JavaScript

GHCJS represents most heap objects with a JavaScript object having the following
fields:

```yaml
{ f, d1, d2, m, cc }
```

One question I had was: why don't we use a JS array instead of a JS object?
Arrays should be faster than objects (i.e. hashmaps), no? It turns out that
objects like this are optimised by JS engines using "hidden classes". That's why
they are usually more efficient than arrays for which bound checking must be
made. Also arrays are bigger because they need to store their size.

Let's now discuss the fields of the heap objects.

### f field

"f" is the equivalent of the info table pointer. It contains a JavaScript
function that is the entry code for the heap object.

Similarly to the tables-next-to-code optimisation discussed above, we use the
fact the JS functions are objects that can have properties to store the info
table fields as properties of the function itself.

Example of an info table / entry function:

```javascript
[Function: h$entry_function_xyz]
  { t    // (Int) object type
  , size // (Int) number of fields in payload (-1 if variable layout)
  , i    // (Array) fields layout (empty if variable layout)
  , n    // (String) object name for debug
  , a    // (Int) arity, constructor tag
  , r    // (Int) arity in number of JS variables
  , s    // (Array) static refs that must be kept alive (SRT)
  , m    // GC mark
  }
```

### d1, d2 fields

d1 and d2 fields contain the payload of the heap object.

As fewer or more than two values can be stored in the payload, the following
encoding is used to store them in two fiels:

| Payload      | d1       | d2                  |
|--------------|----------|---------------------|
| []           | null     | null                |
| [a]          | a        | null                |
| [a,b]        | a        | b                   |
| [a,b,c]      | a        | {d1=b,d2=c}         |
| [a,b,c,d...] | a        | {d1=b,d2=c,d3=d...} |

This encoding allows the heap objects to always have the same representation
with only two fields (d1 and d2). This is good for:

- performance: JS engine hidden classes optimisation mentioned above

- genericity: we can write generic functions (e.g. to copy a closure) that don't
  need to dynamically query the number of fields composing the payload.

### m field

The "m" field is used for reachability checking (~ garbage collection). GHCJS
can't rely on the JS engine to know when a heap object is collected, which is
necessary to implement weak references, finalizers, etc. It implements its own
heap traversal algorithm for this. The "m" field is used as a marker for this
algorithm (it will be the topic of a future blog post).

The "m" field is also used to implement the StableName feature. So it can be
either:

- a number: GC mark

- an object:
```javascript
[h$StableName]
  { m // GC mark
  , s // stable name unique id
  , ...
  }
```

### cc field

The "cc" field is the cost center associated to the heap object. This field is
only present when profiling mode is enabled.

## Other heap object representation

The generic heap object representation presented above is only used for some
objects that use an info table. Several other heap objects are
represented as usual JS objects and recognized with the `instanceof` operated.
For example a TSO is represented as a `h$Thread` object. These objects don't
have associated info tables.

Note that we could imagine every heap object being recognised with `instanceof`
(or by matching on the `constructor` property) by having one separate object
name for all heap objects. It would mean adding `h$Con`, `h$Thunk`, `h$Fun`,
`h$Pap`, `h$Blackhole`, and `h$StackFrame` objects. Then all the heap objects
could be treated in the same way. However these objects need to be overwritable
in place: a Thunk becomes a Fun/Con/Pap/Blackhole, etc. So they must be
instances of the same JS object.

### Optimised representation

Sometimes the generic heap object representation is unnecessary. For example, a
boxed `Int` would be represented as a `CON` heap object with the `Int#` in its
payload, represented as a JavaScript number value.

The only thing we can do with this heap object is to pass it around and to
extract its payload. As such, it is more memory efficient to directly pass the
payload (a JS number). The optimisation consists in doing this.

We can do this in JavaScript because we can use `typeof` on the heap object to
know if it is a JS object or not. It makes it possible to distinguish between
heap object representations. In comparison, we can't do this with the native
(non-JS) backend when we only have a pointer to a heap object: the pointer
doesn't carry the kind of value it points to, hence the pointed memory location
must be generic enough for this introspection to happen.
