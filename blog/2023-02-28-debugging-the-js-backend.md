---
slug: 2023-02-28-debugging-javascript-backend
title: Debugging the JavaScript Backend
date: February 28, 2023
authors: [ luite ]
tags: [ghc, javascript, debugging ]
---

## Introduction

I recently gave a short presentation on the topic of debugging the code produced by the GHC JavaScript backend to the GHC team at IOG. This blog post is a summary of the content.

## Debugging JavaScript

Browsers come with powerful development tools for JavaScript. In particular the chrome development tools are very useful for stepping through JavaScript code and inspecting data during the execution of a program. We can still use these development tools on the code generated by the GHC JavaScript backend, but due to the structure of the code, it can sometimes be difficult to figure out where exactly something goes wrong.

This blog post is an experience report that presents a couple of practical techniques for debugging various problems in the JavaScript code.

## Tracing Operations

Various components of the RTS have tracing options enabled by preprocessor definitions. For example weak reference operations can be traced by compiling the `rts` package with the `-DGHCJS_TRACE_WEAK` cpp option.

Currently, enabling the trace functionality requires rebuilding the `rts` package, while previously with GHCJS it was possible to enable the required tracing by just recompiling the final program. We will likely change this setup to include all tracing functionality in a debug rts liked when using the `-debug` flag, and easily modifyable global settings to enable or disable specific tracing modules.

All the tracing uses the `h$log` function which can be easily modified to redirect the output of the trace, for example tracing only to an array (which can be watched by the JavaScript debugger) and keeping only the last `n` entries.

## Dealing With Tail Calls

All Haskell code is called from a main loop that looks as follows:

```javascript
    while(!haveToYield(c)) {
        c = c();
        c = c();
        c = c();
        ...
    }
```

The main loop keeps calling the funtion returned by the previous call, until the thread has to stop for some reason. This means that the JavaScript call stack isn't very useful for figuring out where something goes wrong in our code: It only contains function calls up to the main loop. If some `c` fails, we don't know much about what calls lead up to the error condition!

However the main loop does give us a good opportunity to add some tracing: If we log each `c = c();` call (the function name and possibly the status of the Haskell stack and some relevant global variables) we can reconstruct more easily which conditions resulted in the error. The RTS provides the useful `h$logCall` and `h$logStack` helper functions for this.

Logging main loop calls generates a lot of output, even more so than tracing specific RTS features, so it's probably necessary to redirect and/or truncate the output of `h$log` here.

It's often useful to make the `haveToYield` condition deterministic, by not taking wall clock time into account. This runs each thread until it blocks or finishes (`c === h$reschedule`). That makes runs reproducible, even if more than one Haskell thread is involved.

## Data Corruption

Function call traces are useful if an error condition manifests itself relatively close to the initial problem. But what if our program crashes on some malformed data. We need to know which what caused to data to be malformed in the first place!

### Representation Checks

One strategy is trying to catch the error earlier by introducing more checks to verify that the types of our data are what we expect. JavaScript is dynamically typed, so the browser will happily run our code, even if we use a `number` in a place where we'd normally use an `object`.

When generating code however, we have a lot more knowledge. When we access data fields of a data constructor or closure, we know which type of data we expect. It's straightforward to modify the code generator to add a test after each field access. The file `verify.js` in the `rts` package has some helper functions for this.

### Sequence Numbering

Representation verification does not always help us find the origin of the problem. Sometimes we'd like to know where some heap object was allocated. We can do this by combining function call tracing with sequence numbers for allocation. After allocating a Haskell heap object we call a helper function that gives the object a unique sequence number. When we run into the error condition with the incorrect data, we inspect its sequence number and match it up with the function that produced it.

Then in another run of the program we can step through the function that produced the wrong data using the JavaScript debugger.

## Debugging Weak References

Sometimes we don't want to debug a problem where the data itself is wrong, but where the data is used at the wrong time. For the JavaScript backend this issue comes up with the storage manager that keeps track of weak references.

The weak references garbage collector keeps track of every Haskell value that is still reachable from the Haskell runtime system. This means that if a Haskell value is considered to be unreachable by XXX XXX.

## Bisection

Sometimes we have a working reference implementation and an optimized implementation in which we want to fix some problem. If our optimization is a more efficient implementation of a specific primop, then we probably know where to look for the problem. But if our optimization is a rewrite pass of all code, things can get a lot more difficult.

The JavaScript optimizer is such a rewrite pass. It takes JavaScript code and rewrites it to a more efficient and compact form.

The pass looks conceptually like this:

```javascript
// input
f() {
    // original function body
}

// output
f() {
    // optimized function body
}
```

After any change to the optimizer we have to recompile all libraries. If we don't know exactly where to make our changes, this can take a lot of time.

It turned out to be very useful not to search by selectively enabling the optimizer only on part of the code: Once we know which function is broken by the optimizer, we can easily run the optimizer on it separately to find out where it goes wrong.

The trick to making this work effectively was keeping around both the optimized and original code for every function:

```javascript
// input
f() {
    // original function body
}

// output
f() {
    if(sequence_no_for_f < threshold) {
        // original function body
    } else {
        // optimized function body
    }
}
```
Each function gets its own sequence number, starting from zero. We adjust the threshold value that determines which functions run the optimized function body to quickly close in on where the optimized version gives a different results.

## Conclusion

We have seen a few debugging strategies for code generated by the JavaScript backend. Most of them are a bit ad hoc and require modification of the compiler or the compiled code. Over time we will probably make more of them available through code generator flags and from a debugging version of the RTS.