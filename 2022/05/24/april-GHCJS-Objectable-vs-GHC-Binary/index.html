<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">Objectable vs GHC Binary | IOG Engineering</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Objectable vs GHC Binary | IOG Engineering"><meta data-rh="true" name="description" content="As part of the integration of GHCJS into GHC as a cross-compilation backend, we&#x27;ve converted the binary serialisation that GHCJS previously used, which was via its Objectable typeclass, into GHC&#x27;s internal Binary typeclass representation. In doing this, we gain access to instances for serialising many of GHC&#x27;s internal data types, and, importantly, we can reuse GHC&#x27;s mechanism for serialising its Name and FastString types, which are written to lookup tables in order to maintain identity, as well as allowing for space savings on disk."><meta data-rh="true" property="og:description" content="As part of the integration of GHCJS into GHC as a cross-compilation backend, we&#x27;ve converted the binary serialisation that GHCJS previously used, which was via its Objectable typeclass, into GHC&#x27;s internal Binary typeclass representation. In doing this, we gain access to instances for serialising many of GHC&#x27;s internal data types, and, importantly, we can reuse GHC&#x27;s mechanism for serialising its Name and FastString types, which are written to lookup tables in order to maintain identity, as well as allowing for space savings on disk."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-05-24T00:00:00.000Z"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary"><link data-rh="true" rel="alternate" href="https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary" hreflang="en"><link data-rh="true" rel="alternate" href="https://engineering.iog.io/2022/05/24/april-GHCJS-Objectable-vs-GHC-Binary" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.3f63ffa1.css">
<link rel="preload" href="/assets/js/runtime~main.840dcf4b.js" as="script">
<link rel="preload" href="/assets/js/main.522da32c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/iohk-logo.png" alt="IOG" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/iohk-logo-inverted.png" alt="IOG" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Engineering</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Recent</a><a class="navbar__item navbar__link" href="/tags">Tags</a><a class="navbar__item navbar__link" href="/archive">Archive</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/upgrading-to-ghc-9.14">Upgrading to ghc-9.14</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-06-12-ghc-update">IOG GHC Update #47</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-05-15-ghc-update">IOG GHC Update #46</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-04-24-ghc-update">IOG GHC Update #45</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-04-03-ghc-update">IOG GHC Update #44</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-03-13-ghc-update">IOG GHC Update #43</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-02-20-ghc-update">IOG GHC Update #42</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-01-30-ghc-update">IOG GHC Update #41</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2025-01-09-ghc-update">IOG GHC Update #40</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-12-19-ghc-update">IOG GHC Update #39</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-11-28-ghc-update">IOG GHC Update #38</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-11-07-ghc-update">IOG GHC Update #37</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-10-17-ghc-update">IOG GHC Update #36</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-09-26-ghc-update">IOG GHC Update #35</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-09-05-ghc-update">IOG GHC Update #34</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-08-15-ghc-update">IOG GHC Update #33</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-07-24-ghc-update">IOG GHC Update #32</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-07-08-ghc-update">IOG GHC Update #31</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-06-17-ghc-update">IOG GHC Update #30</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/2024-05-23-ghc-update">IOG GHC Update #29</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Objectable vs GHC Binary</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-05-24T00:00:00.000Z" itemprop="datePublished">May 24, 2022</time> · <!-- -->11 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>As part of the integration of GHCJS into GHC as a cross-compilation backend, we&#x27;ve converted the binary serialisation that GHCJS previously used, which was via its <code>Objectable</code> typeclass, into GHC&#x27;s internal <code>Binary</code> typeclass representation. In doing this, we gain access to instances for serialising many of GHC&#x27;s internal data types, and, importantly, we can reuse GHC&#x27;s mechanism for serialising its <code>Name</code> and <code>FastString</code> types, which are written to lookup tables in order to maintain identity, as well as allowing for space savings on disk.</p><p>In this post, we will explain how the GHC <code>Binary</code> and GHCJS <code>Objectable</code> approaches work, and compare their tradeoffs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-ghc-binary-works">How GHC Binary Works<a href="#how-ghc-binary-works" class="hash-link" aria-label="Direct link to How GHC Binary Works" title="Direct link to How GHC Binary Works">​</a></h2><p>Internally, GHC uses the <code>Name</code> data type to track the uniqueness of objects during compilation. Amongst information relating to the definition of a <code>Name</code> within the Haskell source, a <code>Name</code> also contains a <code>Unique</code> integer (the value of which is provided by the complation environment monad). Using this <code>Unique</code> integer, which is unpacked in <code>Name</code>&#x27;s definition, we can make O(1) equality comparisons without following further memory references - allowing for this operation to be very quick, which will have a large effect on compilation performance given how often it is used.</p><p><code>FastString</code> is used within GHC to store short, string-like data, and, similarly to <code>Name</code>, <code>FastString</code> uses a unique integer to allow for very fast equality comparisons. Primarily, <code>FastString</code> is used to represent variables and other definitions, and is used both in <code>Name</code> as the string-representation of a name with extra information attached, as well as directly, representing names that don&#x27;t require this extra information, such as local variables.</p><p>In GHC&#x27;s <code>.hi</code> interface files, <code>Name</code> and <code>FastString</code> are serialised differently compared to other data structures. They are written in the main data structure payload as indicies of a table, and these tables contain the actual string-like data of these types. So, an interface file might resemble:</p><ul><li>Header<ul><li>Magic number for recognising interface files</li><li>Pointer to <code>Name</code> symbol table</li><li>Pointer to <code>FastString</code> dictionary</li></ul></li><li>Main data structure payload</li><li><code>Name</code> symbol table</li><li><code>FastString</code> dictionary</li></ul><p>Importantly, the <code>FastString</code> dictionary must be written <em>after</em> the <code>Name</code> symbol table, because <code>Name</code>s contain <code>FastString</code>s, so writing the symbol table will expand the dictionary. Additionally, because we only have one buffer, and we don&#x27;t know the size of the payload until it&#x27;s written, the tables cannot be written in the header, and instead serialisation code must reserve space for the table pointers and jump back to write the pointers once the table locations are known.</p><p>During serialisation, GHC uses mutable data structures to store both the serialised binary buffer, as well as these tables:</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">data BinHandle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  = BinMem {                     -- binary data stored in an unboxed array</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bh_usr :: UserData,         -- sigh, need parameterized modules :-)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     _off_r :: !FastMutInt,      -- the current offset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     _sz_r  :: !FastMutInt,      -- size of the array (cached)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     _arr_r :: !(IORef BinArray) -- the array (bounds: (0,size-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data UserData =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   UserData {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -- for *deserialising* only:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ud_get_name :: BinHandle -&gt; IO Name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ud_get_fs   :: BinHandle -&gt; IO FastString,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -- for *serialising* only:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ud_put_nonbinding_name :: BinHandle -&gt; Name -&gt; IO (),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -- ^ serialize a non-binding &#x27;Name&#x27; (e.g. a reference to another</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -- binding).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ud_put_binding_name :: BinHandle -&gt; Name -&gt; IO (),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        -- ^ serialize a binding &#x27;Name&#x27; (e.g. the name of an IfaceDecl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ud_put_fs   :: BinHandle -&gt; FastString -&gt; IO ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here, we see that various functions are stored in the handle structure, to be later referenced by their respective types in their <code>GHC.Utils.Binary.Binary</code> typeclass instances. Notice that the instance of <code>Binary Name</code> references <code>ud_put_nonbinding_name</code> and <code>ud_get_name</code>. Similarly, the <code>Binary FastString</code> instance uses <code>ud_put_fs</code> and <code>ud_get_fs</code>.</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Binary a where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    put_   :: BinHandle -&gt; a -&gt; IO ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    put    :: BinHandle -&gt; a -&gt; IO (Bin a)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    get    :: BinHandle -&gt; IO a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">instance Binary FastString where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  put_ bh f =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case getUserData bh of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserData { ud_put_fs = put_fs } -&gt; put_fs bh f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  get bh =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case getUserData bh of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserData { ud_get_fs = get_fs } -&gt; get_fs bh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">instance Binary Name where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   put_ bh name =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case getUserData bh of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserData{ ud_put_nonbinding_name = put_name } -&gt; put_name bh name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   get bh =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      case getUserData bh of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UserData { ud_get_name = get_name } -&gt; get_name bh</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In <code>GHC.Iface.Binary</code>, helper types and functions are defined to store the <code>Name</code> symbol table and <code>FastString</code> dictionary in a mutable data structure. Here, <code>putFastString</code> is intended to be partially applied - passing it an appropriately initialised <code>BinDictionary</code> so that the resulting function can be stored in the <code>us_put_fs</code> field of the <code>UserData</code>. <code>allocateFastString</code> does the low-level work here, incrementing the index and modifying the mutable map (stored as a <code>UniqFM</code>, which is map keyed on types that contain <code>Unique</code>s - recalling that these are used for fast equality comparisons):</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">data BinDictionary = BinDictionary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bin_dict_next :: !FastMutInt, -- The next index to use</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bin_dict_map  :: !(IORef (UniqFM FastString (Int,FastString)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                -- indexed by FastString</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putFastString :: BinDictionary -&gt; BinHandle -&gt; FastString -&gt; IO ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putFastString dict bh fs = allocateFastString dict fs &gt;&gt;= put_ bh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">allocateFastString :: BinDictionary -&gt; FastString -&gt; IO Word32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">allocateFastString BinDictionary { bin_dict_next = j_r,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   bin_dict_map  = out_r} f = do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    out &lt;- readIORef out_r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let !uniq = getUnique f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case lookupUFM_Directly out uniq of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Just (j, _)  -&gt; return (fromIntegral j :: Word32)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Nothing -&gt; do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           j &lt;- readFastMutInt j_r</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           writeFastMutInt j_r (j + 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           writeIORef out_r $! addToUFM_Directly out uniq (j, f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           return (fromIntegral j :: Word32)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Later, in <code>GHC.Iface.Binary</code>, <code>getWithUserData</code> and <code>putWithUserData</code> will structure the header, and initialise the <code>UserData</code> functions to write to/read from mutable tables. Notice that we must first reserve header space for pointers to the lookup tables, as well as initialise the mutable tables, write these initialised structures to the <code>UserData</code> (for example, we see the previous <code>putFastString</code> partially applied here), then write the main payload, then write the lookup tables (<code>Name</code> symbol table first, because writing this can add to the <code>FastString</code> dictionary), and finally jump back to fill in the pointers to these tables:</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">putWithUserData :: Binary a =&gt; TraceBinIFace -&gt; BinHandle -&gt; a -&gt; IO ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">putWithUserData traceBinIface bh payload = do</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Remember where the dictionary pointer will go</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_p_p &lt;- tellBin bh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Placeholder for ptr to dictionary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    put_ bh dict_p_p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Remember where the symbol table pointer will go</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_p_p &lt;- tellBin bh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    put_ bh symtab_p_p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Make some initial state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_next &lt;- newFastMutInt 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_map &lt;- newIORef emptyUFM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bin_symtab = BinSymbolTable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         bin_symtab_next = symtab_next,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         bin_symtab_map  = symtab_map }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_next_ref &lt;- newFastMutInt 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_map_ref &lt;- newIORef emptyUFM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let bin_dict = BinDictionary {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       bin_dict_next = dict_next_ref,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       bin_dict_map  = dict_map_ref }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Put the main thing,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bh &lt;- return $ setUserData bh $ newWriteState (putName bin_dict bin_symtab)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  (putName bin_dict bin_symtab)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                  (putFastString bin_dict)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    put_ bh payload</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Write the symtab pointer at the front of the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_p &lt;- tellBin bh        -- This is where the symtab will start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    putAt bh symtab_p_p symtab_p  -- Fill in the placeholder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    seekBin bh symtab_p           -- Seek back to the end of the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Write the symbol table itself</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_next &lt;- readFastMutInt symtab_next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symtab_map  &lt;- readIORef symtab_map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    putSymbolTable bh symtab_next symtab_map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case traceBinIface of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      QuietBinIFace         -&gt; return ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      TraceBinIFace printer -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         printer (text &quot;writeBinIface:&quot; &lt;+&gt; int symtab_next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        &lt;+&gt; text &quot;Names&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- NB. write the dictionary after the symbol table, because</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- writing the symbol table may create more dictionary entries.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Write the dictionary pointer at the front of the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_p &lt;- tellBin bh          -- This is where the dictionary will start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    putAt bh dict_p_p dict_p      -- Fill in the placeholder</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    seekBin bh dict_p             -- Seek back to the end of the file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Write the dictionary itself</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_next &lt;- readFastMutInt dict_next_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dict_map  &lt;- readIORef dict_map_ref</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    putDictionary bh dict_next dict_map</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case traceBinIface of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      QuietBinIFace         -&gt; return ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      TraceBinIFace printer -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         printer (text &quot;writeBinIface:&quot; &lt;+&gt; int dict_next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        &lt;+&gt; text &quot;dict entries&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In summary, we see a number of structural characteristics of code using GHC&#x27;s Binary implementation:</p><ul><li>Use of a single buffer means that the lookup tables can&#x27;t be written in the header, so we have to reserve space for table pointers in the header, and jump back once we know where they will be located in order to write the pointers to the buffer. Essentially, an ordering of file sections is enforced by the data dependencies of the payload containing <code>Name</code>s and <code>FastString</code>s, and <code>Name</code>s containing <code>FastString</code>s - which means these must be written in this order, but reading must be done in the reverse order, causing the need for pointers in the header.</li><li>Jumping around in binary buffers results in weakly enforced types and fiddly, code that Haskell&#x27;s type system isn&#x27;t able to help us debug</li><li>Must carry about read/write functions for the lookup table types (<code>Name</code> and <code>FastString</code>), which are <code>undefined</code> during the opposite serialisation stage, and are hard-coded into the handle, reducing extensibility.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-objectable-works">How Objectable Works<a href="#how-objectable-works" class="hash-link" aria-label="Direct link to How Objectable Works" title="Direct link to How Objectable Works">​</a></h2><p>In comparison, GHCJS previously involved using instances of the <code>Objectable</code> typeclass to serialise its interface files:</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">import qualified Data.Binary as DB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data SymbolTable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  = SymbolTable !Int !(Map ShortText Int)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  deriving (Show)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type PutSM = St.StateT SymbolTable DB.PutM -- FIXME: StateT isn&#x27;t strict enough apparently</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type PutS  = PutSM ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type GetS  = ReaderT ObjEnv DB.Get</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Objectable a where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  put :: a -&gt; PutS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  get :: GetS a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  putList :: [a] -&gt; PutS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  putList = putListOf put</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  getList :: GetS [a]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  getList = getListOf get</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Here we see that GHCJS has opted for a different approach that avoids the mutable buffer by instead using <code>Data.Binary</code> instances that work via concatenating lazy <code>ByteString</code>s. Additionally, the mutable tables are replaced with a <code>State</code> monad that holds the symbol table as a <code>Map</code> structure.</p><p>Because <code>Data.Binary</code> forms lazy <code>ByteString</code>s, it&#x27;s trivial to serialise the individual parts of the interface file and later concatenate these using <code>ByteString</code>&#x27;s monoid instance - allowing for all of the sections of the file to be defined declaratively at the top-level of the function in order of their appearance within the file.</p><div class="language-haskell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-haskell codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">object&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  :: ModuleName                 -- ^ module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt; SymbolTable                -- ^ final symbol table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt; Deps                       -- ^ dependencies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt; [([ShortText],ByteString)] -- ^ serialized units and their exported symbols, the first unit is module-global</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  -&gt; ByteString</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">object&#x27; mod_name st0 deps0 os = hdr &lt;&gt; symbs &lt;&gt; deps1 &lt;&gt; idx &lt;&gt; mconcat (map snd os)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  where</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hdr          = putHeader (Header (moduleNameTag mod_name) (bl symbs) (bl deps1) (bl idx))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bl           = fromIntegral . B.length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    deps1        = putDepsSection deps0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (sti, idx)   = putIndex st0 os</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    symbs        = putSymbolTable sti</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>In summary, the use of multiple <code>ByteString</code> sections that are later concatenated offer several different structural characteristics compared to the use of a single mutable buffer:</p><ul><li>The final ordering of the sections is flexible, because they are serialsied separately, so any data dependencies don&#x27;t introduce ordering in the file - which we see in the <code>where</code> clause of <code>object&#x27;</code></li><li>Types are more strongly enforced because imperative <code>seekBin</code> instructions aren&#x27;t required. However, each section is still <em>deserialised</em> by taking a substring of the file to be read as that section type. Of course, all serialisation eventually results in raw binary, so the simplification of concatenating the sections into the final file without jumping around limits the places that bugs can hide</li><li>Visually, the ordering of the sections within the final file is very clear - we see in <code>object&#x27;</code> that every section is simply listed <em>in order</em> on one line, concatenated together.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>Making use of GHC&#x27;s existing infrastructure lets the GHCJS backend to make use of the <code>FastString</code> and <code>Name</code> data types, as well as allowing for the removal of a significant amount of now-redundant code.</p><p>Additionally, interface file generation using GHC&#x27;s <code>Binary</code> appears to be very fast - for example, attempts to hide the handle behind a reader monad significantly reduce the compiler&#x27;s performance as measured by CI. Speculatively, looking at the generated core, this could be because the optimiser has a much better time with the style of IO code that is used - rather than being a limitation of more abstacted approaches.</p><p>The comparison provided the GHCJS&#x27;s old approach makes it clear that GHC&#x27;s <code>Binary</code> implementation, while very useful, has potential to be improved in both readability and extensiblity. However, because CI has shown that serialisation performance has a significant effect on overall compilation performance, this tradeoff must be considered when making any changes. Potentially, these readability shortfalls in GHC&#x27;s implementation might just be the result of legacy code, and so benchmarks of other approaches, such as <code>Data.Binary</code>, should be used to guide future work in improving the readability and flexibility of GHC&#x27;s serialisation without sacrificing performance.</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col margin-top--sm"><a href="https://github.com/input-output-hk/engineering/tree/master/blog/2022-05-24-april-GHCJS-Objectable-vs-GHC-Binary.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/2022-06-01-ghc-update"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">GHC DevX May 2022 Update</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/2022-05-17-javascript-template-haskell-external-interpreter"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">JavaScript, Template Haskell and the External Interpreter</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#how-ghc-binary-works" class="table-of-contents__link toc-highlight">How GHC Binary Works</a></li><li><a href="#how-objectable-works" class="table-of-contents__link toc-highlight">How Objectable Works</a></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://twitter.com/iog_eng" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://iohk.io/en/blog" target="_blank" rel="noopener noreferrer" class="footer__link-item">IOG Blog</a></li><li class="footer__item"><a href="https://github.com/input-output-hk/" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 IOG Engineering, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.840dcf4b.js"></script>
<script src="/assets/js/main.522da32c.js"></script>
</body>
</html>